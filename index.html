<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/study-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/study-16x16.png">
  <link rel="mask-icon" href="/images/study.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="只争朝夕">
<meta property="og:type" content="website">
<meta property="og:title" content="Magic">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Magic">
<meta property="og:description" content="只争朝夕">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Kaixuan Wang">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Magic</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Magic</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/03/22/thrift/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Kaixuan Wang">
      <meta itemprop="description" content="只争朝夕">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Magic">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/22/thrift/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-03-22 13:17:46 / 修改时间：13:21:20" itemprop="dateCreated datePublished" datetime="2023-03-22T13:17:46+08:00">2023-03-22</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>目录</p>
<h1 id="一、基本介绍"><a href="#一、基本介绍" class="headerlink" title="一、基本介绍"></a>一、基本介绍</h1><p><img src="/2023/03/22/thrift/1.png"></p>
<h2 id="1-1、client端"><a href="#1-1、client端" class="headerlink" title="1.1、client端"></a>1.1、client端</h2><ul>
<li><p>netty client：客户端与服务端的网络通信由netty完成。</p>
</li>
<li><p>客户端代理：RPC要求像调用本地函数一样调用远程函数，需要向调用方屏蔽调用细节。pigeon使用代理模式实现</p>
</li>
<li><p>客户端filter：代理模式的具体实现，是用责任链模式衔接，为框架提供了高可扩展性。Filter 中包含：服务监控、服务路由、故障注入、服务鉴权、服务降级、服务调用等模块</p>
</li>
<li><p>连接池：调用端做IO操作时需要创建的对象。一个客户端可以和多个服务端相连，这些连接在服务端的连接池中维护</p>
</li>
<li><p>线程池：收到服务端返回的数据后，通知业务线程</p>
</li>
<li><p>netty client：客户端与服务端的网络通信由netty完成。其包含 Boss（ Reactor 模型中的 MainReactor ）、Worker（Reactor 模型中的 SubReactor）以及基于Channel 的 Pipeline</p>
<ul>
<li>boss：在客户端中，负责发起connect请求；在服务端中，负责accept客户端发起的connect请求</li>
<li>worker：负责轮询连接是否有数据到达，并负责将数据读写到相应的channel中</li>
<li>pipeline：负责对channel中的数据进行加工<h2 id="1-2、server端"><a href="#1-2、server端" class="headerlink" title="1.2、server端"></a>1.2、server端</h2></li>
</ul>
</li>
<li><p>服务端filter：与客户端filter对应，请求在进入业务代码前，要经过服务监控、服务鉴权、服务限流等模块</p>
</li>
<li><p>线程池：将业务逻辑从I/O中剥离，数据准备好后，业务代码将在业务线程中执行</p>
</li>
<li><p>netty server：与netty client类似</p>
<h2 id="1-3、远程服务调用的执行过程"><a href="#1-3、远程服务调用的执行过程" class="headerlink" title="1.3、远程服务调用的执行过程"></a>1.3、远程服务调用的执行过程</h2><p><img src="/2023/03/22/thrift/2.png"></p>
</li>
</ul>
<ol>
<li>首先在客户端调用远程服务方法时，其真正调用的是 InvocationHandler 的 invoke 方法（这里使用 JDK 的动态代理）。Pigeon 中 InvocationHandler 的实现为 ServiceInvocationProxy， 所以调用接口声明的任意方法最终都会进到 ServiceInvocationProxy.invoke 方法</li>
<li>ServiceInvocationProxy.invoke 中会调用客户端 Filter ，请求会依次经过 监控、路由、降级、网关、鉴权 等模块后，进入 RemoteCallInvokeFilter</li>
<li>在 RemoteCallInvokeFilter 中调用 Client.write 方法，其逻辑为从连接池（ChannelPool）中 获取连接（获取连接的超时时间默认为：2000ms），然后将数据写进 Channel</li>
<li>在向服务端发送数据之前，需经过 Channel 的 Pipeline（序列化、压缩等，减少网络传输的数据量）</li>
<li>开始向服务端发送数据，由于 Netty 发送消息是异步的，所以如果是同步调用的话，Pigeon 这里会让业务线程主动 await ，直到收到服务端响应或超时后唤醒。</li>
<li>服务端收到客户端发过的消息后，从 Channel 中将消息读出来之前，也会先经过一些 Pipeline（反序列化、解压缩等）后到达 NettyServerHandler。pigeon在该步骤有服务隔离的设计<ul>
<li>默认的隔离机制：当超时数达到300，或超时率超过5%，将后续对应请求放入slow线程池处理；其他情况，将后续对应请求放入shared线程池处理</li>
<li>默认开启方法限流：单个方法不能占用超过380个线程</li>
<li>提供业务自定义独立线程池支持</li>
</ul>
</li>
<li>在选择相应的线程池并成功的拿到线程后，请求就到了服务端 Filter 中。请求会依次经过 监控、流量录制、鉴权、泛化调用、网关等模块后，进入 BusinessProcessFilter</li>
<li>BusinessProcessFilter 中会根据客户端传递来的服务信息和参数，通过反射调用相应的业务服务并拿到业务处理结果。然后在 WriteResponseProcessFilter 中将返回结果写入 Channel</li>
<li>返回结果再经过服务端的 Pipeline 处理（序列化、压缩等），就发给客户端</li>
<li>客户端收到消息后，经过客户端的 Pipeline 处理（反序列化、解压缩等）后到达 NettyClientHandler,然后交给 ResponseThreadPoolProcessor 线程池处理</li>
<li>ResponseThreadPoolProcessor 收到消息后，会通知之前 await 的业务线程，并将结果传递给他</li>
<li>业务线程收到 signal 通知后，就将结果返回给之前的方法调用</li>
</ol>
<p><img src="/2023/03/22/thrift/3.png"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/03/22/kafka/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Kaixuan Wang">
      <meta itemprop="description" content="只争朝夕">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Magic">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/22/kafka/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-03-22 13:07:16 / 修改时间：13:16:53" itemprop="dateCreated datePublished" datetime="2023-03-22T13:07:16+08:00">2023-03-22</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="消息队列概述"><a href="#消息队列概述" class="headerlink" title="消息队列概述"></a>消息队列概述</h1><ul>
<li><p><strong>消息队列：</strong>不同进程之间通信或者统一进程下的不同线程通信。主要解决**<em>应用耦合、异步消息、流量削峰</em>**问题</p>
<ul>
<li>发送者只管发送消息，接受者只管接收消息，发送者和接受者之间可以不存在任何联系<h2 id="异步处理"><a href="#异步处理" class="headerlink" title="异步处理"></a>异步处理</h2></li>
</ul>
</li>
<li><p>将原本串行执行的业务，通过消息队列的形式进行分块异步执行，处理速度更快</p>
</li>
</ul>
<p><img src="/2023/03/22/kafka/1.png"><br><img src="/2023/03/22/kafka/2.png"></p>
<h2 id="应用解耦"><a href="#应用解耦" class="headerlink" title="应用解耦"></a>应用解耦</h2><ul>
<li>A系统进行订单创建，需要通知B、C系统作相应操作。A系统是强依赖BC系统的，如果此时BC系统出现了问题，换成了另一个D系统，则代码就需要进行修改</li>
<li>使用消息队列的方式，A系统只用发送消息即可，不用再关心BC系统的状态，进行了解耦</li>
</ul>
<p><img src="/2023/03/22/kafka/3.png"></p>
<h2 id="流量削峰"><a href="#流量削峰" class="headerlink" title="流量削峰"></a>流量削峰</h2><ul>
<li>某个系统平时qps比较低，做活动时qps激增，但系统的处理能力达不到，可以使用消息队列的形式，一方面可以缓解qps压力，另一方面也可以控制参加活动人数，超过限制就丢弃</li>
</ul>
<p><img src="/2023/03/22/kafka/4.png"></p>
<h1 id="Kafka介绍"><a href="#Kafka介绍" class="headerlink" title="Kafka介绍"></a>Kafka介绍</h1><ul>
<li>Kafka是一种高吞吐量的分布式发布订阅消息系统，它可以处理消费者规模的网站中的所有动作流数据</li>
</ul>
<p><img src="/2023/03/22/kafka/5.png"></p>
<ul>
<li>基本组件：<ul>
<li><strong>Broker：</strong>消息中间件处理节点，一个Kafka节点就是一个Broker，一个或者多个Broker可以组成一个Kafka集群</li>
<li><strong>Topic：</strong>每条发布到Kafka集群的消息都有一个类别，这个类别被称为Topic。（物理上不同Topic的消息分开存储，逻辑上一个Topic的消息虽然保存于一个或多个broker上但用户只需指定消息的Topic即可生产或消费数据而不必关心数据存于何处）</li>
<li><strong>Partition</strong>：用于存放消息的队列，存放的消息都是<strong>有序</strong>的。同一个topic可以分多个partition</li>
<li><strong>Producer：</strong>消息生产者，向Broker发送消息的客户端</li>
<li><strong>Consumer</strong>：消息消费者，从Broker读取消息的客户端，通过offset进行标识消息被消费的位置</li>
<li><strong>Consumer Group：</strong>每个consumer都属于一个group，一条消息可以发送到多个不同的group，但是一个group内只有一个consumer能够消费该信息</li>
</ul>
</li>
<li>主要特性：<ul>
<li><strong>快速持久化</strong>：可以在 O(1) 的系统开销下进行消息持久化</li>
<li><strong>高吞吐</strong>：在一台普通的服务器上既可以达到10W/s的吞吐速率</li>
<li><strong>完全的分布式系统</strong>：Broker、Producer和Consumer都原生自动支持分布式，自动实现负载均衡</li>
<li>**零拷贝技术(zero-copy)**：减少IO操作步骤，提高系统吞吐量</li>
<li>支持同步和异步复制两种高可用机制</li>
<li>丰富的消息拉取模型，支持数据批量发送和拉取</li>
<li>数据迁移、扩容对用户透明</li>
<li>无需停机即可扩展机器</li>
<li>高效订阅者水平扩展、实时的消息订阅、亿级的消息堆积能力、定期删除机制<h2 id="消息队列对比"><a href="#消息队列对比" class="headerlink" title="消息队列对比"></a>消息队列对比</h2><table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th><strong>RabbitMQ</strong></th>
<th><strong>RocketMQ</strong></th>
<th><strong>Kafka</strong></th>
<th><strong>ActiveMQ</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>开发语言</strong></td>
<td>Erlang</td>
<td>Java</td>
<td>Scala&amp;Java</td>
<td>Java</td>
</tr>
<tr>
<td><strong>客户端支持</strong></td>
<td>官方支持Erlang、Java、Ruby等，社区产出多语言API，几乎支持所有常用语言</td>
<td>Java、C++</td>
<td>官方支持Java，社区有多语言版本，如PHP、Python、Go、C/C++、Ruby、NodeJs等</td>
<td>Java、C/C++、Python、PHP、Perl、.net等</td>
</tr>
<tr>
<td><strong>协议支持</strong></td>
<td>AMQP、XMPP、SMTP、SMTOP</td>
<td>自定义协议，社区提供JMS</td>
<td>自定义协议，社区提供了HTTP协议支持</td>
<td>OpenWire、SMTOP、REST、XMPP、AMQP</td>
</tr>
<tr>
<td><strong>可用性</strong></td>
<td>高，基于主从架构实现高可用</td>
<td>很高，分布式架构</td>
<td>很高，分布式，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用</td>
<td>高，基于主从架构实现高可用</td>
</tr>
<tr>
<td><strong>集群</strong></td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td><strong>负载均衡</strong></td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td><strong>单机吞吐量</strong></td>
<td>万级</td>
<td>十万级</td>
<td>十万级</td>
<td>万级</td>
</tr>
<tr>
<td><strong>topic数量对吞吐量的影响</strong></td>
<td>-</td>
<td>topic达到几百/几千的级别后，吞吐量会有较小幅度的下降，在同等机器下，可以支撑大量的 topic</td>
<td>topic从几十到几百个时候，吞吐量会大幅度下降，因为Kafka的每个Topic、每个分区都会对应一个物理文件，若需要支撑大规模的topic，则需要增加更多的机器资源</td>
<td>-</td>
</tr>
<tr>
<td><strong>消息批量操作</strong></td>
<td>不支持</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td><strong>消息推拉模式</strong></td>
<td>pull/push均支持</td>
<td>pull/push均支持</td>
<td>pull</td>
<td>pull/push均支持</td>
</tr>
<tr>
<td><strong>消息可靠性</strong></td>
<td>可以做到不丢失</td>
<td>可以做到不丢失</td>
<td>可以做到不丢失</td>
<td>有较低的概率丢失数据</td>
</tr>
<tr>
<td><strong>消息延迟</strong></td>
<td>微秒级 (最快)</td>
<td>毫秒级</td>
<td>毫秒级</td>
<td>毫秒级</td>
</tr>
<tr>
<td><strong>持久化能力</strong></td>
<td>内存、文件，支持数据堆积，但影响生产速率</td>
<td>磁盘文件</td>
<td>磁盘文件，只要容量够，可以做到无限堆积</td>
<td>内存、文件、数据库</td>
</tr>
<tr>
<td><strong>事务消息</strong></td>
<td>不支持</td>
<td>支持</td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td><strong>管理界面</strong></td>
<td>web管理界面</td>
<td>web管理界面</td>
<td>web管理界面</td>
<td>web管理界面</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
</ul>
<h1 id="Kafka架构设计"><a href="#Kafka架构设计" class="headerlink" title="Kafka架构设计"></a>Kafka架构设计</h1><p><strong>2.1、设计思想</strong></p>
<ul>
<li>最基本的架构：producer发布一个消息到topic，topic的消息存于broker，consumer订阅这个topic，从broker中消费消息</li>
</ul>
<p><img src="/2023/03/22/kafka/6.png"></p>
<ul>
<li><p><strong>消息状态：</strong>消息是否被消费的状态保存在consumer中，broker不会在意消息被消费。consumer中会记录一个offset值，指向partition中下一条将要被消费的消息位置。offeset值设置错误可能会导致消息丢失或被消费多次</p>
</li>
<li><p><strong>消息持久化</strong>：kafka会把消息持久化在本地的文件系统中</p>
</li>
<li><p><strong>批量发送</strong>：以消息集合为单位批量发送，提高效率</p>
</li>
<li><p><strong>Push-and-Pull</strong>：producer向broker中Push消息，consumer从broker中pull消息</p>
</li>
<li><p>**分区机制(partition)**：producer可以决定将消息发送到topic的哪个分区，一个partition中的消息顺序就是producer发送的消息顺序，一个topic的partition数是可以指定的</p>
<h2 id="kafka系统架构"><a href="#kafka系统架构" class="headerlink" title="kafka系统架构"></a>kafka系统架构</h2><p><img src="/2023/03/22/kafka/7.png"></p>
</li>
<li><p>一个典型的Kafka集群中包含若干Producer、Broker、Consumer Group以及一个Zookeeper集群。Kafka通过Zookeeper管理Broker集群，Producer使用Push模式将消息发送到Broker，Consumer Group使用Pull模式从Broker订阅并消费消息</p>
</li>
<li><p>一个kafka集群中，一个服务器就是一个broker，broker可以水平无限扩展，同一个topic的消息可以分布在多个broker中</p>
</li>
<li><p>producer将消息发送到broker的partition leader节点，producer可以通过配置保证写入的消息不丢失，支持消息异步发送、批量发送</p>
</li>
<li><p>push模式的目标是尽可能以最快速度传递消息，pull模式可以根据consumer消费能力适当调整速率消费消息</p>
</li>
<li><p>为了提升整个集群的吞吐量，物理上一个Topic可以分成多个Partition，每个<strong>Partition在磁盘上对应一个文件夹</strong>，该文件夹下存放了这个Partition的所有消息文件和索引文件。假设有topic1和topic2两个Topic，且分别有13个和19个分区，则整个集群会生成32个文件夹</p>
</li>
<li><p>每个消息文件都是一个log entry序列，结构如下：</p>
<ul>
<li>一条完整的消息包含RECORD、offset以及message size。record为消息格式，offset标识消息在partition中的偏移量（逻辑值），message size表示消息的大小。message set包含一条或多条信息</li>
<li>record格式：<ul>
<li>crc32：crc32校验值，校验范围magic-value</li>
<li>magic：消息格式版本号</li>
<li>attributes：消息的属性，总共占1个字节，低3位表示压缩类型：0表示NONE、1表示GZIP、2表示SNAPPY、3表示LZ4，其余位保留</li>
<li>key length：消息的key长度，-1表示没有key</li>
<li>key：可选</li>
<li>value length：消息体长度，-1表示消息为空</li>
<li>value：消息体</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="/2023/03/22/kafka/8.png"></p>
<h2 id="消息发送"><a href="#消息发送" class="headerlink" title="消息发送"></a>消息发送</h2><ul>
<li>Producer发送消息到Broker时，会根据Paritition机制选择将消息存储到哪一个Partition。如果Partition机制设置合理，所有消息可以均匀分布到不同的Partition里，这样就实现了<strong>负载均衡</strong>。如果一个Topic对应一个文件，那这个文件所在的机器I/O将会成为这个Topic的性能瓶颈，而有了Partition后，不同的消息可以并行写入不同的Partition中，极大的提高了吞吐率。具体有以下几种策略：<ul>
<li>轮询策略：<ul>
<li>java客户端默认策略</li>
<li>保证消息最大限度平均分配到所有分区，默认情况下是最合理的分配方案</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="/2023/03/22/kafka/9.png"></p>
<ul>
<li>随机策略：从partition列表中随机选择一个</li>
<li>按消息键保存策略：<ul>
<li>kafka允许为每条消息定义消息键，key</li>
<li>一旦消息被定义了key，可以保证同一个key消息放在相同的分区</li>
</ul>
</li>
</ul>
<p><img src="/2023/03/22/kafka/10.png"></p>
<ul>
<li><p>自定义策略</p>
<h2 id="消息消费"><a href="#消息消费" class="headerlink" title="消息消费"></a>消息消费</h2></li>
<li><p>将offset信息写入到__consumer_offsets的topic</p>
</li>
<li><p>consumer group 采用pull方式消费消息，每个consumer消费哪个partition的消息需要一套机制。并且partition是可以水平扩展的，随着partition的扩展，consumer消费的partition也会改变</p>
</li>
<li><p>当以下事件发生时，kafka会进行分区分配：</p>
<ul>
<li>同一个consumer group中新增consumer</li>
<li>consumer离开当前的group</li>
<li>订阅的主题新增partition</li>
</ul>
</li>
<li><p>分区分配策略：</p>
<ul>
<li>Range策略：按照消费者的线程总数均分<ul>
<li>假设我们有个名为 T1 的主题，其包含了5个分区，然后我们有两个消费者（C1，C2）来消费这5个分区里面的数据，而且C1的 num.streams = 2，C2 的 num.streams = 1（这里num.streams指的是消费者的消费线程个数）。Range策略是对每个主题而言的，首先对同一个主题里面的分区按照序号进行排序，并对消费者按照顺序进行排序。在我们的例子里面，排完序的分区将会是0, 1, 2, 3, 4,；消费者线程排完序将会是C1-0, C1-1, C2-0。然后将partitions的个数除以消费者线程的总数来决定每个消费者线程消费几个分区。如果除不尽，那么前面几个消费者线程将会多消费一个分区。在我们的例子里面，我们有5个分区，3个消费者线程， 5 / 3 = 1，而且除不尽，那么消费者线程 C1-0 、C1-1将会多消费一个分区，所以最后分区分配的结果看起来是这样的：C1-0 将消费 0, 1分区，C1-1 将消费 2, 3 分区，C2-0 将消费4分区。具体消费示意图如下所示：</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="/2023/03/22/kafka/11.png"></p>
<ul>
<li>RoundRobin策略<ul>
<li>前提：同一个consumer group中的所有消费者线程数相同；每个consumer订阅的主题相同</li>
<li>将所订阅的主题的分区组成 TopicAndPartition 列表，然后对 TopicAndPartition 列表按照 hashCode 进行排序。分配时轮换分配</li>
</ul>
</li>
</ul>
<p><img src="/2023/03/22/kafka/12.png"></p>
<h2 id="消息可靠性"><a href="#消息可靠性" class="headerlink" title="消息可靠性"></a>消息可靠性</h2><ul>
<li>Kafka的高可靠性的保障来源于其健壮的副本（replication）策略。Kafka将为每个partition提供多个replication，同时将replication分布到整个集群的其它Broker中，数量可以通过参数设置。replication会选举一个Leader节点，其它节点为Follower节点，消息发送全部发送到Leader然后再通过同步算法同步到Follower节点中，当其中有replication不能工作会重新进行选举，即使部分Broker宕机仍然能保证整个集群高可用，消息不丢失</li>
</ul>
<p><img src="/2023/03/22/kafka/13.png"></p>
<h1 id="kafka高可用"><a href="#kafka高可用" class="headerlink" title="kafka高可用"></a>kafka高可用</h1><ul>
<li><p>保障一个或多个broke宕机后，剩下的broker及所有的partition都可以继续服务</p>
</li>
<li><p>kafka采用多机备份和消息应答的方式解决了数据丢失问题，通过一套失败恢复机制解决服务不可用问题</p>
<h2 id="消息备份"><a href="#消息备份" class="headerlink" title="消息备份"></a>消息备份</h2></li>
<li><p>ISR(In-Sync Replicas)：一个partition中与Leader保持同步的Replica列表，在replica.lag.time.max.ms时间内与Leader保持同步。Follower周期性地向Leader发送FetchRequest请求，请求数据同步</p>
</li>
<li><p>Acks：生产者发送消息中包含acks字段，代表Leader应答生产者前Leader收到的应答数</p>
<ul>
<li>acks=0：生产者无需服务端的任何确认，无法保证服务端接收到消息</li>
<li>acks=1：Leader在接收到消息之后立刻应答，无需等待所有Follower同步消息，如果Leader宕机，会产生数据丢失</li>
<li>acks=all：Leader需要等待ISR中所有副本都同步完毕再进行应答，响应时间为ISR中最慢的机器</li>
</ul>
</li>
<li><p>kafka副本对象的重要属性：</p>
<ul>
<li>LEO(log end offset)：日志末端偏移，指向副本日志中下一条消息的位移值（下一条消息的写入位置）</li>
<li>HW(high watermark)：已同步消息标识，因其类似于木桶效应中短板决定水位高度，故取名高水位线<ul>
<li>所有HW以下的数据都是备份过的，对于任何一个对象而言，HW不会大于LEO</li>
<li>Leader的HW值由ISR中所有备份的LE最小值决定（最慢的机器）</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="/2023/03/22/kafka/14.png"></p>
<h2 id="故障恢复"><a href="#故障恢复" class="headerlink" title="故障恢复"></a>故障恢复</h2><ul>
<li><p>kafka在集群所有Broker中选出一个Controller，负责各Partition的Leader选举以及Replica的重新分配。当出现Leader故障后，Controller会将Leader/Follower的变动通知到需为此作出响应的Broker</p>
<h3 id="Broker故障恢复"><a href="#Broker故障恢复" class="headerlink" title="Broker故障恢复"></a>Broker故障恢复</h3></li>
<li><p><strong>场景一：</strong>Broker和其他的Broker断开，ZooKeeper还和Broker0连接，认为它还存活</p>
</li>
</ul>
<p><img src="/2023/03/22/kafka/15.png"></p>
<ul>
<li><strong>Partition0：</strong>Broker0中的副本为Partition0的Leader，当Broker0超过_replica.lag.time.max.ms_没接收到Broker1、Broker2的**<em>FetchRequest</em>**同步请求后，Broker0选择将Partition0的ISR收缩到仅剩Broker0本身，并将ISR的变更同步到ZooKeeper；Broker0需要根据_min.insync.replicas_的配置值决定是否继续接收profucer数据</li>
<li><strong>Partition1：</strong>超过_replica.lag.time.max.ms_后，Broker1会将Broker0中的副本从Partition1的ISR中移除。若后续Broker0恢复连接并赶上了Broker1，则Broker1还会再将Broker0重新加入Partition1的ISR</li>
<li><strong>场景二：</strong>Broker和ZooKeeper断开连接，ZooKeeper会认为Broker0宕机</li>
</ul>
<p><img src="/2023/03/22/kafka/16.png"></p>
<ul>
<li><strong>Partition0：</strong><ul>
<li>ZooKeeper删除broker0后，该节点上注册的Watcher会通知Controller，Controller会发现Broker0为Partition0的Leader，于是从当前存活的ISR中选择了Broker2作为Partition0的新Leader。Controller通过<strong>LeaderAndIsrRequest</strong>将Leader变更通知到Broker1、Broker2，于是Broker1改向Broker2发送Partition0数据的FetchRequest请求</li>
<li>生产者每隔60秒会从_bootstrap.servers_中的Broker获取最新的metadata，当发现Partition0的Leader发生变更后，会改向新Leader-Broker2发送Partition0数据。另一边，Broker0收不到ZooKeeper通知，依然认为自己是Partition0的Leader；由于Broker1、Broker2不再向Broker0发送FetchRequest请求，缺失了ISR应答的Broker0停止写入acks=all的消息，但可以继续写入acks=1的消息。_replica.lag.time.max.ms_时间后，Broker0尝试向ZooKeeper发送ISR变更请求但失败了，于是不再接收生产者的消息</li>
<li>当Broker0与ZooKeeper恢复连接后，发现自己不再是Partition0的Leader，于是将本地日志截断(为了保证和Leader数据一致性)，并开始向Broker2发送FetchRequest请求。<strong>在Broker0与ZooKeeper失联期间写入Broker0的所有消息由于未在新Leader中备份，这些消息都丢失了</strong>。</li>
</ul>
</li>
<li><strong>Partition1：</strong>Broker0中的副本只是作为Partition1的Follower节点，而Broker0与Broker1依然保持连接，因此Broker0依然会向Broker1发送FetchRequest。只要Broker0能继续保持同步，Broker1也不会向ZooKeeper变更ISR。</li>
<li>Broker故障恢复过程：Controller负责选举受影响的Partition的新Leader，并通知相关Broker</li>
</ul>
<p><img src="/2023/03/22/kafka/17.png"></p>
<ul>
<li><p>受到影响的Broker会收到Controller发送的LeaderAndIsrRequest请求后，Broker通过ReplicaManager的becomeLeaderOrFollower方法响应LeaderAndIsrRequest：<strong>新Leader会将HW更新为它的LEO值，而Follower则通过一系列策略截断log以保证数据一致性</strong></p>
<h3 id="Controller故障恢复"><a href="#Controller故障恢复" class="headerlink" title="Controller故障恢复"></a>Controller故障恢复</h3><p><img src="/2023/03/22/kafka/18.png"></p>
</li>
<li><p>场景1：controller与zookeeper断开连接。</p>
<ul>
<li>ZooKeeper会将Controller临时节点删除，并按照故障恢复过程重新竞选出新Controller。原本的Controller由于无法连上ZooKeeper，它什么也执行不了；当它与ZooKeeper恢复连接后发现自己不再是Controller，会在Kafka集群中充当一个普通的Broker</li>
</ul>
</li>
<li><p>场景2：Controller与某个broker断开连接。</p>
<ul>
<li>因为Controller无法通知到Broker0，所以Broker0不知道Partition0的Leader已经更换，所以也会出现broker和zookeeper断开连接时，短暂服务不可用和可能发生数据丢失的情况<h3 id="Controller故障恢复过程"><a href="#Controller故障恢复过程" class="headerlink" title="Controller故障恢复过程"></a>Controller故障恢复过程</h3></li>
</ul>
</li>
<li><p>kafka将所有的broker都在zookeeper的controller节点上注册一个watcher，controller发生故障时，注册在上面的watcher会触发，所有存活的broker竞争成为新的controller（一个）</p>
</li>
<li><p>新的controller会在以下节点上注册watcher，监控boker的运行，负责leader宕机恢复，对管理的脚本做出响应</p>
<ul>
<li>在/admin节点上注册Watcher，以应对管理员脚本对Topic及Partition的影响</li>
<li>在/brokers/ids节点上注册Watcher，以获取各Brokers的状态变化</li>
<li>在/brokers/topics节点上注册Watcher，以监控每个Partition的ISR副本状态<h1 id="kafka高性能架构设计"><a href="#kafka高性能架构设计" class="headerlink" title="kafka高性能架构设计"></a>kafka高性能架构设计</h1><h2 id="kafka系统架构-1"><a href="#kafka系统架构-1" class="headerlink" title="kafka系统架构"></a>kafka系统架构</h2><img src="/2023/03/22/kafka/19.png"></li>
</ul>
</li>
<li><p>Producer生产消息会涉及大量的消息网络传输，如果Producer每生产一个消息就发送到Broker会造成大量的网络消耗，严重影响到Kafka的性能。为了解决这个问题，Kafka使用了<strong>批量发送</strong>的方式。 Broker在持久化消息、读取消息的时候，如果采用传统的IO读写方式，会严重影响Kafka的性能，为了解决这个问题，Kafka采用了<strong>顺序写+零拷贝</strong>的方式</p>
<h2 id="批量发送"><a href="#批量发送" class="headerlink" title="批量发送"></a>批量发送</h2></li>
<li><p>producer生成消息发送到broker的过程：</p>
<ul>
<li>Kafka通过将Topic划分成多个Partition，Producer将消息分发到多个本地Partition的消息队列中，每个Partition消息队列中的消息会写入到不同的Leader节点。如图所示，消息经过路由策略，被分发到不同的Partition对应的本地队列，然后再批量发送到Partition对应的Leader节点</li>
</ul>
</li>
</ul>
<p><img src="/2023/03/22/kafka/20.png"></p>
<ul>
<li>消息路由：相同topic的消息分为多个partition，消息分配到哪个partition的策略为路由策略<ul>
<li>round robin：producer将消息均分到每个partition，最常见策略</li>
<li>散列：kafka对消息的key进行散列，根据散列值将消息路由到特定的partition，相同的key会路由到相同的partition</li>
<li>自定义策略</li>
</ul>
</li>
<li>发送流程：producer生产消息，序列化压缩之后，追加到本地的记录收集器，sender不断轮询，满足一定条件才将收集器中的数据发送到broker中<ul>
<li>消息大小达到阈值</li>
<li>消息等待发送时间达到阈值</li>
</ul>
</li>
</ul>
<p><img src="/2023/03/22/kafka/21.png"></p>
<blockquote>
<p>Producer会为每个Partition都创建一个双端队列来缓存客户端消息，队列的每个元素是一个批记录(ProducerBatch)，批记录使用createdMs表示批记录的创建时间(批记录中第一条消息加入的时间)， topicPartion表示对应的Partition元数据。当Producer生产的消息经过序列化，会被先写入到recordsBuilder对象中。一旦队列中有批记录的大小达到阈值，就会被Sender发送到Partition对应的Leader节点；若批记录等待发送的时间达到阈值，消息也会被发送到Partition对应的Leader节点中。<br><img src="/2023/03/22/kafka/22.png"></p>
</blockquote>
<ul>
<li><p>具体流程：</p>
<ul>
<li>消息被记录收集器收集，按照partition追加到队列尾部的批记录中</li>
<li>sender通过ready()从收集器中找出准备好的服务端节点</li>
<li>如果客户端还没有和服务端节点建立连接，通过connect()建立连接</li>
<li>sender通过drain()从记录收集器获取按照节点整理好的每个批记录</li>
<li>sender得到每个节点的批记录后，为每个节点创建客户端请求，并将消息发送到服务端<h2 id="消息持久化"><a href="#消息持久化" class="headerlink" title="消息持久化"></a>消息持久化</h2><h3 id="随机IO和顺序IO"><a href="#随机IO和顺序IO" class="headerlink" title="随机IO和顺序IO"></a>随机IO和顺序IO</h3><img src="/2023/03/22/kafka/23.png"></li>
</ul>
</li>
<li><p>一次读数据请求分为三个动作：</p>
<ul>
<li>寻道：磁头移动到指定的磁道上，时间代价最高，最长需要0.1s左右</li>
<li>旋转延迟：将对应扇区旋转到磁头下</li>
<li>数据传输：数据通过系统总线从磁盘传输到内存</li>
</ul>
</li>
<li><p>随机IO:数据分布在磁盘的不同盘片的不同扇区中，获取数据需要将磁臂旋转到指定盘片，再通过盘片寻找到指定扇区才能获得数据。由于需要多次切换，读取速度较慢</p>
</li>
<li><p>顺序IO：数据分布在一起，找到第一块数据后，其他需要的数据就在第一块数据的后面，不需要多次切换寻址，读取速度较快</p>
<h3 id="broker写消息"><a href="#broker写消息" class="headerlink" title="broker写消息"></a>broker写消息</h3></li>
<li><p>broker需要将大量的消息持久化，存在大量的查询场景。因此kafka采用顺序写的方式进行消息持久化</p>
</li>
<li><p>producer传递给broker的每条消息都有一个顺序值，代表producer生产消息的顺序。producer创建的消息集中，每条消息的顺序值只是相对于本批次的序号，服务端会将每条消息的顺序值转换为绝对偏移量。kafka通过nextOffset来记录存储在日志中最近一条消息的偏移量</p>
</li>
</ul>
<p><img src="/2023/03/22/kafka/24.png"></p>
<ul>
<li>broker将每个partition的消息追加到日志中，以日志分段为单位（segment）。当segment的大小达到阈值，会创建新的segment保存消息，每个segment都有一个基准偏移量（baseoffset），通过这个baseoffset可以计算出每条消息在partition中的绝对偏移量。每个segment由数据文件和索引文件组成，数据文件为消息内容，索引文件为消息偏移量的物理地址的索引</li>
</ul>
<p><img src="/2023/03/22/kafka/25.png"></p>
<h3 id="基于索引文件的查询"><a href="#基于索引文件的查询" class="headerlink" title="基于索引文件的查询"></a>基于索引文件的查询</h3><p><img src="/2023/03/22/kafka/26.png"></p>
<ul>
<li>索引查询流程：假设有1000条消息，每100条消息写满了一个日志分段，一共有10个日志分段。客户端要查询偏移量为938的消息内容，根据索引文件，我们可以在最后一个日志分段的索引文件中，首先使用绝对偏移量999减去基准偏移量900得到相对偏移量99，然后找到最接近相对偏移量99的索引数据90，相对偏移量90对应的物理地址是1365，然后再到数据文件中，从文件物理位置1365开始往后读消息，直到找到偏移量为999的消息</li>
<li>索引文件的特性：<ul>
<li>索引文件映射偏移量到文件的物理位置，它不会对每条消息都建立索引，所以是稀疏的</li>
<li>索引条目的偏移量存储的是相对于“基准偏移量”的“相对偏移量” ，不是消息的“绝对偏移量”</li>
<li>偏移量是有序的，查询指定的偏移量时，使用二分查找可以快速确定偏移量的位置</li>
<li>指定偏移量如果在索引文件中不存在，可以找到小于等于指定偏移量的最大偏移量</li>
<li>稀疏索引可以通过内存映射方式，将整个索引文件都放入内存，加快偏移量的查询</li>
</ul>
</li>
</ul>
<p><strong>4.4 零拷贝</strong></p>
<ul>
<li>零拷贝技术可以减少数据拷贝和共享总线操作的次数，消除传输数据在存储器之间不必要的中间拷贝次数，减少用户应用程序地址空间和操作系统内核地址空间之间因为上下文切换而带来的开销，从而有效地提高数据传输效率</li>
<li>传统读取数据并发送数据的过程：<ul>
<li>读操作，DMA进行数据拷贝，将数据从磁盘拷贝到内核空间</li>
<li>cpu将数据从内核空间拷贝到用户空间</li>
<li>调用send，cpu将数据从用户空间拷贝到内核空间的socket缓冲区</li>
<li>send结束，DMA将数据从内核拷贝到协议引擎</li>
</ul>
</li>
</ul>
<p><img src="/2023/03/22/kafka/27.png"></p>
<ul>
<li>零拷贝过程：简化了从内核空间拷贝到用户空间的过程<ul>
<li>sendfile通过DMA将文件内容拷贝到一个数据缓冲区，由内核将数据拷贝到与输出套接字相关联的内核缓冲区</li>
</ul>
</li>
</ul>
<p><img src="/2023/03/22/kafka/28.png"></p>
<ul>
<li>从具体实现来看，Kafka的数据传输通过TransportLayer来完成，其子类PlaintextTransportLayer通过Java NIO的FileChannel的transferTo()和transferFrom()方法实现零拷贝。transferTo()和transferFrom()并不保证一定能使用零拷贝，实际上是否能使用零拷贝与操作系统相关，如果操作系统提供sendfile这样的零拷贝系统调用，则这两个方法会通过这样的系统调用充分利用零拷贝的优势，否则并不能通过这两个方法本身实现零拷贝</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/01/09/30/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Kaixuan Wang">
      <meta itemprop="description" content="只争朝夕">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Magic">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/09/30/" class="post-title-link" itemprop="url">SpringBoot</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-01-09 18:08:56" itemprop="dateCreated datePublished" datetime="2022-01-09T18:08:56+08:00">2022-01-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-04-01 15:55:20" itemprop="dateModified" datetime="2022-04-01T15:55:20+08:00">2022-04-01</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>SpringBoot：能够快速创建出生产级别的Spring应用，简化了整合的过程</p>
<p>SpringBoot是整合Spring技术栈的一站式框架</p>
</blockquote>
<h1 id="SpringBoot入门"><a href="#SpringBoot入门" class="headerlink" title="SpringBoot入门"></a>SpringBoot入门</h1><h2 id="maven配置"><a href="#maven配置" class="headerlink" title="maven配置"></a>maven配置</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirrors</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus-aliyun<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>Nexus aliyun<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">mirrors</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">  <span class="tag">&lt;<span class="name">profiles</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">id</span>&gt;</span>jdk-1.8<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">activation</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">activeByDefault</span>&gt;</span>true<span class="tag">&lt;/<span class="name">activeByDefault</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">jdk</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">jdk</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">maven.compiler.compilerVersion</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.compilerVersion</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">profiles</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="主程序创建"><a href="#主程序创建" class="headerlink" title="主程序创建"></a>主程序创建</h2><ul>
<li><p>使用@SpringBootApplication注解</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 主程序类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@SpringBootApplication</span>：这是一个SpringBoot应用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(MainApplication.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>业务编写，使用@RestController，整合了@Controller和@ResponseBody两个注解</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">handler01</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello SpringBoot&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="简化配置"><a href="#简化配置" class="headerlink" title="简化配置"></a>简化配置</h2><ul>
<li>配置都写在application.properties文件中</li>
</ul>
<h1 id="自动装配原理"><a href="#自动装配原理" class="headerlink" title="自动装配原理"></a>自动装配原理</h1><h2 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h2><ul>
<li><p>父项目做依赖管理，不需要自己写版本号</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">依赖管理    </span><br><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line">他的父项目</span><br><span class="line"> <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line">几乎声明了所有开发中常用的依赖的版本号,自动版本仲裁机制。如果引入的依赖不再父项目中，需要自己写版本号</span><br><span class="line"></span><br><span class="line">如果需要自定义修改依赖版本号</span><br><span class="line">    1、查看spring-boot-dependencies里面规定当前依赖的版本 用的 key。</span><br><span class="line">    2、在当前项目里面重写配置</span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mysql.version</span>&gt;</span>5.1.43<span class="tag">&lt;/<span class="name">mysql.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>开发导入starter场景启动器</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1、见到很多 spring-boot-starter-* ： *代表某种场景</span><br><span class="line">2、只要引入starter，这个场景的所有常规需要的依赖我们都自动引入</span><br><span class="line">3、见到的  *-spring-boot-starter： 第三方为我们提供的简化开发的场景启动器。</span><br><span class="line">4、所有场景启动器最底层的依赖</span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="自动配置"><a href="#自动配置" class="headerlink" title="自动配置"></a>自动配置</h2><ul>
<li><p>自动配好Tomcat</p>
<ul>
<li>引入了Tomcat依赖</li>
<li>配置Tomcat</li>
</ul>
</li>
<li><p>自动配好SpringMVC</p>
<ul>
<li>引入SpringMVC全套组件</li>
<li>自动配好SpringMVC常用组件（功能）</li>
</ul>
</li>
<li><p>自动配好Web常见功能，如：字符编码问题</p>
<ul>
<li>SpringBoot帮我们配置好了所有web开发的常见场景</li>
</ul>
</li>
<li><p>默认的包结构</p>
<ul>
<li><p>主程序所在包及其下面的所有子包里面的组件都会被默认扫描进来</p>
</li>
<li><p>无需以前的包扫描配置</p>
</li>
<li><p>想要改变扫描路径，@SpringBootApplication(scanBasePackages=<strong>“com.atguigu”</strong>)或者@ComponentScan 指定扫描路径</p>
</li>
</ul>
</li>
<li><p>各种配置拥有默认值</p>
<ul>
<li>默认配置最终都是映射到某个类上，如：MultipartProperties</li>
<li>配置文件的值最终会绑定每个类上，这个类会在容器中创建对象</li>
</ul>
</li>
<li><p>按需加载所有自动配置项</p>
<ul>
<li><p>引入了哪些场景这个场景的自动配置才会开启</p>
</li>
<li><p>SpringBoot所有的自动配置功能都在 spring-boot-autoconfigure 包里面</p>
</li>
</ul>
</li>
</ul>
<h2 id="容器功能"><a href="#容器功能" class="headerlink" title="容器功能"></a>容器功能</h2><ul>
<li><p>组件添加，@Configuration</p>
<ul>
<li>Full模式与Lite模式:<ul>
<li>配置 类组件之间无依赖关系用Lite模式加速容器启动过程，减少判断</li>
<li>配置类组件之间有依赖关系，方法会被调用得到之前单实例组件，用Full模式</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1、配置类里面使用<span class="doctag">@Bean</span>标注在方法上给容器注册组件，默认也是单实例的</span></span><br><span class="line"><span class="comment"> * 2、配置类本身也是组件</span></span><br><span class="line"><span class="comment"> * 3、proxyBeanMethods：代理bean的方法</span></span><br><span class="line"><span class="comment"> *      Full(proxyBeanMethods = true)、【保证每个<span class="doctag">@Bean</span>方法被调用多少次返回的组件都是单实例的】</span></span><br><span class="line"><span class="comment"> *      Lite(proxyBeanMethods = false)【每个<span class="doctag">@Bean</span>方法被调用多少次返回的组件都是新创建的】</span></span><br><span class="line"><span class="comment"> *      组件依赖必须使用Full模式默认。其他默认是否Lite模式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration(proxyBeanMethods = true)</span> <span class="comment">//告诉SpringBoot这是一个配置类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Full:外部无论对配置类中的这个组件注册方法调用多少次获取的都是之前注册容器中的单实例对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span> <span class="comment">//给容器中添加组件。以方法名作为组件的id。返回类型就是组件类型。返回的值，就是组件在容器中的实例</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">user01</span><span class="params">()</span></span>&#123;</span><br><span class="line">        User zhangsan = <span class="keyword">new</span> User(<span class="string">&quot;zhangsan&quot;</span>, <span class="number">18</span>);</span><br><span class="line">        <span class="comment">//user组件依赖了Pet组件</span></span><br><span class="line">        zhangsan.setPet(tomcatPet());</span><br><span class="line">        <span class="keyword">return</span> zhangsan;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(&quot;tom&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Pet <span class="title">tomcatPet</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Pet(<span class="string">&quot;tomcat&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">################################<span class="meta">@Configuration</span>测试代码如下########################################</span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1、返回我们IOC容器</span></span><br><span class="line">        ConfigurableApplicationContext run = SpringApplication.run(MainApplication.class, args);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2、查看容器里面的组件</span></span><br><span class="line">        String[] names = run.getBeanDefinitionNames();</span><br><span class="line">        <span class="keyword">for</span> (String name : names) &#123;</span><br><span class="line">            System.out.println(name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3、从容器中获取组件</span></span><br><span class="line"></span><br><span class="line">        Pet tom01 = run.getBean(<span class="string">&quot;tom&quot;</span>, Pet.class);</span><br><span class="line"></span><br><span class="line">        Pet tom02 = run.getBean(<span class="string">&quot;tom&quot;</span>, Pet.class);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;组件：&quot;</span>+(tom01 == tom02));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//4、com.atguigu.boot.config.MyConfig$$EnhancerBySpringCGLIB$$51f1e1ca@1654a892</span></span><br><span class="line">        MyConfig bean = run.getBean(MyConfig.class);</span><br><span class="line">        System.out.println(bean);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果@Configuration(proxyBeanMethods = true)代理对象调用方法。SpringBoot总会检查这个组件是否在容器中有。</span></span><br><span class="line">        <span class="comment">//保持组件单实例</span></span><br><span class="line">        User user = bean.user01();</span><br><span class="line">        User user1 = bean.user01();</span><br><span class="line">        System.out.println(user == user1);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        User user01 = run.getBean(<span class="string">&quot;user01&quot;</span>, User.class);</span><br><span class="line">        Pet tom = run.getBean(<span class="string">&quot;tom&quot;</span>, Pet.class);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;用户的宠物：&quot;</span>+(user01.getPet() == tom));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>@Import</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> * <span class="meta">@Import(&#123;User.class, DBHelper.class&#125;)</span></span><br><span class="line"> *      给容器中自动创建出这两个类型的组件、默认组件的名字就是全类名</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line"><span class="meta">@Import(&#123;User.class, DBHelper.class&#125;)</span></span><br><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfig</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>@Conditional：条件装配</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">=====================测试条件装配==========================</span><br><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span> </span><br><span class="line"><span class="comment">//@ConditionalOnBean(name = &quot;tom&quot;) //有tom组件时装配</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean(name = &quot;tom&quot;)</span> <span class="comment">//没有tom组件时装配</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">user01</span><span class="params">()</span></span>&#123;</span><br><span class="line">        User zhangsan = <span class="keyword">new</span> User(<span class="string">&quot;zhangsan&quot;</span>, <span class="number">18</span>);</span><br><span class="line">        <span class="comment">//user组件依赖了Pet组件</span></span><br><span class="line">        zhangsan.setPet(tomcatPet());</span><br><span class="line">        <span class="keyword">return</span> zhangsan;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(&quot;tom22&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Pet <span class="title">tomcatPet</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Pet(<span class="string">&quot;tomcat&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1、返回我们IOC容器</span></span><br><span class="line">        ConfigurableApplicationContext run = SpringApplication.run(MainApplication.class, args);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2、查看容器里面的组件</span></span><br><span class="line">        String[] names = run.getBeanDefinitionNames();</span><br><span class="line">        <span class="keyword">for</span> (String name : names) &#123;</span><br><span class="line">            System.out.println(name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> tom = run.containsBean(<span class="string">&quot;tom&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;容器中Tom组件：&quot;</span>+tom);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> user01 = run.containsBean(<span class="string">&quot;user01&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;容器中user01组件：&quot;</span>+user01);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> tom22 = run.containsBean(<span class="string">&quot;tom22&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;容器中tom22组件：&quot;</span>+tom22);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>@ImportResource：从.xml注入组件，方便整合老项目</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;haha&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.boot.bean.User&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;zhangsan&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;18&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;hehe&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.boot.bean.Pet&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;tomcat&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ImportResource(&quot;classpath:beans.xml&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfig</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">======================测试=================</span><br><span class="line">        <span class="keyword">boolean</span> haha = run.containsBean(<span class="string">&quot;haha&quot;</span>);</span><br><span class="line">        <span class="keyword">boolean</span> hehe = run.containsBean(<span class="string">&quot;hehe&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;haha：&quot;</span>+haha);<span class="comment">//true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;hehe：&quot;</span>+hehe);<span class="comment">//true</span></span><br></pre></td></tr></table></figure></li>
<li><p>@ConfigurationProperties：配置绑定，将配置信息封装到JavaBean中</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">mycar.brand</span>=<span class="string">BYD</span></span><br><span class="line"><span class="meta">mycar.price</span>=<span class="string">100</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 只有在容器中的组件，才会拥有SpringBoot提供的强大功能</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;mycar&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String brand;</span><br><span class="line">    <span class="keyword">private</span> Integer price;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getBrand</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> brand;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBrand</span><span class="params">(String brand)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.brand = brand;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getPrice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPrice</span><span class="params">(Integer price)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Car&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;brand=&#x27;&quot;</span> + brand + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, price=&quot;</span> + price +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="自动配置原理"><a href="#自动配置原理" class="headerlink" title="自动配置原理"></a>自动配置原理</h2><ul>
<li><p>引导加载自动配置类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootConfiguration</span> <span class="comment">// 代表当前是一个配置类</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan(excludeFilters = &#123; @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),</span></span><br><span class="line"><span class="meta">		@Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)</span> <span class="comment">//开启注解扫描</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootApplication&#123;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>@EnableAutoConfiguration</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AutoConfigurationPackage</span></span><br><span class="line"><span class="meta">@Import(AutoConfigurationImportSelector.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAutoConfiguration &#123;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>@AutoConfigurationPackage：指定了默认的包规则</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Import(AutoConfigurationPackages.Registrar.class)</span>  <span class="comment">//给容器中导入一个组件</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> AutoConfigurationPackage &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//利用Registrar给容器中导入一系列组件</span></span><br><span class="line"><span class="comment">//将指定的一个包下的所有组件导入进来，MainApplication 所在包下。</span></span><br></pre></td></tr></table></figure></li>
<li><p>@Import(AutoConfigurationImportSelector.class)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、利用getAutoConfigurationEntry(annotationMetadata);给容器中批量导入一些组件</span><br><span class="line"><span class="number">2</span>、调用List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata, attributes)获取到所有需要导入到容器中的配置类</span><br><span class="line"><span class="number">3</span>、利用工厂加载 Map&lt;String, List&lt;String&gt;&gt; loadSpringFactories(<span class="meta">@Nullable</span> ClassLoader classLoader)；得到所有的组件</span><br><span class="line"><span class="number">4</span>、从META-INF/spring.factories位置来加载一个文件。</span><br><span class="line">	默认扫描我们当前系统里面所有META-INF/spring.factories位置的文件</span><br><span class="line">    spring-boot-autoconfigure-<span class="number">2.3</span><span class="number">.4</span>.RELEASE.jar包里面也有META-INF/spring.factories</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>按需开启自动配置项：127个场景的所有自动配置启动时默认全部加载，但使用@Conditional进行按需加载</p>
</li>
<li><p>SpringBoot默认会在底层配好所有的组件。但是如果用户自己配置了以用户的优先</p>
</li>
<li><p>总结：</p>
<ul>
<li><p>SpringBoot先加载所有的自动配置类  xxxxxAutoConfiguration</p>
</li>
<li><p>每个自动配置类按照条件进行生效，默认都会绑定配置文件指定的值。xxxxProperties里面拿。xxxProperties和配置文件进行了绑定</p>
</li>
<li><p>生效的配置类就会给容器中装配很多组件</p>
</li>
<li><p>只要容器中有这些组件，相当于这些功能就有了</p>
</li>
<li><p>定制化配置</p>
</li>
<li><ul>
<li>用户直接自己@Bean替换底层的组件</li>
<li>用户去看这个组件是获取的配置文件什么值就去修改。</li>
</ul>
</li>
</ul>
<blockquote>
<p> xxxxxAutoConfiguration —&gt; 组件  —&gt;xxxxProperties里面拿值  —-&gt; application.properties</p>
</blockquote>
</li>
</ul>
<h2 id="最佳使用流程"><a href="#最佳使用流程" class="headerlink" title="最佳使用流程"></a>最佳使用流程</h2><ul>
<li><p>引入场景依赖</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/current/reference/html/using-spring-boot.html#using-boot-starter">查看有哪些场景</a></li>
</ul>
</li>
<li><p>查看自动配置了哪些（选做）</p>
<ul>
<li>自己分析，引入场景对应的自动配置一般都生效了</li>
<li>配置文件中debug=true开启自动配置报告。Negative（不生效）\Positive（生效）</li>
</ul>
</li>
<li><p>是否需要修改</p>
<ul>
<li><p>参照文档修改配置项</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/current/reference/html/appendix-application-properties.html#common-application-properties">官方文档</a></li>
<li>自己分析。xxxxProperties绑定了配置文件的哪些。</li>
</ul>
</li>
</ul>
</li>
<li><p>自定义加入或者替换组件</p>
<ul>
<li>@Bean、@Component。。。</li>
</ul>
</li>
<li><p>自定义器  <strong>XXXXXCustomizer</strong>；</p>
</li>
<li><p>……</p>
</li>
</ul>
<h1 id="开发技巧"><a href="#开发技巧" class="headerlink" title="开发技巧"></a>开发技巧</h1><h2 id="Lombok"><a href="#Lombok" class="headerlink" title="Lombok"></a>Lombok</h2><ul>
<li>简化JavaBean开发</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">===============================简化JavaBean开发===================================</span><br><span class="line"><span class="meta">@NoArgsConstructor</span> <span class="comment">// 无参构造器</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span> <span class="comment">// 全参构造器</span></span><br><span class="line"><span class="meta">@Data</span> <span class="comment">//生成get set方法</span></span><br><span class="line"><span class="meta">@ToString</span> <span class="comment">//生成toString方法</span></span><br><span class="line"><span class="meta">@EqualsAndHashCode</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Pet pet;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String name,Integer age)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">================================简化日志开发===================================</span><br><span class="line"><span class="meta">@Slf4j</span>  <span class="comment">// 导入日志</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">handle01</span><span class="params">(<span class="meta">@RequestParam(&quot;name&quot;)</span> String name)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        log.info(<span class="string">&quot;请求进来了....&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello, Spring Boot 2!&quot;</span>+<span class="string">&quot;你好：&quot;</span>+name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="dev-tools"><a href="#dev-tools" class="headerlink" title="dev-tools"></a>dev-tools</h2><ul>
<li>热部署</li>
</ul>
<h2 id="Spring-Initailizr-初始化向导"><a href="#Spring-Initailizr-初始化向导" class="headerlink" title="Spring Initailizr(初始化向导)"></a>Spring Initailizr(初始化向导)</h2><ul>
<li>帮助新建项目</li>
</ul>
<h1 id="核心功能"><a href="#核心功能" class="headerlink" title="核心功能"></a>核心功能</h1><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><h3 id="yaml"><a href="#yaml" class="headerlink" title="yaml"></a>yaml</h3><ul>
<li><p>基本语法：</p>
<ul>
<li><p>key: value；kv之间有空格</p>
</li>
<li><p>大小写敏感</p>
</li>
<li><p>使用缩进表示层级关系</p>
</li>
<li><p>缩进不允许使用tab，只允许空格</p>
</li>
<li><p>缩进的空格数不重要，只要相同层级的元素左对齐即可</p>
</li>
<li><p>‘#’表示注释</p>
</li>
<li><p>字符串无需加引号，如果要加，’’与””表示字符串内容 会被 转义/不转义</p>
</li>
</ul>
</li>
<li><p>数据类型：</p>
<ul>
<li><p>字面量：单个的、不可再分的值。date、boolean、string、number、null</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">data1:true</span></span><br></pre></td></tr></table></figure></li>
<li><p>对象：键值对的集合。map、hash、set、object</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">行内写法：</span>  <span class="attr">k:</span> &#123;<span class="string">k1:v1</span>,<span class="string">k2:v2</span>,<span class="string">k3:v3</span>&#125;</span><br><span class="line"><span class="comment">#或</span></span><br><span class="line"><span class="attr">k:</span> </span><br><span class="line">  <span class="attr">k1:</span> <span class="string">v1</span></span><br><span class="line">  <span class="attr">k2:</span> <span class="string">v2</span></span><br><span class="line">  <span class="attr">k3:</span> <span class="string">v3</span></span><br></pre></td></tr></table></figure></li>
<li><p>数组：一组按次序排列的值。array、list、queue</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">行内写法：</span>  <span class="attr">k:</span> [<span class="string">v1</span>,<span class="string">v2</span>,<span class="string">v3</span>]</span><br><span class="line"><span class="comment">#或者</span></span><br><span class="line"><span class="attr">k:</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">v1</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">v2</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">v3</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> String userName;</span><br><span class="line">	<span class="keyword">private</span> Boolean boss;</span><br><span class="line">	<span class="keyword">private</span> Date birth;</span><br><span class="line">	<span class="keyword">private</span> Integer age;</span><br><span class="line">	<span class="keyword">private</span> Pet pet;</span><br><span class="line">	<span class="keyword">private</span> String[] interests;</span><br><span class="line">	<span class="keyword">private</span> List&lt;String&gt; animal;</span><br><span class="line">	<span class="keyword">private</span> Map&lt;String, Object&gt; score;</span><br><span class="line">	<span class="keyword">private</span> Set&lt;Double&gt; salarys;</span><br><span class="line">	<span class="keyword">private</span> Map&lt;String, List&lt;Pet&gt;&gt; allPets;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pet</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> Double weight;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># yaml表示以上对象</span></span><br><span class="line"><span class="attr">person:</span></span><br><span class="line">  <span class="attr">userName:</span> <span class="string">zhangsan</span></span><br><span class="line">  <span class="attr">boss:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">birth:</span> <span class="number">2019</span><span class="string">/12/12</span> <span class="number">20</span><span class="string">:12:33</span></span><br><span class="line">  <span class="attr">age:</span> <span class="number">18</span></span><br><span class="line">  <span class="attr">pet:</span> </span><br><span class="line">    <span class="attr">name:</span> <span class="string">tomcat</span></span><br><span class="line">    <span class="attr">weight:</span> <span class="number">23.4</span></span><br><span class="line">  <span class="attr">interests:</span> [<span class="string">篮球</span>,<span class="string">游泳</span>]</span><br><span class="line">  <span class="attr">animal:</span> </span><br><span class="line">    <span class="bullet">-</span> <span class="string">jerry</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">mario</span></span><br><span class="line">  <span class="attr">score:</span></span><br><span class="line">    <span class="attr">english:</span> </span><br><span class="line">      <span class="attr">first:</span> <span class="number">30</span></span><br><span class="line">      <span class="attr">second:</span> <span class="number">40</span></span><br><span class="line">      <span class="attr">third:</span> <span class="number">50</span></span><br><span class="line">    <span class="attr">math:</span> [<span class="number">131</span>,<span class="number">140</span>,<span class="number">148</span>]</span><br><span class="line">    <span class="attr">chinese:</span> &#123;<span class="attr">first:</span> <span class="number">128</span>,<span class="attr">second:</span> <span class="number">136</span>&#125;</span><br><span class="line">  <span class="attr">salarys:</span> [<span class="number">3999</span>,<span class="number">4999.98</span>,<span class="number">5999.99</span>]</span><br><span class="line">  <span class="attr">allPets:</span></span><br><span class="line">    <span class="attr">sick:</span></span><br><span class="line">      <span class="bullet">-</span> &#123;<span class="attr">name:</span> <span class="string">tom</span>&#125;</span><br><span class="line">      <span class="bullet">-</span> &#123;<span class="attr">name:</span> <span class="string">jerry</span>,<span class="attr">weight:</span> <span class="number">47</span>&#125;</span><br><span class="line">    <span class="attr">health:</span> [&#123;<span class="attr">name:</span> <span class="string">mario</span>,<span class="attr">weight:</span> <span class="number">47</span>&#125;]</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="配置提示"><a href="#配置提示" class="headerlink" title="配置提示"></a>配置提示</h3><ul>
<li>开启注释处理器</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 打包时去除该插件</span><br><span class="line"> <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">excludes</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">exclude</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">excludes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="Web开发"><a href="#Web开发" class="headerlink" title="Web开发"></a>Web开发</h2><h3 id="静态资源"><a href="#静态资源" class="headerlink" title="静态资源"></a>静态资源</h3><h4 id="静态资源访问"><a href="#静态资源访问" class="headerlink" title="静态资源访问"></a>静态资源访问</h4><ul>
<li><p>静态资源目录：只要静态资源放在类路径下：  <code>/static</code> (or <code>/public</code> or <code>/resources</code> or <code>/META-INF/resources</code>，都可以通过  <code>当前项目根路径/ + 静态资源名 </code>访问</p>
<ul>
<li><p>原理：静态资源，映射/**。请求进来，先去找Controller看能不能处理。不能处理的所有请求又都交给静态资源处理器。静态资源也找不到则响应404页面</p>
</li>
<li><p>改变默认静态资源和静态资源路径：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">mvc:</span></span><br><span class="line">    <span class="attr">static-path-pattern:</span> <span class="string">/res/**</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">resources:</span></span><br><span class="line">    <span class="attr">static-locations:</span> [<span class="string">classpath:/haha/</span>]</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h4 id="欢迎页支持"><a href="#欢迎页支持" class="headerlink" title="欢迎页支持"></a>欢迎页支持</h4><ul>
<li>静态资源路径下index.html<ul>
<li>可以配置静态资源路径</li>
<li>不可以配置静态资源访问前缀，否则无法访问index.html</li>
</ul>
</li>
<li>controller处理/index</li>
</ul>
<h4 id="自定义Favicon"><a href="#自定义Favicon" class="headerlink" title="自定义Favicon"></a>自定义Favicon</h4><ul>
<li>将favicon.ico放在静态资源目录下</li>
</ul>
<h4 id="静态资源配置原理"><a href="#静态资源配置原理" class="headerlink" title="静态资源配置原理"></a>静态资源配置原理</h4><ul>
<li><p>SpringMVC功能的自动配置类 WebMvcAutoConfiguration，生效</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="meta">@ConditionalOnWebApplication(type = Type.SERVLET)</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(&#123; Servlet.class, DispatcherServlet.class, WebMvcConfigurer.class &#125;)</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean(WebMvcConfigurationSupport.class)</span></span><br><span class="line"><span class="meta">@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE + 10)</span></span><br><span class="line"><span class="meta">@AutoConfigureAfter(&#123; DispatcherServletAutoConfiguration.class, TaskExecutionAutoConfiguration.class,</span></span><br><span class="line"><span class="meta">		ValidationAutoConfiguration.class &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebMvcAutoConfiguration</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>该配置类给容器中配置了很多，重要的是WebMvcAutoConfigurationAdapter</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line">	<span class="meta">@Import(EnableWebMvcConfiguration.class)</span></span><br><span class="line">	<span class="meta">@EnableConfigurationProperties(&#123; WebMvcProperties.class, ResourceProperties.class &#125;)</span></span><br><span class="line">	<span class="meta">@Order(0)</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">WebMvcAutoConfigurationAdapter</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>配置文件的相关属性和xxx进行了绑定。WebMvcProperties ==<strong>spring.mvc</strong>、ResourceProperties==<strong>spring.resources</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">	//有参构造器所有参数的值都会从容器中确定</span><br><span class="line">//ResourceProperties resourceProperties；获取和spring.resources绑定的所有的值的对象</span><br><span class="line">//WebMvcProperties mvcProperties 获取和spring.mvc绑定的所有的值的对象</span><br><span class="line">//ListableBeanFactory beanFactory Spring的beanFactory</span><br><span class="line">//HttpMessageConverters 找到所有的HttpMessageConverters</span><br><span class="line">//ResourceHandlerRegistrationCustomizer 找到 资源处理器的自定义器。=========</span><br><span class="line">//DispatcherServletPath  </span><br><span class="line">//ServletRegistrationBean   给应用注册Servlet、Filter....</span><br><span class="line">	public WebMvcAutoConfigurationAdapter(ResourceProperties resourceProperties, WebMvcProperties mvcProperties,</span><br><span class="line">				ListableBeanFactory beanFactory, ObjectProvider&lt;HttpMessageConverters&gt; messageConvertersProvider,</span><br><span class="line">				ObjectProvider&lt;ResourceHandlerRegistrationCustomizer&gt; resourceHandlerRegistrationCustomizerProvider,</span><br><span class="line">				ObjectProvider&lt;DispatcherServletPath&gt; dispatcherServletPath,</span><br><span class="line">				ObjectProvider&lt;ServletRegistrationBean&lt;?&gt;&gt; servletRegistrations) &#123;</span><br><span class="line">			this.resourceProperties = resourceProperties;</span><br><span class="line">			this.mvcProperties = mvcProperties;</span><br><span class="line">			this.beanFactory = beanFactory;</span><br><span class="line">			this.messageConvertersProvider = messageConvertersProvider;</span><br><span class="line">			this.resourceHandlerRegistrationCustomizer = resourceHandlerRegistrationCustomizerProvider.getIfAvailable();</span><br><span class="line">			this.dispatcherServletPath = dispatcherServletPath;</span><br><span class="line">			this.servletRegistrations = servletRegistrations;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>资源处理的默认规则</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="comment">#  mvc:</span></span><br><span class="line"><span class="comment">#    static-path-pattern: /res/**</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">resources:</span></span><br><span class="line">    <span class="attr">add-mappings:</span> <span class="literal">false</span>   <span class="string">禁用所有静态资源规则</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addResourceHandlers</span><span class="params">(ResourceHandlerRegistry registry)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">if</span> (!<span class="keyword">this</span>.resourceProperties.isAddMappings()) &#123;</span><br><span class="line">				logger.debug(<span class="string">&quot;Default resource handling disabled&quot;</span>);</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">            <span class="comment">//配置缓存</span></span><br><span class="line">			Duration cachePeriod = <span class="keyword">this</span>.resourceProperties.getCache().getPeriod();</span><br><span class="line">			CacheControl cacheControl = <span class="keyword">this</span>.resourceProperties.getCache().getCachecontrol().toHttpCacheControl();</span><br><span class="line">			<span class="comment">//webjars的规则</span></span><br><span class="line">            <span class="keyword">if</span> (!registry.hasMappingForPattern(<span class="string">&quot;/webjars/**&quot;</span>)) &#123;</span><br><span class="line">				customizeResourceHandlerRegistration(registry.addResourceHandler(<span class="string">&quot;/webjars/**&quot;</span>)</span><br><span class="line">						.addResourceLocations(<span class="string">&quot;classpath:/META-INF/resources/webjars/&quot;</span>)</span><br><span class="line">						.setCachePeriod(getSeconds(cachePeriod)).setCacheControl(cacheControl));</span><br><span class="line">			&#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//配置静态资源路径</span></span><br><span class="line">			String staticPathPattern = <span class="keyword">this</span>.mvcProperties.getStaticPathPattern();</span><br><span class="line">			<span class="keyword">if</span> (!registry.hasMappingForPattern(staticPathPattern)) &#123;</span><br><span class="line">				customizeResourceHandlerRegistration(registry.addResourceHandler(staticPathPattern)</span><br><span class="line">						.addResourceLocations(getResourceLocations(<span class="keyword">this</span>.resourceProperties.getStaticLocations()))</span><br><span class="line">						.setCachePeriod(getSeconds(cachePeriod)).setCacheControl(cacheControl));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;spring.resources&quot;, ignoreUnknownFields = false)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResourceProperties</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] CLASSPATH_RESOURCE_LOCATIONS = &#123; <span class="string">&quot;classpath:/META-INF/resources/&quot;</span>,</span><br><span class="line">			<span class="string">&quot;classpath:/resources/&quot;</span>, <span class="string">&quot;classpath:/static/&quot;</span>, <span class="string">&quot;classpath:/public/&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Locations of static resources. Defaults to classpath:[/META-INF/resources/,</span></span><br><span class="line"><span class="comment">	 * /resources/, /static/, /public/].</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">private</span> String[] staticLocations = CLASSPATH_RESOURCE_LOCATIONS;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="请求参数处理"><a href="#请求参数处理" class="headerlink" title="请求参数处理"></a>请求参数处理</h3><ul>
<li>REST风格，使用Filter，HiddenHttpMethodFilter，springBoot需要手动开启</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">	<span class="attr">mvc:</span></span><br><span class="line">		<span class="attr">hiddenmethod:</span></span><br><span class="line">			<span class="attr">filter:</span></span><br><span class="line">				<span class="attr">enabled:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>



<h4 id="普通参数和基本注解"><a href="#普通参数和基本注解" class="headerlink" title="普通参数和基本注解"></a>普通参数和基本注解</h4><ul>
<li><p>注解：</p>
<ul>
<li><p>@PathVariable：路径变量</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;car/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getCar</span><span class="params">(<span class="meta">@PathVarible(&quot;id&quot;)</span> Integer id)</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>@RequestHeader：获取请求头</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;car/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getCar</span><span class="params">(<span class="meta">@PathVarible(&quot;id&quot;)</span> Integer id,</span></span></span><br><span class="line"><span class="params"><span class="function">                   <span class="meta">@RequestHeader</span> Map&lt;String,String&gt; head)</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>@RequestParam：获得请求参数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;car/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getCar</span><span class="params">(<span class="meta">@RequestParam</span> Map&lt;String,String&gt; params)</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>@MatrixVariable：矩阵变量,springBoot默认未开启</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1、语法： 请求路径：/cars/sell;low=34;brand=byd,audi,yd</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/cars/&#123;path&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map <span class="title">carsSell</span><span class="params">(<span class="meta">@MatrixVariable(&quot;low&quot;)</span> Integer low,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="meta">@MatrixVariable(&quot;brand&quot;)</span> List&lt;String&gt; brand)</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>@CookieValue：获取cookie的值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;car/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getCar</span><span class="params">(<span class="meta">@CookieValue(&quot;cookie&quot;)</span> Cookie cookie)</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>@RequestBody：获取请求体</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;car/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateCar</span><span class="params">(<span class="meta">@PostMapping</span> String content)</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>@RequestAttribute：获得request域数据</p>
</li>
</ul>
</li>
</ul>
<h2 id="视图解析Thymeleaf"><a href="#视图解析Thymeleaf" class="headerlink" title="视图解析Thymeleaf"></a>视图解析Thymeleaf</h2><ul>
<li><p>页面开发</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span> <span class="attr">xmlns:th</span>=<span class="string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;msg&#125;&quot;</span>&gt;</span>哈哈<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;www.atguigu.com&quot;</span> <span class="attr">th:href</span>=<span class="string">&quot;$&#123;link&#125;&quot;</span>&gt;</span>去百度<span class="tag">&lt;/<span class="name">a</span>&gt;</span>  <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;www.atguigu.com&quot;</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;link&#125;&quot;</span>&gt;</span>去百度2<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h2><ul>
<li><p>可以用作登录检查</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 登录检查</span></span><br><span class="line"><span class="comment"> * 1、配置好拦截器要拦截哪些请求</span></span><br><span class="line"><span class="comment"> * 2、把这些配置放在容器中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginInterceptor</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 目标方法执行之前</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> response</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> handler</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        String requestURI = request.getRequestURI();</span><br><span class="line">        log.info(<span class="string">&quot;preHandle拦截的请求路径是&#123;&#125;&quot;</span>,requestURI);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//登录检查逻辑</span></span><br><span class="line">        HttpSession session = request.getSession();</span><br><span class="line"></span><br><span class="line">        Object loginUser = session.getAttribute(<span class="string">&quot;loginUser&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(loginUser != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//放行</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//拦截住。未登录。跳转到登录页</span></span><br><span class="line">        request.setAttribute(<span class="string">&quot;msg&quot;</span>,<span class="string">&quot;请先登录&quot;</span>);</span><br><span class="line"><span class="comment">//        re.sendRedirect(&quot;/&quot;);</span></span><br><span class="line">        request.getRequestDispatcher(<span class="string">&quot;/&quot;</span>).forward(request,response);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 目标方法执行完成以后</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> response</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> handler</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> modelAndView</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;postHandle执行&#123;&#125;&quot;</span>,modelAndView);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 页面渲染以后</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> response</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> handler</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ex</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;afterCompletion执行异常&#123;&#125;&quot;</span>,ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1、编写一个拦截器实现HandlerInterceptor接口</span></span><br><span class="line"><span class="comment"> * 2、拦截器注册到容器中（实现WebMvcConfigurer的addInterceptors）</span></span><br><span class="line"><span class="comment"> * 3、指定拦截规则【如果是拦截所有，静态资源也会被拦截】</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AdminWebConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> LoginInterceptor())</span><br><span class="line">                .addPathPatterns(<span class="string">&quot;/**&quot;</span>)  <span class="comment">//所有请求都被拦截包括静态资源</span></span><br><span class="line">                .excludePathPatterns(<span class="string">&quot;/&quot;</span>,<span class="string">&quot;/login&quot;</span>,<span class="string">&quot;/css/**&quot;</span>,<span class="string">&quot;/fonts/**&quot;</span>,<span class="string">&quot;/images/**&quot;</span>,<span class="string">&quot;/js/**&quot;</span>); <span class="comment">//放行的请求</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>拦截器原理</p>
<p>1、根据当前请求，找到<strong>HandlerExecutionChain【</strong>可以处理请求的handler以及handler的所有 拦截器】</p>
<p>2、先来<strong>顺序执行</strong> 所有拦截器的 preHandle方法</p>
<ul>
<li>1、如果当前拦截器prehandler返回为true。则执行下一个拦截器的preHandle</li>
<li>2、如果当前拦截器返回为false。直接    倒序执行所有已经执行了的拦截器的  afterCompletion；</li>
</ul>
<p><strong>3、如果任何一个拦截器返回false。直接跳出不执行目标方法</strong></p>
<p><strong>4、所有拦截器都返回True。执行目标方法</strong></p>
<p><strong>5、倒序执行所有拦截器的postHandle方法。</strong></p>
<p><strong>6、前面的步骤有任何异常都会直接倒序触发</strong> afterCompletion</p>
<p>7、页面成功渲染完成以后，也会倒序触发 afterCompletion</p>
</li>
</ul>
<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><ul>
<li><p>默认规则</p>
<ul>
<li><p>默认情况下，Spring Boot提供<code>/error</code>处理所有错误的映射</p>
</li>
<li><p>对于机器客户端，它将生成JSON响应，其中包含错误，HTTP状态和异常消息的详细信息。对于浏览器客户端，响应一个whitelabel错误视图，以HTML格式呈现相同的数据</p>
<p><img src="/2022/01/09/30/day30_1.png" alt="Json"></p>
</li>
<li><p>自定义错误页面：error/下的4xx，5xx页面会被自动解析</p>
</li>
</ul>
</li>
<li><p>异常处理流程：</p>
<ul>
<li><p>执行目标方法，目标方法运行期间有任何异常都会被catch、而且标志当前请求结束；并且用 <strong>dispatchException</strong>保存异常</p>
</li>
<li><p>进入视图解析流程</p>
</li>
<li><p><strong>mv</strong> = <strong>processHandlerException</strong>；处理handler发生的异常，处理完成返回ModelAndView</p>
<ul>
<li><p>遍历所有的 <code>handlerExceptionResolvers</code>，看谁能处理当前异常</p>
<ul>
<li><code>DefaultErrorAttributes</code>先来处理异常。把异常信息保存到rrequest域，并且返回null</li>
<li>默认没有任何人能处理异常，所以异常会被抛出<ul>
<li>如果没有任何人能处理最终底层就会发送 /error 请求。会被底层的<code>BasicErrorController</code>处理</li>
<li>解析错误视图;遍历所有的  <code>ErrorViewResolver</code>  看谁能解析<ul>
<li>默认的DefaultErrorViewResolver ,作用是把响应状态码作为错误页的地址，<strong>error/500.html</strong></li>
<li>模板引擎最终响应这个页面<strong>error/500.html</strong> </li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="数据访问"><a href="#数据访问" class="headerlink" title="数据访问"></a>数据访问</h1><h2 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h2><ul>
<li><p>导入JDBC场景</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>数据库版本和驱动版本对应：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">默认版本：<span class="tag">&lt;<span class="name">mysql.version</span>&gt;</span>8.0.22<span class="tag">&lt;/<span class="name">mysql.version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--            &lt;version&gt;5.1.49&lt;/version&gt;--&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">想要修改版本</span><br><span class="line">1、直接依赖引入具体版本（maven的就近依赖原则）</span><br><span class="line">2、重新声明版本（maven的属性的就近优先原则）</span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mysql.version</span>&gt;</span>5.1.49<span class="tag">&lt;/<span class="name">mysql.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>修改配置项</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/db_account</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.jdbc.Driver</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="整合Mybatis"><a href="#整合Mybatis" class="headerlink" title="整合Mybatis"></a>整合Mybatis</h3><ul>
<li><p>导入mybatis官方starter</p>
</li>
<li><p>编写mapper接口。标准@Mapper注解</p>
</li>
<li><p>编写sql映射文件并绑定mapper接口</p>
</li>
<li><p>在application.yaml中指定Mapper配置文件的位置，以及指定全局配置文件的信息 （建议；<strong>配置在mybatis.configuration</strong>）</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 配置mybatis规则</span></span><br><span class="line"><span class="attr">mybatis:</span></span><br><span class="line">  <span class="comment">#config-location: classpath:mybatis/mybatis-config.xml  #全局配置文件位置</span></span><br><span class="line">  <span class="attr">mapper-locations:</span> <span class="string">classpath:mybatis/mapper/*.xml</span>  <span class="comment">#sql映射文件位置</span></span><br><span class="line">  <span class="attr">configuration:</span></span><br><span class="line">    <span class="attr">map-underscore-to-camel-case:</span> <span class="literal">true</span> <span class="comment">#开启驼峰命名</span></span><br><span class="line">    </span><br><span class="line">    <span class="string">可以不写全局；配置文件，所有全局配置文件的配置都放在configuration配置项中即可</span></span><br><span class="line">  </span><br><span class="line"><span class="string">Mapper接口---&gt;绑定Xml</span></span><br><span class="line"><span class="string">&lt;?xml</span> <span class="string">version=&quot;1.0&quot;</span> <span class="string">encoding=&quot;UTF-8&quot;</span> <span class="string">?&gt;</span></span><br><span class="line"><span class="string">&lt;!DOCTYPE</span> <span class="string">mapper</span></span><br><span class="line">        <span class="string">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span><br><span class="line">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span><span class="string">&gt;</span></span><br><span class="line"><span class="string">&lt;mapper</span> <span class="string">namespace=&quot;com.atguigu.admin.mapper.AccountMapper&quot;&gt;</span></span><br><span class="line"><span class="string">&lt;!--</span>    <span class="string">public</span> <span class="string">Account</span> <span class="string">getAcct(Long</span> <span class="string">id);</span> <span class="string">--&gt;</span></span><br><span class="line">    <span class="string">&lt;select</span> <span class="string">id=&quot;getAcct&quot;</span> <span class="string">resultType=&quot;com.atguigu.admin.bean.Account&quot;&gt;</span></span><br><span class="line">        <span class="string">select</span> <span class="string">*</span> <span class="string">from</span>  <span class="string">account_tbl</span> <span class="string">where</span>  <span class="string">id=#&#123;id&#125;</span></span><br><span class="line">    <span class="string">&lt;/select&gt;</span></span><br><span class="line"><span class="string">&lt;/mapper&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>纯注解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CityMapper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Select(&quot;select * from city where id=#&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> City <span class="title">getById</span><span class="params">(Long id)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(City city)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p>最佳使用方法：</p>
<ul>
<li>引入mybatis-starter</li>
<li><strong>配置application.yaml中，指定mapper-location位置即可</strong></li>
<li>编写Mapper接口并标注@Mapper注解</li>
<li>简单方法直接注解方式</li>
<li>复杂方法编写mapper.xml进行绑定映射</li>
<li><em>@MapperScan(“com.atguigu.admin.mapper”) 简化</em>，其他的接口就可以不用标注@Mapper注解</li>
</ul>
</blockquote>
<h2 id="NoSQL"><a href="#NoSQL" class="headerlink" title="NoSQL"></a>NoSQL</h2><ul>
<li><p>redis自动配置：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>RedisTemplate与Lettuce</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testRedis</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ValueOperations&lt;String, String&gt; operations = redisTemplate.opsForValue();</span><br><span class="line">  </span><br><span class="line">    operations.set(<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;world&quot;</span>);</span><br><span class="line">  </span><br><span class="line">    String hello = operations.get(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    System.out.println(hello);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>切换至jedis</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--        导入jedis--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/01/03/day29/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Kaixuan Wang">
      <meta itemprop="description" content="只争朝夕">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Magic">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/03/day29/" class="post-title-link" itemprop="url">八股</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-01-03 20:08:04" itemprop="dateCreated datePublished" datetime="2022-01-03T20:08:04+08:00">2022-01-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-10-08 15:19:29" itemprop="dateModified" datetime="2022-10-08T15:19:29+08:00">2022-10-08</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="JAVA基础"><a href="#JAVA基础" class="headerlink" title="JAVA基础"></a>JAVA基础</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="Java-泛型了解么？什么是类型擦除？介绍一下常用的通配符？"><a href="#Java-泛型了解么？什么是类型擦除？介绍一下常用的通配符？" class="headerlink" title="Java 泛型了解么？什么是类型擦除？介绍一下常用的通配符？"></a><strong>Java 泛型了解么？什么是类型擦除？介绍一下常用的通配符？</strong></h3><ul>
<li>Java 泛型（generics）是 JDK 5 中引入的一个新特性, 泛型提供了编译时类型安全检测机制，该机制允许程序员在编译时检测到非法的类型。泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。</li>
<li>Java 的泛型是伪泛型，这是因为 Java 在编译期间，所有的泛型信息都会被擦掉，也就是编译生成的字节码中不包含泛型信息，但泛型信息还是会保存下来</li>
</ul>
<h3 id="为什么重写-equals-时必须重写-hashCode-方法？"><a href="#为什么重写-equals-时必须重写-hashCode-方法？" class="headerlink" title="为什么重写 equals 时必须重写 hashCode 方法？"></a><strong>为什么重写 equals 时必须重写 hashCode 方法？</strong></h3><ul>
<li>例如HashSet存放元素，会先调用hashCode()方法判断，如果存在hashCode()，才调用equals()方法判断是否相等。</li>
<li>如果两个对象相等，则 hashcode 一定也是相同的。两个对象相等,对两个对象分别调用 equals 方法都返回 true。但是，两个对象有相同的 hashcode 值，它们也不一定是相等的 。因此，equals 方法被覆盖过，则 hashCode 方法也必须被覆盖。</li>
</ul>
<h3 id="8-种基本类型的包装类和常量池"><a href="#8-种基本类型的包装类和常量池" class="headerlink" title="8 种基本类型的包装类和常量池"></a><strong>8 种基本类型的包装类和常量池</strong></h3><ul>
<li>Java 基本类型的包装类的大部分都实现了常量池技术。Byte,Short,Integer,Long 这 4 种包装类默认创建了数值 [-128，127] 的相应类型的缓存数据，Character 创建了数值在[0,127]范围的缓存数据，Boolean 直接返回 True Or False</li>
<li><strong>为什么缓存设置在[-128, 127]？</strong>性能和资源的平衡，太大的话占用资源太多，太小的话性能不会有很大提升，可以进行调整</li>
<li>valueOf方法会直接从缓存池中获得对象</li>
</ul>
<h3 id="成员变量与局部变量的区别有哪些？"><a href="#成员变量与局部变量的区别有哪些？" class="headerlink" title="成员变量与局部变量的区别有哪些？"></a><strong>成员变量与局部变量的区别有哪些？</strong></h3><ul>
<li>从语法形式上看，成员变量是属于类的，而局部变量是在代码块或方法中定义的变量或是方法的参数；成员变量可以被 public,private,static 等修饰符所修饰，而局部变量不能被访问控制修饰符及 static 所修饰；但是，成员变量和局部变量都能被 final 所修饰。</li>
<li>从变量在内存中的存储方式来看,如果成员变量是使用 static 修饰的，那么这个成员变量是属于类的，如果没有使用 static 修饰，这个成员变量是属于实例的。而对象存在于堆内存，局部变量则存在于栈内存。</li>
<li>从变量在内存中的生存时间上看，成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动消失。</li>
<li>从变量是否有默认值来看，成员变量如果没有被赋初，则会自动以类型的默认值而赋值（一种情况例外:被 final 修饰的成员变量也必须显式地赋值），而局部变量则不会自动赋值。</li>
</ul>
<h3 id="如何从子类调用父类的private属性和方法？"><a href="#如何从子类调用父类的private属性和方法？" class="headerlink" title="如何从子类调用父类的private属性和方法？"></a><strong>如何从子类调用父类的private属性和方法？</strong></h3><ul>
<li>可以通过反射获得。可以将子类和父类定义为同一个类的内部类。之后实例化的子类就可以访问父类的私有方法和私有属性，父类也可以直接调用私有方法和私有属性</li>
</ul>
<h3 id="String-StringBuffer-和-StringBuilder-的区别是什么-String-为什么是不可变的-不可变有什么好处"><a href="#String-StringBuffer-和-StringBuilder-的区别是什么-String-为什么是不可变的-不可变有什么好处" class="headerlink" title="**String StringBuffer 和 StringBuilder 的区别是什么? String 为什么是不可变的?**不可变有什么好处?"></a>**String StringBuffer 和 StringBuilder 的区别是什么? String 为什么是不可变的?**不可变有什么好处?</h3><ul>
<li>简单的来说：String类中使用 final 关键字修饰字符数组来保存字符串，private final char value[]，所以String 对象是不可变的。</li>
</ul>
<ul>
<li>String 真正不可变有下面几点原因：<ul>
<li><p>保存字符串的数组被 final 修饰且为私有的，并且String 类没有提供/暴露修改这个字符串的方法。</p>
<p>String 类被 final 修饰导致其不能被继承，进而避免了子类破坏 String 不可变。</p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>补充：在 Java 9 之后，String 、StringBuilder 与 StringBuffer 的实现改用 byte 数组存储字符串 private final byte[] value</p>
</blockquote>
<ul>
<li>而 StringBuilder 与 StringBuffer 都继承自 AbstractStringBuilder 类，在 AbstractStringBuilder 中也是使用字符数组保存字符串char[]value 但是没有用 final 关键字修饰，所以这两种对象都是可变的。</li>
<li>StringBuffer 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder 并没有对方法进行加同步锁，所以是非线程安全的。</li>
<li>每次对 String 类型进行改变的时候，都会生成一个新的 String 对象，然后将指针指向新的 String 对象。StringBuffer 每次都会对 StringBuffer 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 StringBuilder 相比使用 StringBuffer 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。</li>
<li>StringBuilder扩容时，长度变为原来的两倍再加上2，加2主要是因为append()之后会在后面加上一个分隔符char，char占用两个字节，避免因为分隔符而再次扩容</li>
</ul>
<blockquote>
<p>不可变好处：</p>
<ol>
<li>可以缓存hash值</li>
<li>String Pool需要，如果String已经被创建过了，就会直接从常量池中获得，只有String不可变才可以使用String Pool</li>
<li>线程安全 new String(“abc”)会创建两个string 对象，分别在堆中和字符串常量池中</li>
</ol>
</blockquote>
<h3 id="浅拷贝和引用拷贝区别"><a href="#浅拷贝和引用拷贝区别" class="headerlink" title="浅拷贝和引用拷贝区别"></a><strong>浅拷贝和引用拷贝区别</strong></h3><ul>
<li>浅拷贝会在堆上创建一个新的对象，但是如果原对象内部属性为引用类型的话，新对象直接复制内部对象的引用地址</li>
<li>引用拷贝只是在栈上创建一个引用变量</li>
</ul>
<h3 id="反射机制优缺点"><a href="#反射机制优缺点" class="headerlink" title="反射机制优缺点"></a><strong>反射机制优缺点</strong></h3><p>优点 ： 可以让咱们的代码更加灵活、为各种框架提供开箱即用的功能提供了便利</p>
<p>缺点 ：让我们在运行时有了分析操作类的能力，这同样也增加了安全问题。比如可以无视泛型参数的安全检查（泛型参数的安全检查发生在编译时）。另外，反射的性能也要稍差点，不过，对于框架来说实际是影响不大的。</p>
<h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a><strong>异常</strong></h3><p>除了RuntimeException及其子类以外，其他的Exception类及其子类都属于受检查异常 。</p>
<p><img src="/2022/01/03/day29/day29_1.jpg" alt="异常分类"> </p>
<p><img src="/2022/01/03/day29/day29_2.jpg" alt="异常分类（2）"> </p>
<h3 id="Java-序列化中如果有些字段不想进行序列化，怎么办？"><a href="#Java-序列化中如果有些字段不想进行序列化，怎么办？" class="headerlink" title="Java 序列化中如果有些字段不想进行序列化，怎么办？"></a><strong>Java 序列化中如果有些字段不想进行序列化，怎么办？</strong></h3><p>对于不想进行序列化的变量，使用 transient 关键字修饰。  </p>
<p>transient 关键字的作用是：阻止实例中那些用此关键字修饰的的变量序列化；当对象被反序列化时，被 transient 修饰的变量值不会被持久化和恢复。</p>
<blockquote>
<p>关于 transient 还有几点注意：<br>transient 只能修饰变量，不能修饰类和方法。<br>transient 修饰的变量，在反序列化后变量值将会被置成类型的默认值。例如，如果是修饰 int 类型，那么反序列后结果就是 0。<br>static 变量因为不属于任何对象(Object)，所以无论有没有 transient 关键字修饰，均不会被序列化。</p>
</blockquote>
<h3 id="Java中只有值传递"><a href="#Java中只有值传递" class="headerlink" title="Java中只有值传递"></a><strong>Java中只有值传递</strong></h3><p>如果参数是基本类型的话，很简单，传递的就是基本类型的字面量值的拷贝，会创建副本。</p>
<p>如果参数是引用类型，传递的就是实参所引用的对象在堆中地址值的拷贝，同样也会创建副本。</p>
<h3 id="BIO-NIO-AIO"><a href="#BIO-NIO-AIO" class="headerlink" title="BIO NIO AIO"></a><strong>BIO NIO AIO</strong></h3><ul>
<li><p>BIO(Blocking IO)：同步阻塞型IO，一个客户端对应一个处理线程，同时处理多个客户端必须使用多线程。<strong>在没有读取到相应数据时，程序一直阻塞</strong></p>
</li>
<li><p>伪异步线程：对BIO的改进。在客户端发起请求后，维护一个消息队列，将请求放入消息队列中，再通过线程池进行线程管理，处理消息队列中的请求。这样可以满足客户端请求大于线程数</p>
</li>
<li><p>NIO(new IO):同步非阻塞型IO，使用缓冲区解决阻塞问题，读写数据都要通过缓存区实现。NIO中通过channel读写数据，是双向的通道，既可以读也可以写。NIO中有selector选择器，可以使用较少的线程处理多个通道，减少线程的切换，提高效率</p>
</li>
<li><p>IO 多路复用模型中，线程首先发起 select 调用，询问内核数据是否准备就绪，等内核把数据准备好了，用户线程再发起 read 调用，不需要一直发起read请求。read 调用的过程（数据从内核空间 -&gt; 用户空间）还是阻塞的。</p>
<blockquote>
<p>操作系统级别提供了一些接口来支持IO多路复用，最早的是select、poll，其后epoll是Linux下的IO多路复用的实现。</p>
<ul>
<li>select接口最早实现存在需要调用多次、线程不安全以及限制只能监视1024个链接的问题</li>
<li>poll接口修复了select函数的一些问题，但是依然不是线程安全的。</li>
<li>epoll接口修复了上述的问题，并且线程安全，会通知具体哪个连接有新数据。<ul>
<li>epoll通过epoll_ctl()来注册一个文件描述符,一旦基于某个文件描述符就绪时,内核会采用类似<strong>callback的回调机制</strong>,迅速激活这个文件描述符,当进程调用epoll_wait()时便得到通知(不再需要遍历文件描述符,通过监听回调的机制,也是epoll的魅力)</li>
<li>epoll除了性能优势，还有一个优点——同时支持水平触发(Level Trigger)和边沿触发(Edge Trigger)。<ul>
<li>水平触发只关心文件描述符中是否还有没完成处理的数据，如果有，不管怎样epoll_wait，总是会被返回。简单说——水平触发代表了一种“状态”</li>
<li>边沿触发只关心文件描述符是否有新的事件产生，如果有，则返回；如果返回过一次，不管程序是否处理了，只要没有新的事件产生，epoll_wait不会再认为这个fd被“触发”了。简单说——边沿触发代表了一个“事件”。</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
</li>
<li><p>AIO(Asynchronous I/O)：异步非阻塞型IO，相对于NIO而言，AIO是在数据完全处理完之后再通知cpu，而不需要cpu自己做同步的数据读写 </p>
</li>
</ul>
<h3 id="JDK动态代理和CGLIB动态代理对比"><a href="#JDK动态代理和CGLIB动态代理对比" class="headerlink" title="JDK动态代理和CGLIB动态代理对比"></a>JDK动态代理和CGLIB动态代理对比</h3><ul>
<li><strong>JDK 动态代理只能代理实现了接口的类或者直接代理接口，而 CGLIB 可以代理未实现任何接口的类。</strong> 另外， CGLIB 动态代理是通过生成一个被代理类的子类来拦截被代理类的方法调用，因此不能代理声明为 final 类型的类和方法</li>
<li>就二者的效率来说，大部分情况都是 JDK 动态代理更优秀，随着 JDK 版本的升级，这个优势更加明显</li>
</ul>
<h3 id="抽象类和接口"><a href="#抽象类和接口" class="headerlink" title="抽象类和接口"></a>抽象类和接口</h3><ul>
<li><strong>共同点</strong>：<ul>
<li>都不能被实例化</li>
<li>都可以包含抽象方法</li>
<li>都可以有默认的实现方法</li>
</ul>
</li>
<li><strong>区别</strong>：<ul>
<li>接口只要是对类的行为进行约束，实现了接口就有了具体的对应功能；抽象类主要用于代码复用，强调所属关系</li>
<li>一个类只能继承一个类，实现多个接口</li>
<li>接口中的成员变量只能是 <code>public static final</code> 类型的，不能被修改且必须有初始值，而抽象类的成员变量默认 default，可在子类中被重新定义，也可被重新赋值。</li>
</ul>
</li>
</ul>
<h3 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h3><ul>
<li>枚举类比较可以使用==或equals方法，是等价的</li>
<li>枚举类在jvm编译之后，实际变成final修饰的class，意味着实例化之后无法改变，并且只存在一个对象</li>
</ul>
<h3 id="IO类"><a href="#IO类" class="headerlink" title="IO类"></a>IO类</h3><ul>
<li>字节流：<ul>
<li>InputStream：所有字节输入流父类<ul>
<li>FileInputStream:一般与bufferedInputStream一起使用</li>
<li>DataInputStream：读取指定类型数据，与FileInputStream一起使用</li>
<li>ObjectInputStream：从输入流中读取Java对象</li>
</ul>
</li>
<li>OutputStream：所有字节输出流父类<ul>
<li>FileInputStream：一般与bufferedOutputStream一起使用</li>
<li>DataOutputStream：写入指定类型数据，与FileInputStream一起使用</li>
<li>ObjectOutputStream ：将对象写入到输出流</li>
</ul>
</li>
</ul>
</li>
<li>字符流：为了防止不知道编码出现乱码问题<ul>
<li>Reader：所有字符输入流父类，读取文本，抽象类<ul>
<li>InputStreamReader：字节流转换为字符流桥梁</li>
<li>FileReader</li>
</ul>
</li>
<li>Writer：所有字符输出流父类，抽象类<ul>
<li>OutputStreamWriter：字节流转换为字符流桥梁</li>
<li>FileWriter</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="设计模式总结"><a href="#设计模式总结" class="headerlink" title="设计模式总结"></a>设计模式总结</h3><ul>
<li>观察者模式：对象之间一对多的依赖。一个对象状态改变，所有的依赖者都会收到相应的通知。（如气象站和布告板，气象站温度变化，所有布告板都需要更新）</li>
<li>装饰者模式：将责任附加到对象上，例如IO类中，FileInputStream就是一个装饰者，增强了InputStream的功能</li>
<li>单例模式：只存在一个实例</li>
<li>工厂模式：由子类自己决定要实例化的类是哪一个，将类的实例化推迟到子类</li>
<li>适配器模式：将一个类的接口，转化成另一个客户期待的接口</li>
</ul>
<h3 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h3><ul>
<li><p>交换</p>
<ul>
<li><p>冒泡排序：每一轮将最大的元素放在结尾</p>
</li>
<li><p>快速排序：优化：随机选择基准、设定一个阈值，低于阈值使用插入排序</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &gt;= right) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> l = left;</span><br><span class="line">    <span class="keyword">int</span> r = right;</span><br><span class="line">    <span class="keyword">int</span> temp = nums[l];</span><br><span class="line">    <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r &amp;&amp; nums[r]&gt;=temp) r--;</span><br><span class="line">       	nums[l] = nums[r];</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r &amp;&amp; nums[l]&lt;=temp) l++;</span><br><span class="line">        nums[r] = nums[l];</span><br><span class="line">    &#125;</span><br><span class="line">    nums[l] = temp;</span><br><span class="line">    quickSort(nums,left,l-<span class="number">1</span>);</span><br><span class="line">    quickSort(nums,l+<span class="number">1</span>,right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>插入</p>
<ul>
<li>插入排序：每次将新元素插入到队列中</li>
<li>希尔排序：每次设定一个增量，初始为length/2，增量每轮减半，直到减为1，完成排序</li>
</ul>
</li>
<li><p>选择</p>
<ul>
<li>选择排序：选择最小的元素交换至第一位</li>
<li>堆排序：建立大根堆</li>
</ul>
</li>
<li><p>归并排序：将数组长度逐渐分割很小，再进行有序数组合并</p>
</li>
<li><p>桶</p>
<ul>
<li>桶排序：每个桶对应不同的数据范围，将所有数据分成几个小的数组，分别排序。时间复杂度可以接近O（n）</li>
<li>计数排序：根据数据范围创建max-min+1辅助空间，记录每个元素出现个数</li>
<li>基数排序：逐次比较数据每一位的大小，创建0-9的桶。</li>
</ul>
</li>
</ul>
<blockquote>
<p>对于小的数据排序使用插入排序、中等数据使用快排、对于结构化的数组使用归并排序</p>
<ol>
<li><p>如果待排序列中数据含有大量重复值——优先使用计数排序；</p>
</li>
<li><p>如果待排序列中数据近乎有序——优先使用插入排序；</p>
</li>
<li><p>如果待排序列中数据取值范围有限——优先使用计数排序；</p>
</li>
<li><p>如果待排序列中数据要求稳定——优先使用归并排序；</p>
</li>
<li><p>如果待排序列需要使用链表——优先链表归并、链表快排；</p>
</li>
<li><p>如果待排序列中数据无法全部装到内存——优先使用外部排序（归并排序，基数排序，计数排序，桶排序）</p>
</li>
</ol>
</blockquote>
<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><h3 id="ArrayList扩容"><a href="#ArrayList扩容" class="headerlink" title="ArrayList扩容"></a>ArrayList扩容</h3><ul>
<li><p>默认初始容量为10。但如果使用默认容量，在没有添加元素之前，容量为0。</p>
</li>
<li><p>在进行添加元素时，如果需要的空间大于目前的容量，需要进行扩容：</p>
<ul>
<li>正常情况下，容量会增大到原来容量的1.5倍，<strong>newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1)</strong></li>
<li>如果增加1.5倍后的容量大于定义的最大容量<strong>Integer.MAX_VALUE-8</strong>，此时需要比较所需的最小容量和最大容量<ul>
<li>若所需最小容量小于最大容量，扩容到最大容量</li>
<li>若所需最小容量大于最大容量，扩容到<strong>Integer.MAX_VALUE</strong></li>
</ul>
</li>
</ul>
<blockquote>
<p>扩容因子为什么是1.5？</p>
<p>因为一般在内存中，扩容时首先需要开辟扩容后的空间，再将原来的数据复制进去。如果扩容因子&gt;=2，每次扩容的容量都会大于之前所有扩容的容量之和，就没办法使用前面释放的空间，扩容因子设为1.5的话也比较容易计算，也可以复用之前的空间</p>
</blockquote>
</li>
<li><p>Arrays.asList()方法返回的是Arrays内部的ArrayList，因为没有重写抽象父类的方法，不支持元素的新增和删除</p>
</li>
</ul>
<h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><h4 id="无序性和不可重复性的含义是什么"><a href="#无序性和不可重复性的含义是什么" class="headerlink" title="无序性和不可重复性的含义是什么?"></a>无序性和不可重复性的含义是什么?</h4><ul>
<li><p>无序性不等于随机性 ，无序性是指存储的数据在底层数组中并非按照数组索引的顺序添加 ，而是根据数据的哈希值决定的。</p>
</li>
<li><p>不可重复性是指添加的元素按照 equals()判断时 ，返回 false，需要同时重写 equals()方法和 HashCode()方法。</p>
</li>
</ul>
<h4 id="比较-HashSet、LinkedHashSet-和-TreeSet-三者的异同"><a href="#比较-HashSet、LinkedHashSet-和-TreeSet-三者的异同" class="headerlink" title="比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同"></a>比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同</h4><ul>
<li>都是 <code>Set</code> 接口的实现类，都能保证元素唯一，并且都不是线程安全的。</li>
<li><code>HashSet</code> 的底层数据结构是哈希表（基于 <code>HashMap</code> 实现）。<code>LinkedHashSet</code> 的底层数据结构是链表和哈希表，元素的插入和取出顺序满足 FIFO。<code>TreeSet</code> 底层数据结构是红黑树，元素是有序的，排序的方式有自然排序和定制排序。</li>
<li><code>HashSet</code> 用于不需要保证元素插入和取出顺序的场景，<code>LinkedHashSet</code> 用于保证元素的插入和取出顺序满足 FIFO 的场景，<code>TreeSet</code> 用于支持对元素自定义排序规则的场景</li>
</ul>
<h3 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h3><h4 id="ArrayDeque-与-LinkedList-的区别"><a href="#ArrayDeque-与-LinkedList-的区别" class="headerlink" title="ArrayDeque 与 LinkedList 的区别"></a>ArrayDeque 与 LinkedList 的区别</h4><ul>
<li><p><code>ArrayDeque</code> 是基于可变长的数组和双指针来实现，而 <code>LinkedList</code> 则通过链表来实现。</p>
</li>
<li><p><code>ArrayDeque</code> 不支持存储 <code>NULL</code> 数据，但 <code>LinkedList</code> 支持。</p>
</li>
<li><p><code>ArrayDeque</code> 是在 JDK1.6 才被引入的，而<code>LinkedList</code> 早在 JDK1.2 时就已经存在。</p>
</li>
<li><p><code>ArrayDeque</code> 插入时可能存在扩容过程, 不过均摊后的插入操作依然为 O(1)。虽然 <code>LinkedList</code> 不需要扩容，但是每次插入数据时均需要申请新的堆空间，均摊性能相比更慢。</p>
</li>
<li><p>从性能的角度上，选用 <code>ArrayDeque</code> 来实现队列要比 <code>LinkedList</code> 更好。</p>
</li>
</ul>
<h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><h4 id="HashMap和HashTable区别"><a href="#HashMap和HashTable区别" class="headerlink" title="HashMap和HashTable区别"></a>HashMap和HashTable区别</h4><ul>
<li><p><strong>线程是否安全：</strong> <code>HashMap</code> 是非线程安全的，<code>Hashtable</code> 是线程安全的,因为 <code>Hashtable</code> 内部的方法基本都经过<code>synchronized</code> 修饰。</p>
</li>
<li><p><strong>效率：</strong> 因为线程安全的问题，<code>HashMap</code> 要比 <code>Hashtable</code> 效率高一点。另外，<code>Hashtable</code> 基本被淘汰，不要在代码中使用它，保证线程安全的话就使用 <code>ConcurrentHashMap</code> </p>
</li>
<li><p><strong>对 Null key 和 Null value 的支持：</strong> <code>HashMap</code> 可以存储 null 的 key 和 value，但 null 作为键只能有一个，null 作为值可以有多个；<code>Hashtable</code> 不允许有 null 键和 null 值，否则会抛出 <code>NullPointerException</code>。</p>
</li>
<li><p><strong>初始容量大小和每次扩充容量大小的不同 ：</strong> </p>
<ul>
<li><p>创建时如果不指定容量初始值，<code>Hashtable</code> 默认的初始大小为 11，之后每次扩充，容量变为原来的 2n+1。<code>HashMap</code> 默认的初始化大小为 16。之后每次扩充，容量变为原来的 2 倍。</p>
</li>
<li><p> 创建时如果给定了容量初始值，那么 Hashtable 会直接使用你给定的大小，而 <code>HashMap</code> 会将其扩充为 2 的幂次方大小（<code>HashMap</code> 中的<code>tableSizeFor()</code>方法保证）。</p>
</li>
</ul>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns a power of two size for the given target capacity.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>底层数据结构：</strong> JDK1.8 以后的 <code>HashMap</code> 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，<strong>如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树</strong>）时，将链表转化为红黑树，以减少搜索时间。Hashtable 没有这样的机制。</p>
</li>
</ul>
<h4 id="HashMap-、TreeMap和LinkedHashMap区别"><a href="#HashMap-、TreeMap和LinkedHashMap区别" class="headerlink" title="HashMap 、TreeMap和LinkedHashMap区别"></a>HashMap 、TreeMap和LinkedHashMap区别</h4><ul>
<li><code>TreeMap</code> 和<code>HashMap</code> 都继承自<code>AbstractMap</code> ，但是需要注意的是<code>TreeMap</code>它还实现了<code>NavigableMap</code>接口和<code>SortedMap</code> 接口</li>
<li>实现 <code>NavigableMap</code> 接口让 <code>TreeMap</code> 有了对集合内元素的搜索的能力.实现<code>SortedMap</code>接口让 <code>TreeMap</code> 有了对集合中的元素根据键排序的能力，可以自定义比较器</li>
<li>相比于<code>HashMap</code>来说 <code>TreeMap</code> 主要多了对集合中的元素根据键排序的能力以及对集合内元素的搜索的能力</li>
<li><code>LinkedHashMap</code>在HashMap的基础上添加了双向链表，可以保证插入节点的顺序，在访问时可以进行顺序访问</li>
</ul>
<h4 id="HashSet检测重复"><a href="#HashSet检测重复" class="headerlink" title="HashSet检测重复"></a>HashSet检测重复</h4><ul>
<li>先判断<code>hashCode()</code>是否相同，如果相同，再判断<code>equals()</code></li>
<li>在jdk8中，<code>HashSet</code>的<code>add()</code>方法只是简单的调用了<code>HashMap</code>的<code>put()</code>方法，并且判断了一下返回值以确保是否有重复元素。<strong>也就是说，即使有重复元素，<code>HashSet</code>还是会将元素插入，只是通过返回值告诉我们存在重复元素</strong></li>
</ul>
<h4 id="HashMap底层实现"><a href="#HashMap底层实现" class="headerlink" title="HashMap底层实现"></a>HashMap底层实现</h4><ul>
<li><p>jdk8之前使用<code>数组+链表</code>实现。HashMap 通过 key 的 hashCode 经过扰动函数处理过后得到 hash 值，然后通过 (n - 1) &amp; hash 判断当前元素存放的位置（这里的 n 指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突</p>
</li>
<li><p>jdk8之后，使用<code>数组+链表+红黑树</code>实现。当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间</p>
<blockquote>
<p>链表长度大于8：链表长度太短没必要转化为红黑树，查找效率不会有很大提升，并且插入删除操作耗时</p>
<p>数组长度大于64：数组长度小于64发生hash冲突的几率比较高，转为红黑树可能会导致插入次数变多；数组长度比较小时，扩容的几率比较高，红黑树结构在rehash的过程中比较复杂</p>
</blockquote>
</li>
<li><p>默认加载因子为0.75，加载因子太大会导致冲突几率增大，太小空间利用率太低，0.75是一个折中的方案</p>
</li>
<li><p>最大容量：2^30；树的长度小于6时，重新转换为链表</p>
</li>
<li><p><code>put</code>操作，调用<code>putVal</code>方法</p>
<ul>
<li>如果是插入进链表，则插入到链表尾部。JDK7,插入到头部</li>
</ul>
<p><img src="/2022/01/03/day29/day29_3.png" alt="put方法大致流程"></p>
</li>
<li><p><code>resize</code>方法，一般伴随着<code>rehash</code>非常耗时，要尽量避免</p>
<ul>
<li>如果当前的数组大小超过了最大值就不再扩容，否则容量变为原来的两倍</li>
<li>rehash的过程中，需要将原数据复制到新数组中<ul>
<li>没有冲突的位置，直接<code>hashcoe &amp; (newCap-1)</code>计算位置</li>
<li>对于链表，要么位置不变，要么在原位置+oldCap位置</li>
<li>对于红黑树，算法较为复杂</li>
</ul>
</li>
</ul>
<blockquote>
<p>各种树：</p>
<ol>
<li><strong>红黑树和AVL树区别</strong></li>
</ol>
<ul>
<li>AVL树是<strong>严格的平衡二叉树</strong>，平衡条件必须满足（<strong>所有节点的左右子树高度差不超过1</strong>）。不管我们是执行插入还是删除操作，只要不满足上面的条件，就要通过旋转来保持平衡。它的高度会更低，所以<strong>AVL树适合用于插入与删除次数比较少，但查找多的情况。</strong></li>
<li>红黑树是<strong>弱平衡二叉树</strong>，它通过着色限制的关系，<strong>确保没有一条路径会比其它路径长出两倍，</strong>相对于AVL树来说，它的旋转次数少，所以<strong>对于搜索，插入，删除操作较多的情况下，我们就用红黑树</strong></li>
<li>红黑树插入操作的时间复杂度为O(logn)，AVL树插入操作的时间复杂度也为O(logn)</li>
</ul>
<ol start="2">
<li><strong>红黑树的性质</strong></li>
</ol>
<ul>
<li>红色结点不可能相连，黑色节点可以相连</li>
<li>根节点是黑色节点</li>
<li>每个红色节点的两个子节点都是黑色，叶子节点都是黑色(Null节点)</li>
<li>从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。</li>
<li>插入的点默认都是红色</li>
</ul>
<ol start="3">
<li><strong>红黑树插入规则</strong></li>
</ol>
<ul>
<li><p>变颜色</p>
<ul>
<li><p>当前结点的父亲是红色，且它的爷爷结点的另一个结点(叔叔)也是红色：</p>
<ul>
<li><p>把父结点设为黑色</p>
</li>
<li><p>把叔叔结点设为黑色</p>
</li>
<li><p>把爷爷结点设为红色</p>
</li>
<li><p>把指针定位到爷爷节点继续往上分析变换规则</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>左旋</p>
<ul>
<li>当前父节点是红色，叔叔是黑色的时候，且当前的结点是右子树，左旋以父结点左旋</li>
</ul>
</li>
<li><p>右旋</p>
<ul>
<li>当前父结点是红色，叔叔是黑色的时候，且当前节点是左子树：<ul>
<li>把父点变成黑色</li>
<li>把爷爷节点变成红色</li>
<li>以爷爷节点进行右旋</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
</li>
</ul>
<ul>
<li>hash方法：将hashcode()计算出来的值右移16位，再和原来的数进行异或<ul>
<li>为什么要这样做：混合后，低位掺杂了高位的特性，保留高位的特征，加大低位的随机性；hashcode()可能被重写，不一定可以保证随机性</li>
</ul>
</li>
</ul>
<h4 id="HashMap-的长度为什么是-2-的幂次方"><a href="#HashMap-的长度为什么是-2-的幂次方" class="headerlink" title="HashMap 的长度为什么是 2 的幂次方"></a>HashMap 的长度为什么是 2 的幂次方</h4><ul>
<li>由于hash值的范围很大，在使用之前需要对数组的长度取模，得到的余数才能用来要存放的位置也就是对应的数组下标。这个数组下标的计算方法是 <code>(n - 1) &amp; hash</code>。（n 代表数组长度）。这也就解释了 HashMap 的长度为什么是 2 的幂次方</li>
<li><strong>取余(%)操作中如果除数是 2 的幂次则等价于与其除数减一的与(&amp;)操作（也就是说 hash%length==hash&amp;(length-1)的前提是 length 是 2 的 n 次方）</strong>。采用二进制位操作 &amp;，相对于%能够提高运算效率，这就解释了 HashMap 的长度为什么是 2 的幂次方</li>
</ul>
<h4 id="HashMap多线程操作导致死循环"><a href="#HashMap多线程操作导致死循环" class="headerlink" title="HashMap多线程操作导致死循环"></a>HashMap多线程操作导致死循环</h4><ul>
<li><p>在并发编程下，HashMap线程不安全，在Rehash的时候可能会出现循环链表，jdk8已经解决</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://coolshell.cn/articles/9606.html">源码图文分析</a></p>
</blockquote>
</li>
</ul>
<h4 id="ConcurrentHashMap和HashTable区别"><a href="#ConcurrentHashMap和HashTable区别" class="headerlink" title="ConcurrentHashMap和HashTable区别"></a>ConcurrentHashMap和HashTable区别</h4><ul>
<li><strong>底层数据结构：</strong> <code>ConcurrentHashMap</code> JDK1.8 采用的数据结构跟 <code>HashMap1.8</code> 的结构一样，数组+链表/红黑二叉树。<code>Hashtable</code> 和 JDK1.8 之前的 <code>HashMap</code> 的底层数据结构类似都是采用 <strong>数组+链表</strong> 的形式</li>
<li><strong>实现线程安全的方式：</strong> <ul>
<li><strong>在 JDK1.7 的时候，<code>ConcurrentHashMap</code>（分段锁）</strong> 对整个桶数组进行了分割分段(<code>Segment</code>)，每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。 <strong>到了 JDK1.8 的时候已经摒弃了 <code>Segment</code> 的概念，而是直接用 <code>Node</code> 数组+链表+红黑树的数据结构来实现，并发控制使用 <code>synchronized</code> 和 CAS 来操作。（JDK1.6 以后 对 <code>synchronized</code> 锁做了很多优化）</strong> 整个看起来就像是优化过且线程安全的 <code>HashMap</code>，虽然在 JDK1.8 中还能看到 <code>Segment</code> 的数据结构，但是已经简化了属性，只是为了兼容旧版本</li>
<li><strong><code>Hashtable</code>(同一把锁)</strong> :使用 <code>synchronized</code> 来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用 put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低。</li>
<li><strong>总的来说，<code>HashTable</code>使用的是全表锁，JDK1.7的<code>ConcurrentHashMap</code>使用<code>Segment</code>分段锁，JDK1.8之后的<code>ConcurrentHashMap</code>使用Node数组+链表/红黑树，红黑树情况使用TreeNode</strong></li>
</ul>
</li>
</ul>
<h4 id="ConcurrentHashMap线程安全具体实现方法"><a href="#ConcurrentHashMap线程安全具体实现方法" class="headerlink" title="ConcurrentHashMap线程安全具体实现方法"></a>ConcurrentHashMap线程安全具体实现方法</h4><ul>
<li>JDK7，首先将数据分为一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据时，其他段的数据也能被其他线程访问。Segment 实现了 <code>ReentrantLock</code>,所以 <code>Segment</code> 是一种可重入锁，扮演锁的角色。</li>
<li>JDK8，<code>ConcurrentHashMap</code> 取消了 <code>Segment</code> 分段锁，采用 CAS 和 <code>synchronized</code> 来保证并发安全。<code>synchronized</code> 只锁定当前链表或红黑二叉树的首节点，这样只要 hash 不冲突，就不会产生并发。</li>
</ul>
<h4 id="ConcurrentHashMap底层实现"><a href="#ConcurrentHashMap底层实现" class="headerlink" title="ConcurrentHashMap底层实现"></a>ConcurrentHashMap底层实现</h4><ul>
<li><p>JDK1.7，<strong>Segment 数组 + HashEntry 数组 + 链表</strong>，使用<code>segment</code>分段锁实现并发，每一个segment类似HashMap的结构，在每个segment内部可以进行扩容，但是segment的个数不能改变，也就是并发的线程个数无法扩容。</p>
<ul>
<li><p>默认容量16，负载因子0.75，并发级别(segment个数)16</p>
</li>
<li><p>并发级别高于2^16时，会被强制设置为65536，同时在进行初始化时，会将并发级别设置为不超过设定值的最大2的倍数</p>
</li>
<li><p>每个segment的容量也必须是2的倍数</p>
</li>
<li><p>记录 segmentShift 偏移量，这个值为【容量 = 2 的N次方】中的 N，在后面 Put 时计算位置时会用到。<strong>默认是 32 - sshift = 28</strong>.</p>
</li>
<li><p>记录 segmentMask，默认是 ssize - 1 = 16 -1 = 15</p>
</li>
<li><p><code>put</code>操作：</p>
<ul>
<li><p>计算要 put 的 key 的位置，获取指定位置的 Segment。</p>
</li>
<li><p>如果指定位置的 Segment 为空，则初始化这个 Segment.</p>
<ul>
<li><strong>初始化 Segment 流程：</strong><ol>
<li>检查计算得到的位置的 Segment 是否为null.</li>
<li>为 null 继续初始化，使用 Segment[0] 的容量和负载因子创建一个 HashEntry 数组。</li>
<li>再次检查计算得到的指定位置的 Segment 是否为null.</li>
<li>使用创建的 HashEntry 数组初始化这个 Segment.</li>
<li>自旋判断计算得到的指定位置的 Segment 是否为null，使用 CAS 在这个位置赋值为 Segment.</li>
</ol>
</li>
</ul>
</li>
<li><p>Segment.put 插入 key,value 值</p>
<ul>
<li><p>tryLock() 获取锁，获取不到使用 <strong><code>scanAndLockForPut</code></strong> 方法继续获取。</p>
</li>
<li><p>计算 put 的数据要放入的 index 位置，然后获取这个位置上的 HashEntry </p>
</li>
<li><p>如果这个位置上的 <strong>HashEntry 不存在</strong>：</p>
<ol>
<li>如果当前容量大于扩容阀值，小于最大容量，<strong>进行扩容</strong>。</li>
<li>直接头插法插入。</li>
</ol>
<p>如果这个位置上的 <strong>HashEntry 存在</strong>：</p>
<ol>
<li>判断链表当前元素 Key 和 hash 值是否和要 put 的 key 和 hash 值一致。一致则替换值</li>
<li>不一致，获取链表下一个节点，直到发现相同进行值替换，或者链表表里完毕没有相同的。<ol>
<li>如果当前容量大于扩容阀值，小于最大容量，<strong>进行扩容</strong>。</li>
<li>直接链表头插法插入。</li>
</ol>
</li>
</ol>
</li>
<li><p>如果要插入的位置之前已经存在，替换后返回旧值，否则返回 null</p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>自旋获得锁时，如果尝试获取锁超过了一定次数，直接阻塞，直到获得锁</p>
</blockquote>
</li>
</ul>
</li>
<li><p>扩容<code>rehash</code>：ConcurrentHashMap 的扩容只会扩容到原来的两倍。老数组里的数据移动到新的数组时，位置要么不变，要么变为 index+ oldSize，参数里的 node 会在扩容之后使用链表<strong>头插法</strong>插入到指定位置</p>
</li>
<li><p>JDK1.8，<strong>Node 数组 + 链表 / 红黑树</strong></p>
<ul>
<li><p>ConcurrentHashMap 的初始化是通过<strong>自旋和 CAS</strong> 操作完成的，需要注意的是变量 <code>sizeCtl</code> ，它的值决定着当前的初始化状态</p>
<ol>
<li>-1 说明正在初始化</li>
<li>-N 说明有N-1个线程正在进行扩容</li>
<li>表示 table 初始化大小，如果 table 没有初始化</li>
<li>表示 table 容量，如果 table　已经初始化</li>
</ol>
</li>
<li><p><code>put</code>方法：</p>
<ul>
<li>根据 key 计算出 hashcode 。</li>
<li>判断是否需要进行初始化。</li>
<li>即为当前 key 定位出的 Node，如果为空表示当前位置可以写入数据，利用 CAS 尝试写入，失败则自旋保证成功。</li>
<li>如果当前位置的 <code>hashcode == MOVED == -1</code>,则需要进行扩容。</li>
<li>如果都不满足，则利用 synchronized 锁写入数据。</li>
<li>如果数量大于 <code>TREEIFY_THRESHOLD</code> 则要执行树化方法，在treeifyBin中会首先判断当前数组长度≥64时才会将链表转换为红黑树。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="Hash冲突解决方案"><a href="#Hash冲突解决方案" class="headerlink" title="Hash冲突解决方案"></a>Hash冲突解决方案</h4><ul>
<li>链地址法：使用链表和红黑树</li>
<li>线性探测再散列：线性向后探索，直到找到下一个空节点</li>
<li>再哈希法：多个hash函数，直到不冲突</li>
<li>建立公共溢出区：将哈希表分为基本表和溢出表，相当于使用多个哈希表</li>
</ul>
<h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><h3 id="为什么程序计数器、虚拟机栈和本地方法栈是线程私有的？"><a href="#为什么程序计数器、虚拟机栈和本地方法栈是线程私有的？" class="headerlink" title="为什么程序计数器、虚拟机栈和本地方法栈是线程私有的？"></a>为什么程序计数器、虚拟机栈和本地方法栈是线程私有的？</h3><ul>
<li><p><strong>程序计数器主要有下面两个作用</strong>：</p>
<ol>
<li>通过改变程序计数器来依次读取指令，从而实现代码的流程控制，</li>
<li>记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该从哪里开始运行</li>
</ol>
<p>需要注意的是，如果执行的是 native 方法，那么程序计数器记录的是 undefined 地址，只有执行的是 Java 代码时程序计数器记录的才是下一条指令的地址。</p>
<p>所以，程序计数器私有主要是为了<strong>线程切换后能恢复到正确的执行位置</strong></p>
</li>
<li><p>为了<strong>保证线程中的局部变量不被别的线程访问到</strong>，虚拟机栈和本地方法栈是线程私有的。</p>
<ul>
<li><p><strong>虚拟机栈：</strong> 每个 Java 方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至执行完成的过程，就对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程</p>
</li>
<li><p><strong>本地方法栈：</strong> 和虚拟机栈所发挥的作用非常相似，区别是： <strong>虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。</strong> 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一</p>
</li>
</ul>
</li>
</ul>
<h3 id="为什么要使用多线程？"><a href="#为什么要使用多线程？" class="headerlink" title="为什么要使用多线程？"></a>为什么要使用多线程？</h3><ul>
<li><p>先从总体上来说：</p>
<ul>
<li><strong>从计算机底层来说：</strong> 线程可以比作是轻量级的进程，是程序执行的最小单位,线程间的切换和调度的成本远远小于进程。另外，多核 CPU 时代意味着多个线程可以同时运行，这减少了线程上下文切换的开销。</li>
<li><strong>从当代互联网发展趋势来说：</strong>多线程并发编程是开发高并发系统的基础，利用好多线程机制可以大大提高系统整体的并发能力以及性能。</li>
</ul>
</li>
<li><p>再深入到计算机底层来探讨：</p>
<ul>
<li><strong>单核时代</strong>： <strong>在单核时代多线程主要是为了提高单进程利用 CPU 和 IO 系统的效率</strong>。 假设只运行了一个 Java 进程的情况，当我们请求 IO 的时候，如果 Java 进程中只有一个线程，此线程被 IO 阻塞则整个进程被阻塞。CPU 和 IO 设备只有一个在运行，那么可以简单地说系统整体效率只有 50%。当使用多线程的时候，一个线程被 IO 阻塞，其他线程还可以继续使用 CPU。从而提高了 Java 进程利用系统资源的整体效率。</li>
<li><strong>多核时代</strong>: <strong>多核时代多线程主要是为了提高进程利用多核 CPU 的能力</strong>。举个例子：假如我们要计算一个复杂的任务，我们只用一个线程的话，不论系统有几个 CPU 核心，都只会有一个 CPU 核心被利用到。而创建多个线程，这些线程可以被映射到底层多个 CPU 上执行，在任务中的多个线程没有资源竞争的情况下，任务执行的效率会有显著性的提高，约等于（单核时执行时间/CPU 核心数）。</li>
</ul>
</li>
</ul>
<h3 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h3><ul>
<li><strong>NEW（新建）</strong>：线程被创建之后处于的状态</li>
<li><strong>RUNNABLE（运行中）</strong>：NEW状态之后，调用<code>start()</code>方法后处于的状态，其实包含了两种状态<ul>
<li>READY(就绪)：调用<code>start()</code>方法后，处于的状态</li>
<li>RUNNING(运行)：线程获得CPU时间片之后，真正开始运行处于的状态</li>
<li><strong>JVM中不区分这两种状态</strong>：现在的操作系统架构导致每个线程最多一次在CPU上运行10-20ms，之后又会放到调度队列末尾再次调度，切换得太快，区分这两种状态没有意义</li>
</ul>
</li>
<li>**WAITING(等待)、TIMED_WAITING(超时等待)**：执行<code>wait()</code>方法后进入等待状态，如果加入了超时限制，就进入超时等待状态<ul>
<li>超时时间达到后，线程会返回到RUNNABLE状态</li>
</ul>
</li>
<li>**BLOCKED(阻塞)**：当线程调用同步方法，没有获得锁时，进入的状态</li>
<li>**TERMINATERD(终止)**：线程<code>run()</code>方法执行结束进入的状态</li>
</ul>
<p><img src="/2022/01/03/day29/day29_4.png" alt="Java 线程状态变迁"></p>
<h3 id="什么是死锁，产生死锁的条件"><a href="#什么是死锁，产生死锁的条件" class="headerlink" title="什么是死锁，产生死锁的条件"></a>什么是死锁，产生死锁的条件</h3><ul>
<li><p>死锁：两个线程分别都持有一个资源，同时都想要得到对方的资源，导致两个线程都阻塞</p>
</li>
<li><p>产生死锁的条件：</p>
<ul>
<li>互斥条件：该资源任意一个时刻只由一个线程占用。</li>
<li>请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。</li>
<li>不剥夺条件:线程已获得的资源在未使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。</li>
<li>循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系</li>
</ul>
</li>
</ul>
<h3 id="如何避免死锁"><a href="#如何避免死锁" class="headerlink" title="如何避免死锁"></a>如何避免死锁</h3><ul>
<li>破坏产生四个产生条件的其中一个</li>
<li>使用banker算法分配资源，使系统进入安全状态<ul>
<li>寻找安全序列：<ul>
<li>假设进程需要最多的资源</li>
<li>寻找使用空闲资源能够满足的进程（找不到进程，非安全状态）</li>
<li>释放该进程的资源</li>
<li>继续寻找进程</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="sleep和wait方法区别和共同点"><a href="#sleep和wait方法区别和共同点" class="headerlink" title="sleep和wait方法区别和共同点"></a>sleep和wait方法区别和共同点</h3><ul>
<li>两者最主要的区别在于：**<code>sleep()</code> 方法没有释放锁，而 <code>wait()</code> 方法释放了锁** 。</li>
<li>两者都可以暂停线程的执行。</li>
<li><code>wait()</code> 通常被用于线程间交互/通信，<code>sleep() </code>通常被用于暂停执行。</li>
<li><code>wait()</code> 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 <code>notify() </code>或者 <code>notifyAll()</code> 方法。<code>sleep() </code>方法执行完成后，线程会自动苏醒。或者可以使用 <code>wait(long timeout)</code> 超时后线程会自动苏醒。</li>
</ul>
<h3 id="为什么我们调用-start-方法时会执行-run-方法，为什么我们不能直接调用-run-方法？"><a href="#为什么我们调用-start-方法时会执行-run-方法，为什么我们不能直接调用-run-方法？" class="headerlink" title="为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run() 方法？"></a>为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run() 方法？</h3><ul>
<li><p>new 一个 Thread，线程进入了新建状态。调用 <code>start()</code>方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。 <code>start()</code> 会执行线程的相应准备工作，然后自动执行 <code>run()</code> 方法的内容，这是真正的多线程工作。 </p>
</li>
<li><p>直接执行 <code>run()</code> 方法，会把 <code>run()</code> 方法当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。</p>
</li>
<li><p><strong>总结： 调用 <code>start()</code> 方法方可启动线程并使线程进入就绪状态，直接执行 <code>run()</code> 方法的话不会以多线程的方式执行</strong></p>
</li>
</ul>
<h3 id="synchronized关键字"><a href="#synchronized关键字" class="headerlink" title="synchronized关键字"></a>synchronized关键字</h3><ul>
<li><p>在 Java 早期版本中，<code>synchronized</code> 属于 <strong>重量级锁</strong>，效率低下。因为监视器锁（monitor）是依赖于底层的操作系统的 <code>Mutex Lock</code> 来实现的，Java 的线程是映射到操作系统的原生线程之上的。如果要挂起或者唤醒一个线程，都需要操作系统帮忙完成，而操作系统实现线程之间的切换时需要从<strong>用户态转换到内核态</strong>，这个状态之间的转换需要相对比较长的时间，时间成本相对较高</p>
</li>
<li><p><strong>三种主要使用方式</strong>：</p>
<ul>
<li>修饰实例方法：相当于对当前对象加锁，进入同步代码前需要获得当前实例对象的锁</li>
<li>修饰静态方法：相当于对当前类加锁，进入同步代码前需要获得当前类的锁<ul>
<li>允许一个线程调用一个实例对象的非静态同步方法，同时另一个线程调用静态同步方法，因为获得的锁不同</li>
</ul>
</li>
<li>修饰代码块：指定加锁对象，对给定对象/类加锁。<code>synchronized(this|object)</code> 表示进入同步代码库前要获得<strong>给定对象的锁</strong>。<code>synchronized(类.class)</code> 表示进入同步代码前要获得 <strong>当前 class 的锁</strong></li>
<li>对于具有缓存功能的对象，尽量不使用synchronized加锁，例如尽量不使用sychronized(String s)，可能会导致线程不执行</li>
</ul>
</li>
<li><p><strong>构造方法不能被synchronized关键字修饰，因为构造方法本身就是线程安全的</strong>，对象还未产生，就不存在加不加锁的问题</p>
</li>
<li><p>双重检验锁方式实现单例模式：</p>
<ul>
<li><p><code>uniqueInstance</code> 采用 <code>volatile</code> 关键字修饰也是很有必要，对象创建其实分为三步：</p>
<ul>
<li>为 <code>uniqueInstance</code> 分配内存空间</li>
<li>初始化 <code>uniqueInstance</code></li>
<li>将 <code>uniqueInstance</code> 指向分配的内存地址</li>
</ul>
<p>volatile可以防止指令重排，在多线程情况下可以保证获得的单例模式对象不为空</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton uniqueInstance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">static</span> Singleton <span class="title">getUniqueInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">//先判断对象是否已经实例过，没有实例化过才进入加锁代码</span></span><br><span class="line">        <span class="keyword">if</span> (uniqueInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//类对象加锁</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (uniqueInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    uniqueInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="synchronized底层原理"><a href="#synchronized底层原理" class="headerlink" title="synchronized底层原理"></a>synchronized底层原理</h3><ul>
<li>修饰同步代码块：<code>synchronized</code> 同步语句块的实现使用的是 <code>monitorenter</code> 和 <code>monitorexit</code> 指令，其中 <code>monitorenter</code> 指令指向同步代码块的开始位置，<code>monitorexit</code> 指令则指明同步代码块的结束位置。<ul>
<li>在 Java 虚拟机(HotSpot)中，Monitor 是基于 C++实现的，由ObjectMonitor实现的。每个对象中都内置了一个 <code>ObjectMonitor</code>对象</li>
<li>在执行<code>monitorenter</code>时，会尝试获取对象的锁，如果锁的计数器为 0 则表示锁可以被获取，获取后将锁计数器设为 1 也就是加 1</li>
<li>对象锁的的拥有者线程才可以执行 <code>monitorexit</code> 指令来释放锁。在执行 <code>monitorexit</code> 指令后，将锁计数器设为 0，表明锁被释放，其他线程可以尝试获取锁</li>
<li>如果获取对象锁失败，那当前线程就要阻塞等待，直到锁被另外一个线程释放为止</li>
</ul>
</li>
<li>修饰方法：<code>synchronized</code> 修饰的方法并没有 <code>monitorenter</code> 指令和 <code>monitorexit</code> 指令，取得代之的确实是 <code>ACC_SYNCHRONIZED</code> 标识，该标识指明了该方法是一个同步方法。JVM 通过该 <code>ACC_SYNCHRONIZED</code> 访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用。<ul>
<li>如果是实例方法，JVM 会尝试获取实例对象的锁。如果是静态方法，JVM 会尝试获取当前 class 的锁</li>
</ul>
</li>
</ul>
<h3 id="JDK1-6-之后的-synchronized-关键字底层做了哪些优化"><a href="#JDK1-6-之后的-synchronized-关键字底层做了哪些优化" class="headerlink" title="JDK1.6 之后的 synchronized 关键字底层做了哪些优化"></a>JDK1.6 之后的 synchronized 关键字底层做了哪些优化</h3><ul>
<li><p>JDK1.6 对锁的实现引入了大量的优化，如偏向锁、轻量级锁、自旋锁、适应性自旋锁、锁消除、锁粗化等技术来减少锁操作的开销</p>
<ul>
<li><code>自旋锁</code>：对于锁状态很短的线程，挂起和恢复线程是开销很大的，因此让线程执行一个忙等待（自旋），这就是自旋锁的技术</li>
<li><code>自适应锁</code>：本质还是自旋锁，如果上次通过自旋获得了锁，这次可以等待时间长一些，否则，等待时间变短</li>
<li><code>锁消除</code>：方法体中的所有数据都不会逃逸出去，是线程私有的，可以不使用锁</li>
<li><code>锁粗化</code>：频繁获得锁释放锁很消耗资源，可以将锁的范围扩大</li>
</ul>
</li>
<li><p>锁主要存在四种状态，依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态。注意锁可以升级不可降级，这种策略是为了提高获得锁和释放锁的效率。</p>
</li>
<li><p>锁的升级：</p>
<ul>
<li><p><strong>偏向锁</strong>：有竞争才释放锁。某个线程持有当前锁后，当前java对象头会存储锁偏向的线程ID。没有竞争的情况下，相同线程下次再获得相同的锁，不需要使用CAS进行竞争，也不用释放。</p>
<ul>
<li><strong>偏向锁释放</strong>：如果有其他线程竞争锁，偏向锁的释放需要等到全局安全点（没有正在执行的字节码）。首先暂停持有锁的线程，其次检测该线程是否活着，如果死亡，则将对象头设置为无锁状态；如果活着，遍历偏向对象的锁记录，修改对象头和栈中的锁记录，要么偏向于另一个线程，要么恢复无锁，要么标记对象不适合作为偏向锁</li>
</ul>
</li>
<li><p><strong>轻量级锁</strong>：将对象头中的Mark Word赋值记录到栈帧的锁记录中，使用CAS修改对象头，获得锁。如果有其他线程竞争锁，当前线程没有释放锁的情况下，其他线程会通过自旋来获得锁。当前线程释放锁时，会再次使用CAS将保存的对象头信息重新写入对象头。</p>
</li>
<li><p><strong>轻量级锁升级</strong>：长时间自旋导致CPU消耗，CAS自旋10次还未获得锁；竞争的线程超过CPU核数的一半。自动升级为重量级锁</p>
</li>
<li><p><strong>重量级锁</strong>：竞争的线程较多，阻塞所有等待竞争的线程，防止CPU空转，阻塞等待线程释放锁后进入无锁状态重新竞争</p>
<ul>
<li>线程在进入Contention List时阻塞等待之前，程会先尝试自旋使用CAS操作获取锁，如果获取不到就进入Contention List队列的尾部</li>
<li>Owner线程在解锁时，如果Entry List为空，那么会<strong>先将Contention List中队列尾部的部分线程移动到Entry List</strong></li>
<li>Owner线程在解锁时，如果Entry List不为空，从Entry List中取一个线程，让它成为OnDeck线程，Owner线程并不直接把锁传递给OnDeck线程，而是把<strong>锁竞争</strong>的权利交给OnDeck，OnDeck需要重新竞争锁，JVM中这种选择行为称为 “竞争切换”。（<strong>主要是与还没有进入到ContentionList，还在自旋获取重量级锁的线程竞争</strong>）</li>
<li>OnDeck线程获取到锁，成为Owner线程进行执行。</li>
</ul>
</li>
<li><p>Owner线程调用锁对象的wait（）方法进行等待，会移动到Wait Set中，并且会释放CPU资源，也同时释放锁，</p>
<ul>
<li>当其他线程调用锁对象的notify（）方法，之前调用wait方法等待的这个线程才会从Wait Set移动到Entry List，等待获取锁</li>
</ul>
<p><img src="/2022/01/03/day29/day29_28.png" alt="重量级锁"></p>
</li>
</ul>
</li>
</ul>
<h3 id="为什么JDK8在4s之后才开启偏向锁？"><a href="#为什么JDK8在4s之后才开启偏向锁？" class="headerlink" title="为什么JDK8在4s之后才开启偏向锁？"></a>为什么JDK8在4s之后才开启偏向锁？</h3><ul>
<li>代码刚执行时，一定有很多线程来竞争锁，开启了偏向锁反而效率低</li>
</ul>
<h3 id="synchronized-和-ReentrantLock-的区别"><a href="#synchronized-和-ReentrantLock-的区别" class="headerlink" title="synchronized 和 ReentrantLock 的区别"></a>synchronized 和 ReentrantLock 的区别</h3><ul>
<li><p>两者都是可重入锁：<strong>“可重入锁”</strong> 指的是自己可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果不可锁重入的话，就会造成死锁。<strong>同一个线程每次获取锁，锁的计数器都自增 1，所以要等到锁的计数器下降为 0 时才能释放锁。</strong></p>
</li>
<li><p>synchronized 依赖于 JVM 而 ReentrantLock 依赖于 API：<code>synchronized</code> 是依赖于 JVM 实现的，优化都是在虚拟机层面实现的，并没有直接暴露给我们。<code>ReentrantLock</code> 是 JDK 层面实现的（也就是 API 层面，需要 lock() 和 unlock() 方法配合 try/finally 语句块来完成）。</p>
</li>
<li><p>发生异常时，synchronized会自动释放锁，ReetrantLock需要开发者手动释放</p>
</li>
<li><p>ReentrantLock 比 synchronized 增加了一些高级功能：</p>
<ul>
<li><strong>等待可中断</strong> : <code>ReentrantLock</code>提供了一种能够中断等待锁的线程的机制，通过<code>lock.lockInterruptibly()</code> 来实现这个机制。也就是说正在等待的线程可以选择放弃等待，改为处理其他事情。</li>
<li><strong>可实现公平锁</strong> : <code>ReentrantLock</code>可以指定是公平锁还是非公平锁。而<code>synchronized</code>只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。<code>ReentrantLock</code>默认情况是非公平的，可以通过 <code>ReentrantLock</code>类的<code>ReentrantLock(boolean fair)</code>构造方法来制定是否是公平的。</li>
<li><strong>可实现选择性通知（锁可以绑定多个条件）</strong>: <code>ReentrantLock</code>类可以实现对指定线程的通知唤醒，但是需要借助于<code>Condition</code>接口与<code>newCondition()</code>方法。</li>
</ul>
<blockquote>
<p><code>Condition</code>是 JDK1.5 之后才有的，它具有很好的灵活性，比如可以实现多路通知功能也就是在一个<code>Lock</code>对象中可以创建多个<code>Condition</code>实例（即对象监视器），<strong>线程对象可以注册在指定的<code>Condition</code>中，从而可以有选择性的进行线程通知，在调度线程上更加灵活。 在使用<code>notify()/notifyAll()</code>方法进行通知时，被通知的线程是由 JVM 选择的，用<code>ReentrantLock</code>类结合<code>Condition</code>实例可以实现“选择性通知”</strong> 。而<code>synchronized</code>关键字就相当于整个 Lock 对象中只有一个<code>Condition</code>实例，所有的线程都注册在它一个身上。如果执行<code>notifyAll()</code>方法的话就会通知所有处于等待状态的线程这样会造成很大的效率问题，而<code>Condition</code>实例的<code>signalAll()</code>方法 只会唤醒注册在该<code>Condition</code>实例中的所有等待线程。</p>
</blockquote>
</li>
</ul>
<h3 id="并发编程的三个重要特性"><a href="#并发编程的三个重要特性" class="headerlink" title="并发编程的三个重要特性"></a>并发编程的三个重要特性</h3><ul>
<li><p><strong>原子性</strong> : 一个的操作或者多次操作，要么所有的操作全部都得到执行并且不会受到任何因素的干扰而中断，要么所有的操作都执行，要么都不执行。<code>synchronized</code> 可以保证代码片段的原子性。</p>
</li>
<li><p><strong>可见性</strong> ：当一个线程对共享变量进行了修改，那么另外的线程都是立即可以看到修改后的最新值。<code>volatile</code> 关键字可以保证共享变量的可见性。</p>
</li>
<li><p><strong>有序性</strong> ：代码在执行的过程中的先后顺序，Java 在编译器以及运行期间的优化，代码的执行顺序未必就是编写代码时候的顺序。<code>volatile</code> 关键字可以禁止指令进行重排序优化。</p>
</li>
</ul>
<h3 id="volatile和synchronized关键字区别"><a href="#volatile和synchronized关键字区别" class="headerlink" title="volatile和synchronized关键字区别"></a>volatile和synchronized关键字区别</h3><ul>
<li><p><code>volatile</code> 关键字 除了防止 JVM 的指令重排 ，还有一个重要的作用就是保证变量的可见性</p>
<blockquote>
<p>volatile：将数据写入系统内存。采用缓存一致性协议，其他cpu在使用缓存数据时会进行嗅探，如果发现自己的缓存行地址对应的内存地址发生变换，则缓存无效</p>
<p>读取共享变量时，会先清空本地内存的变量值，再从主内存中获取最新值</p>
<p>写入共享变量时，会直接写到主内存中，而且会导致其他线程的缓存无效</p>
</blockquote>
</li>
<li><p><strong><code>volatile</code> 关键字</strong>是线程同步的<strong>轻量级实现</strong>，所以 <strong><code>volatile </code>性能肯定比<code>synchronized</code>关键字要好</strong> 。但是 <strong><code>volatile</code> 关键字只能用于变量而 <code>synchronized</code> 关键字可以修饰方法以及代码块</strong> </p>
</li>
<li><p><strong><code>volatile</code> 关键字能保证数据的可见性，但不能保证数据的原子性。<code>synchronized</code> 关键字两者都能保证。</strong></p>
</li>
<li><p>volatile是非阻塞的，synchronized阻塞</p>
</li>
<li><p><strong><code>volatile</code>关键字主要用于解决变量在多个线程之间的可见性，而 <code>synchronized</code> 关键字解决的是多个线程之间访问资源的同步性。</strong></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实现单例模式，线程安全</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton singleton = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(singleton == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Singleton.class)&#123;</span><br><span class="line">                <span class="keyword">if</span>(singleton ==<span class="keyword">null</span>) &#123;</span><br><span class="line">                    singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="ThreadLocal原理"><a href="#ThreadLocal原理" class="headerlink" title="ThreadLocal原理"></a>ThreadLocal原理</h3><ul>
<li><p>访问<code>ThreadLocal</code>变量的每个线程都会有这个变量的本地副本。他们可以使用 <code>get（）</code> 和 <code>set（）</code> 方法来获取默认值或将其值更改为当前线程所存的副本的值，从而避免了线程安全问题</p>
</li>
<li><p>最终的变量是放在了当前线程的 <code>ThreadLocalMap</code> 中，并不是存在 <code>ThreadLocal</code> 上，<code>ThreadLocal</code> 可以理解为只是<code>ThreadLocalMap</code>的封装，传递了变量值。<code>ThrealLocal</code> 类中可以通<code>Thread.currentThread()</code>获取到当前线程对象后，直接通过<code>getMap(Thread t)</code>可以访问到该线程的<code>ThreadLocalMap</code>对象，每个<code>Thread</code>中都具备一个<code>ThreadLocalMap</code>，而<code>ThreadLocalMap</code>可以存储以<code>ThreadLocal</code>为 key ，Object 对象为 value 的键值对</p>
<p><img src="/2022/01/03/day29/day29_5.png" alt="ThreadLocal数据结构"></p>
</li>
</ul>
<h3 id="ThreadLocal-内存泄露问题"><a href="#ThreadLocal-内存泄露问题" class="headerlink" title="ThreadLocal 内存泄露问题"></a>ThreadLocal 内存泄露问题</h3><ul>
<li><p><code>ThreadLocalMap</code> 中使用的 <strong>key 为 <code>ThreadLocal</code> 的弱引用</strong>,而 value 是强引用。所以，如果 <code>ThreadLocal</code> 没有被外部强引用的情况下，在垃圾回收的时候，key 会被清理掉，而 value 不会被清理掉。这样一来，<code>ThreadLocalMap</code> 中就会出现 key 为 null 的 Entry。假如我们不做任何措施的话，value 永远无法被 GC 回收，这个时候就可能会产生内存泄露。ThreadLocalMap 实现中已经考虑了这种情况，在调用 <code>set()</code>、<code>get()</code>、<code>remove()</code> 方法的时候，会清理掉 key 为 null 的记录。使用完 <code>ThreadLocal</code>方法后 最好手动调用<code>remove()</code>方法</p>
<blockquote>
<p>为什么要把key设计为弱引用？</p>
<p>当我们在外部将ThreadLocal变量的强引用设置为null时，Entry中的ThreadLocal理应被回收，如果设置为强引用就无法被回收</p>
</blockquote>
</li>
</ul>
<h3 id="ThreadLocalMap"><a href="#ThreadLocalMap" class="headerlink" title="ThreadLocalMap"></a>ThreadLocalMap</h3><ul>
<li>类似HashMap，但底层数据结构只是数组</li>
<li>threadLocalHashCode的计算，采用黄金分割数，每创建一个ThreadLocal对象就加1，hash分布很均匀</li>
<li>采用线性探测法处理hash冲突，线性探测遇到过期的数据时，会进行数据清理<ul>
<li>探测式数据清理：以当前Entry 向后迭代查找，遇到为null则结束清理，遇到entry为空的值，清空数组位置，size–。非空的entry计算重哈希的位置</li>
<li>启发性清理：向后递归查找一个过期的位置，找到过期的位置触发探测性清理</li>
</ul>
</li>
</ul>
<h3 id="线程池的好处"><a href="#线程池的好处" class="headerlink" title="线程池的好处"></a>线程池的好处</h3><ul>
<li><strong>降低资源消耗</strong>。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li>
<li><strong>提高响应速度</strong>。当任务到达时，任务可以不需要等到线程创建就能立即执行。</li>
<li><strong>提高线程的可管理性</strong>。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li>
</ul>
<h3 id="线程池的状态"><a href="#线程池的状态" class="headerlink" title="线程池的状态"></a>线程池的状态</h3><p><img src="/2022/01/03/day29/day29_27.png" alt="线程池状态"></p>
<ul>
<li><p><code>RUNNING</code>：线程池处在RUNNING状态时，能够接收新任务，以及对已添加的任务进行处理。线程池一被创建就处于RUNNING状态</p>
</li>
<li><p><code>SHUTDOWN</code>：线程池处在SHUTDOWN状态时，不接收新任务，但能处理已添加的任务</p>
<ul>
<li>调用线程池的shutdown()接口时，线程池由RUNNING -&gt; SHUTDOWN</li>
</ul>
</li>
<li><p><code>STOP</code>：线程池处在STOP状态时，不接收新任务，不处理已添加的任务，并且会中断正在处理的任务</p>
<ul>
<li>调用线程池的shutdownNow()接口时，线程池由(RUNNING or SHUTDOWN ) -&gt; STOP。</li>
</ul>
</li>
<li><p><code>TIDYING</code>：当所有的任务已终止，ctl记录的”任务数量”为0，线程池会变为TIDYING状态</p>
<ul>
<li>当线程池在SHUTDOWN状态下，阻塞队列为空并且线程池中执行的任务也为空时，就会由 SHUTDOWN -&gt; TIDYING。当线程池在STOP状态下，线程池中执行的任务为空时，就会由STOP -&gt; TIDYING。</li>
</ul>
</li>
<li><p><code>TERMINATED</code>：线程池彻底终止，就变成TERMINATED状态</p>
<ul>
<li>线程池处在TIDYING状态时，执行完terminated()之后，就会由 TIDYING -&gt; TERMINATED</li>
</ul>
</li>
</ul>
<h3 id="实现-Runnable-接口和-Callable-接口的区别"><a href="#实现-Runnable-接口和-Callable-接口的区别" class="headerlink" title="实现 Runnable 接口和 Callable 接口的区别"></a>实现 Runnable 接口和 Callable 接口的区别</h3><ul>
<li><code>Runnable</code> 接口<em>不会返回结果或抛出检查异常，但是 <code>Callable</code> 接口</em>可以。所以，如果任务不需要返回结果或抛出异常推荐使用 <strong><code>Runnable</code> 接口</strong> 。</li>
</ul>
<h3 id="执行-execute-方法和-submit-方法的区别是什么呢？"><a href="#执行-execute-方法和-submit-方法的区别是什么呢？" class="headerlink" title="执行 execute()方法和 submit()方法的区别是什么呢？"></a>执行 execute()方法和 submit()方法的区别是什么呢？</h3><ul>
<li><code>execute()</code>方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功与否；</li>
<li><code>submit()</code>方法用于提交需要返回值的任务。线程池会返回一个 <code>Future</code> 类型的对象，通过这个 <code>Future</code> 对象可以判断任务是否执行成功，并且可以通过 <code>Future</code> 的 <code>get()</code>方法来获取返回值，<code>get()</code>方法会阻塞当前线程直到任务完成，而使用 <code>get(long timeout，TimeUnit unit)</code>方法则会阻塞当前线程一段时间后立即返回，这时候有可能任务没有执行完。</li>
</ul>
<h3 id="ThreadPoolExecutor参数分析"><a href="#ThreadPoolExecutor参数分析" class="headerlink" title="ThreadPoolExecutor参数分析"></a>ThreadPoolExecutor参数分析</h3><ul>
<li><strong><code>corePoolSize</code> :</strong> 核心线程数定义了最小可以同时运行的线程数量。</li>
<li><strong><code>maximumPoolSize</code> :</strong> 当队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。</li>
<li><strong><code>workQueue</code>:</strong> 当新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中</li>
<li><strong><code>keepAliveTime</code></strong>:当线程池中的线程数量大于 <code>corePoolSize</code> 的时候，如果这时没有新的任务提交，核心线程外的空闲线程不会立即销毁，而是会等待，直到等待的时间超过了 <code>keepAliveTime</code>才会被回收销毁；</li>
<li><strong><code>unit</code></strong> : <code>keepAliveTime</code> 参数的时间单位。</li>
<li><strong><code>threadFactory</code></strong> :executor 创建新线程的时候会用到。</li>
<li><strong><code>handler</code></strong> :饱和策略，同时运行的线程数量达到最大线程数量并且队列也已经被放满了任务，称为饱和<ul>
<li><strong><code>ThreadPoolExecutor.AbortPolicy</code>：</strong> 抛出 <code>RejectedExecutionException</code>来拒绝新任务的处理。</li>
<li><strong><code>ThreadPoolExecutor.CallerRunsPolicy</code>：</strong> 调用执行自己的线程运行任务，也就是直接在调用<code>execute</code>方法的线程中运行(<code>run</code>)被拒绝的任务，如果执行程序已关闭，则会丢弃该任务。因此这种策略会降低对于新任务提交速度，影响程序的整体性能。</li>
<li><strong><code>ThreadPoolExecutor.DiscardPolicy</code>：</strong> 不处理新任务，直接丢弃掉。</li>
<li><strong><code>ThreadPoolExecutor.DiscardOldestPolicy</code>：</strong> 此策略将丢弃最早的未处理的任务请求</li>
</ul>
</li>
</ul>
<p><img src="/2022/01/03/day29/day29_6.png" alt="线程池实现原理"></p>
<h3 id="FixedThreadPool、SingleThreadExecutor和CachedThreadPool"><a href="#FixedThreadPool、SingleThreadExecutor和CachedThreadPool" class="headerlink" title="FixedThreadPool、SingleThreadExecutor和CachedThreadPool"></a>FixedThreadPool、SingleThreadExecutor和CachedThreadPool</h3><ul>
<li><p><strong>FixedThreadPool</strong>：固定线程数的线程池，调用ThreadPoolExecutor实现</p>
<ul>
<li><code>FixedThreadPool</code> 使用无界队列 <code>LinkedBlockingQueue</code>（队列的容量为 Integer.MAX_VALUE）作为线程池的工作队列，任务较多时会出现OOM</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                       <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                       <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(),</span><br><span class="line">                       threadFactory);</span><br></pre></td></tr></table></figure></li>
<li><p><strong>SingleThreadExecutor</strong>：只有一个线程的线程池，同样也是使用无界队列作为线程池的工作队列</p>
</li>
<li><p><strong>CachedThreadPool</strong>：<code>corePoolSize</code>设置为0，<code>maximumPoolSize</code>设置为Integer.MAX_VALUE，无界</p>
<ul>
<li>如果任务的添加速度大于线程的处理速度，会不断创建线程，耗尽CPU资源</li>
</ul>
</li>
</ul>
<h3 id="Atomic原子类有哪些"><a href="#Atomic原子类有哪些" class="headerlink" title="Atomic原子类有哪些"></a>Atomic原子类有哪些</h3><ul>
<li><strong>基本类型</strong>：使用原子的方式更新基本类型<ul>
<li><code>AtomicInteger</code>：整形原子类</li>
<li><code>AtomicLong</code>：长整型原子类</li>
<li><code>AtomicBoolean</code>：布尔型原子类</li>
</ul>
</li>
<li><strong>数组类型</strong>：使用原子的方式更新数组里的某个元素<ul>
<li><code>AtomicIntegerArray</code>：整形数组原子类</li>
<li><code>AtomicLongArray</code>：长整形数组原子类</li>
<li><code>AtomicReferenceArray</code>：引用类型数组原子类</li>
</ul>
</li>
<li><strong>引用类型</strong><ul>
<li><code>AtomicReference</code>：引用类型原子类</li>
<li><code>AtomicStampedReference</code>：原子更新带有版本号的引用类型。该类将整数值与引用关联起来，可用于解决原子的更新数据和数据的版本号，可以解决使用 CAS 进行原子更新时可能出现的 ABA 问题。</li>
<li><code>AtomicMarkableReference</code> ：原子更新带有标记位的引用类型</li>
</ul>
</li>
<li><strong>对象的属性修改类型</strong>：原子更新某个类里的某个字段，更新的对象属性必须使用 public volatile 修饰符<ul>
<li><code>AtomicIntegerFieldUpdater</code>：原子更新整形字段的更新器</li>
<li><code>AtomicLongFieldUpdater</code>：原子更新长整形字段的更新器</li>
<li><code>AtomicReferenceFieldUpdater</code>：原子更新引用类型字段的更新器</li>
</ul>
</li>
</ul>
<h3 id="AtomicInteger-线程安全原理简单分析"><a href="#AtomicInteger-线程安全原理简单分析" class="headerlink" title="AtomicInteger 线程安全原理简单分析"></a>AtomicInteger 线程安全原理简单分析</h3><ul>
<li>AtomicInteger 类主要利用 CAS (compare and swap) + volatile 和 native 方法来保证原子操作，从而避免 synchronized 的高开销，执行效率大为提升。</li>
<li>CAS的原理是拿期望的值和原本的一个值作比较，如果相同则更新成新的值。UnSafe 类的 objectFieldOffset() 方法是一个本地方法，这个方法是用来拿到“原来的值”的内存地址，返回值是 valueOffset。另外 value 是一个volatile变量，在内存中可见，因此 JVM 可以保证任何时刻任何线程总能拿到该变量的最新值。</li>
</ul>
<h3 id="AQS原理"><a href="#AQS原理" class="headerlink" title="AQS原理"></a>AQS原理</h3><ul>
<li><strong>AQS 核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制 AQS 是用 CLH 队列锁实现的，即将暂时获取不到锁的线程加入到队列中。</strong></li>
</ul>
<p><img src="/2022/01/03/day29/day29_7.png" alt="AQS原理图"></p>
<ul>
<li>AQS 使用一个 <code>private volatile int</code> 成员变量来表示同步状态，通过内置的 FIFO 队列来完成获取资源线程的排队工作。AQS 使用 CAS 对该同步状态进行原子操作实现对其值的修改，控制线程的同步</li>
<li><strong>AQS 定义两种资源共享方式</strong></li>
<li>独占：只有一个线程能够获得资源，又分为公平锁和非公平锁<ul>
<li>共享：多个线程可同时执行，如<code> CountDownLatch</code>、<code>Semaphore</code>、 <code>CyclicBarrier</code>、<code>ReadWriteLock</code>等</li>
</ul>
</li>
<li><strong>AQS 底层使用了模板方法模式</strong></li>
</ul>
<h3 id="AQS-组件总结"><a href="#AQS-组件总结" class="headerlink" title="AQS 组件总结"></a>AQS 组件总结</h3><ul>
<li><strong><code>Semaphore</code>(信号量)-允许多个线程同时访问：</strong> <code>synchronized</code> 和 <code>ReentrantLock</code> 都是一次只允许一个线程访问某个资源，<code>Semaphore</code>(信号量)可以指定多个线程同时访问某个资源<ul>
<li>每次访问资源需要得到许可证，许可证的个数可以设置</li>
<li>支持公平和非公平模式</li>
</ul>
</li>
<li><strong><code>CountDownLatch </code>（倒计时器）：</strong> <code>CountDownLatch</code> 是一个同步工具类，用来协调多个线程之间的同步。这个工具通常用来控制线程等待，它可以让某一个线程等待直到倒计时结束，再开始执行。</li>
<li><strong><code>CyclicBarrier</code>(循环栅栏)：</strong> <code>CyclicBarrier</code> 和 <code>CountDownLatch</code> 非常类似，它也可以实现线程间的技术等待，但是它的功能比 <code>CountDownLatch</code> 更加复杂和强大。主要应用场景和 <code>CountDownLatch</code> 类似。<code>CyclicBarrier</code> 意思是可循环使用（<code>Cyclic</code>）的屏障（<code>Barrier</code>）。它要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活。<code>CyclicBarrier</code> 默认的构造方法是 <code>CyclicBarrier(int parties)</code>，其参数表示屏障拦截的线程数量，每个线程调用 <code>await()</code> 方法告诉 <code>CyclicBarrier</code> 我已经到达了屏障，然后当前线程被阻塞<ul>
<li><code>CyclicBarrier</code> 可以用于多线程计算数据，最后合并计算结果的应用场景</li>
</ul>
</li>
</ul>
<h3 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h3><ul>
<li><p><code>CopyOnWriteArrayList</code> 类的所有可变操作（add，set 等等）都是通过创建底层数组的新副本来实现的。当 List 需要被修改的时候，并不修改原有内容，而是对原有数据进行一次复制，将修改的内容写入副本。写完之后，再将修改完的副本替换原来的数据，这样就可以保证<strong>写操作不会影响读操作了，适合读多写少的场景</strong></p>
</li>
<li><p>写入操作：加锁后复制数组进行修改</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Appends the specified element to the end of this list.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e element to be appended to this list</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; (as specified by &#123;<span class="doctag">@link</span> Collection#add&#125;)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();<span class="comment">//加锁</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="keyword">int</span> len = elements.length;</span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);<span class="comment">//拷贝新数组</span></span><br><span class="line">        newElements[len] = e;</span><br><span class="line">        setArray(newElements);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();<span class="comment">//释放锁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Blocking-Queue"><a href="#Blocking-Queue" class="headerlink" title="Blocking Queue"></a>Blocking Queue</h3><ul>
<li><p>阻塞队列：被广泛使用在“生产者-消费者”问题中，其原因是 <code>BlockingQueue</code> 提供了可阻塞的插入和移除的方法。当队列容器已满，生产者线程会被阻塞，直到队列未满；当队列容器为空时，消费者线程会被阻塞，直至队列非空时为止</p>
</li>
<li><p><strong>ArrayBlockingQueue</strong>：有界队列实现，底层为数组。一旦创建，容量无法改变，插入取出操作都需要获得锁。队列容量满时，阻塞插入操作；队列为空时，阻塞取出操作。默认为非公平</p>
</li>
<li><p><strong>LinkedBlockingQueue</strong>：可以当做无界队列也可以当做有界队列来使用，同样满足 FIFO 的特性，底层为单向链表，吞吐量更大</p>
</li>
<li><p><strong>PriorityBlockingQueue</strong>：支持优先级的误解阻塞队列，可以指定初始容量。并发控制采用ReentrantLock</p>
</li>
</ul>
<h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><h3 id="内存区域"><a href="#内存区域" class="headerlink" title="内存区域"></a>内存区域</h3><h4 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h4><ul>
<li><p>JDK1.8之前</p>
<p><img src="/2022/01/03/day29/day29_8.png" alt="JDK8之前"></p>
</li>
<li><p>JDK8之后</p>
<p><img src="/2022/01/03/day29/day29_9.png" alt="JDK8之后"></p>
</li>
</ul>
<h4 id="线程私有区域"><a href="#线程私有区域" class="headerlink" title="线程私有区域"></a>线程私有区域</h4><ul>
<li><p><strong>程序计数器</strong></p>
</li>
<li><p>实现代码的流程控制</p>
</li>
<li><p>多线程情况下，方便恢复线程程序</p>
</li>
<li><p><strong>唯一一个不会OutofMemory的区域，随线程创建而创建，随线程死亡而死亡</strong></p>
</li>
<li><p><strong>虚拟机栈</strong>：生命周期和程序计数器相同，不存在垃圾回收</p>
<ul>
<li><p>当虚拟机栈不允许动态扩展时，会出现StackOverFlow，如果允许动态扩展，会出现OutOfMemory</p>
</li>
<li><p>由一个一个栈帧组成，每个栈帧包含局部变量表、操作数栈、动态链接、方法出口信息</p>
</li>
<li><p><code>局部变量表</code>：存储方法参数和在方法内定义的局部变量。使用<code>slot(变量槽)</code>存储，this指针放在index为0的槽内</p>
</li>
<li><p><code>操作数栈</code>：方法执行过程中，往栈中写入或提取数据，作为计算过程中变量的临时存储空间，方法返回值也会放入操作数栈</p>
</li>
<li><p><code>动态链接</code>：每一个栈帧中都包含一个指向运行时常量池中该栈帧所属方法的引用，包含引用的目的就是为了实现动态链接，Java源文件被编译为字节码后，所有的变量和方法引用都会作为符号引用保存在class文件的常量池中，<strong>将符号引用转为调用方法的直接引用称为动态链接</strong></p>
<blockquote>
<p>方法的调用：</p>
<p>Java 栈可以类比数据结构中栈，Java 栈中保存的主要内容是栈帧，每一次函数调用都会有一个对应的栈帧被压入 Java 栈，每一个函数调用结束后，都会有一个栈帧被弹出</p>
</blockquote>
</li>
</ul>
</li>
<li><p><strong>本地方法栈</strong>：和虚拟机栈类似，主要为<strong>native方法</strong>服务，在HotySpot虚拟机中，与虚拟机栈合二为一</p>
</li>
</ul>
<h4 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h4><ul>
<li>内存中最大的一块，线程共享，在虚拟机启动时创建，是GC的主要区域</li>
<li>几乎所有的对象实例和数组都在堆上分配内存，但也不是绝对，<strong>例如JDK1.7之后会进行逃逸分析，方法中的对象引用没有被返回或未被方法外使用，可以直接在栈上分配</strong></li>
<li>堆中的对象又分为年轻代、老年代和永久代，jdk8之后将永久代放入了元空间中：<ul>
<li>年轻代：生命周期较短的对象<ul>
<li>年轻代分为：Eden空间，s0空间和s1空间，默认情况下的内存比例为8：1：1，几乎所有对象都是在Eden空间创建出来的</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>为什么又两个Survior区域：</p>
<ol>
<li>只有一个的话，有对象进入老年代时会产生空间碎片，最后可能会触发minorGC</li>
<li>新生代的垃圾回收算法采用标记-复制算法，需要两个区域</li>
</ol>
</blockquote>
<ul>
<li><p>老年代：生命周期较长的对象</p>
</li>
<li><p>容易出现OutOfMemory，比如：</p>
<ul>
<li><p><strong><code>java.lang.OutOfMemoryError: GC Overhead Limit Exceeded</code></strong> ： 当 JVM 花太多时间执行垃圾回收并且只能回收很少的堆空间时，就会发生此错误。</p>
<p><strong><code>java.lang.OutOfMemoryError: Java heap space</code></strong> :假如在创建新的对象时, 堆内存中的空间不足以存放新创建的对象, 就会引发此错误。(和配置的最大堆内存有关，且受制于物理内存大小。最大堆内存可通过<code>-Xmx</code>参数配置，若没有特别配置，将会使用默认值）</p>
</li>
</ul>
</li>
</ul>
<h4 id="堆、栈和方法区的关系"><a href="#堆、栈和方法区的关系" class="headerlink" title="堆、栈和方法区的关系"></a>堆、栈和方法区的关系</h4><ul>
<li><strong>方法区</strong>：用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据</li>
</ul>
<p><img src="/2022/01/03/day29/day29_10.png" alt="实际例子"></p>
<h4 id="为什么要使用元空间代替方法区"><a href="#为什么要使用元空间代替方法区" class="headerlink" title="为什么要使用元空间代替方法区"></a>为什么要使用元空间代替方法区</h4><ul>
<li><strong>出现溢出的可能性更小</strong>：整个永久代有一个 JVM 本身设置的固定大小上限，而元空间使用的是直接内存，受本机可用内存的限制，虽然元空间仍旧可能溢出，但是比原来出现的几率会更小</li>
<li>元空间里面存放的是类的元数据，由系统的实际可用空间来控制，这样能加载的类就更多了</li>
</ul>
<h4 id="JVM-常量池中存储的是对象还是引用呢"><a href="#JVM-常量池中存储的是对象还是引用呢" class="headerlink" title="JVM 常量池中存储的是对象还是引用呢?"></a>JVM 常量池中存储的是对象还是引用呢?</h4><ul>
<li><p><strong>JDK1.7之前</strong>运⾏时常量池包含：字符串常量池存放在⽅法区, 此时hotspot虚拟机对⽅法区的实现为永久代</p>
</li>
<li><p><strong>JDK1.7</strong>把字符串常量池拿出来放在了堆中，但是其他的仍在方法区（永久代）</p>
</li>
<li><p><strong>JDK8之后</strong>，字符串常量池被放在堆空间，包含了字符串对象和字符串常量值， hotspot移除了永久代⽤元空间(Metaspace)取⽽代之，元空间的常量池寻访的是引用</p>
</li>
</ul>
<h4 id="对象分配过程"><a href="#对象分配过程" class="headerlink" title="对象分配过程"></a>对象分配过程</h4><ul>
<li>首先创建对象。放在Eden区</li>
<li>Eden区放满后，再来对象会进行YGC/Minor GC，进行垃圾回收。非垃圾对象会进入Survivor0区，每个对象的年龄为1，Eden区清空。</li>
<li>重复前两个步骤，每次当Eden区放满，垃圾回收算法也会检测幸存者区的对象，并把非垃圾对象在S0和S1区中往返复制，并增加每个对象的年龄。S0和S1区总有一个区为空</li>
<li>当有对象的年龄达到阈值（默认为15）时，对象会从年轻代晋升到老年代</li>
</ul>
<blockquote>
<p>特殊情况：</p>
<ol>
<li>YGC后，需要创建的对象很大，Eden区无法放下，则直接放入老年代。如果老年代也放不下，先进行FGC/major GC对老年代进行垃圾回收；如果回收之后还放不下，报错OOM(不自动调整的情况)</li>
<li>YGC时，如果Eden区的对象S0或S1区放不下，则对象直接晋升老年代</li>
<li>如果幸存者区中相同年龄的对象大小的总和大于幸存者空间的一半，年龄大于等于该年龄的对象直接进入老年代</li>
<li>Hotspot 遍历所有对象时，按照年龄从小到大对其所占用的大小进行累积，当累积的某个年龄大小超过了 survivor 区的一半时，会将该年龄和晋升阈值作比较，选择较小的为新的晋升年龄</li>
</ol>
</blockquote>
<h4 id="对象的创建过程"><a href="#对象的创建过程" class="headerlink" title="对象的创建过程"></a>对象的创建过程</h4><ul>
<li><p><strong>类加载检查</strong>：虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程</p>
</li>
<li><p><strong>分配内存</strong>： <strong>“指针碰撞”</strong> 和 <strong>“空闲列表”</strong> 两种分配方式，选择哪种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定</p>
<ul>
<li>分配内存时，会存在并发问题，需要保证线程安全，采用两种方式<ul>
<li><strong>CAS+失败重试：</strong> CAS 是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。<strong>虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。</strong></li>
<li><strong>TLAB：</strong>线程私有， 为<strong>每一个线程</strong>预先在 Eden 区分配一块儿内存，JVM 在给线程中的对象分配内存时，首先在 TLAB 分配，当对象大于 TLAB 中的剩余内存或 TLAB 的内存已用尽时，再采用上述的 CAS 进行内存分配</li>
</ul>
</li>
</ul>
<p><img src="/2022/01/03/day29/day29_11.png" alt="分配内存"></p>
</li>
<li><p><strong>初始化零值</strong>：将对象的属性进行初始化</p>
</li>
<li><p><strong>设置对象头</strong>：将对象的所属类、HashCode和对象的GC信息、锁信息等数据存储在对象的对象头中</p>
</li>
<li><p><strong>执行init方法</strong>：父类静态代码块、父类静态变量初始化、子类静态代码块、子类静态变量初始化、父类变量初始化、父类代码块、父类构造函数、子类变量初始化、子类代码块、子类构造方法</p>
</li>
</ul>
<h4 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h4><ul>
<li>对象头：<ul>
<li>存储对象自身的运行时数据：希码、GC 分代年龄、锁状态标志等等</li>
<li>类型指针：对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例</li>
<li>如果是数组，还需要记录数组长度</li>
</ul>
</li>
<li>实例数据：存储对象有效信息，各字段的值<ul>
<li>规则：先放父类的字段；相同宽度字段放在一起；如果CompactFields设置为true(默认为true)，子类窄变量可能插入到父类变量的间隙</li>
</ul>
</li>
<li>对齐填充：占位作用，对象占用内存必须是8字节的整数倍</li>
</ul>
<h4 id="常量池问题"><a href="#常量池问题" class="headerlink" title="常量池问题"></a>常量池问题</h4><ul>
<li><p>字符串常量池，在编译期就可以确定的字符串，就直接是常量池的对象。否则会在堆上新建对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">String str1 = <span class="string">&quot;str&quot;</span>;</span><br><span class="line">String str2 = <span class="string">&quot;ing&quot;</span>;</span><br><span class="line">String str3 = <span class="string">&quot;str&quot;</span> + <span class="string">&quot;ing&quot;</span>;<span class="comment">//常量池中的对象</span></span><br><span class="line">String str4 = str1 + str2; <span class="comment">//在堆上创建的新的对象</span></span><br><span class="line">String str5 = <span class="string">&quot;string&quot;</span>;<span class="comment">//常量池中的对象</span></span><br><span class="line">System.out.println(str3 == str4);<span class="comment">//false</span></span><br><span class="line">System.out.println(str3 == str5);<span class="comment">//true</span></span><br><span class="line">System.out.println(str4 == str5);<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用final关键字会有变化</span></span><br><span class="line"><span class="keyword">final</span> String str1 = <span class="string">&quot;str&quot;</span>;</span><br><span class="line"><span class="keyword">final</span> String str2 = <span class="string">&quot;ing&quot;</span>;</span><br><span class="line">String c = <span class="string">&quot;str&quot;</span> + <span class="string">&quot;ing&quot;</span>;<span class="comment">// 常量池中的对象</span></span><br><span class="line">String d = str1 + str2; <span class="comment">// 常量池中的对象</span></span><br><span class="line">System.out.println(c == d);<span class="comment">// true</span></span><br></pre></td></tr></table></figure></li>
<li><p>包装类常量池，浮点类没有常量池，自动拆箱装箱</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Integer i1 = <span class="number">40</span>;</span><br><span class="line">Integer i2 = <span class="number">40</span>;</span><br><span class="line">Integer i3 = <span class="number">0</span>;</span><br><span class="line">Integer i4 = <span class="keyword">new</span> Integer(<span class="number">40</span>);</span><br><span class="line">Integer i5 = <span class="keyword">new</span> Integer(<span class="number">40</span>);</span><br><span class="line">Integer i6 = <span class="keyword">new</span> Integer(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(i1 == i2);<span class="comment">// true</span></span><br><span class="line">System.out.println(i1 == i2 + i3);<span class="comment">//true</span></span><br><span class="line">System.out.println(i1 == i4);<span class="comment">// false</span></span><br><span class="line">System.out.println(i4 == i5);<span class="comment">// false</span></span><br><span class="line">System.out.println(i4 == i5 + i6);<span class="comment">// true</span></span><br><span class="line">System.out.println(<span class="number">40</span> == i5 + i6);<span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>i1</code> , <code>i2</code> , <code>i3</code> 都是常量池中的对象，<code>i4</code> , <code>i5</code> , <code>i6</code> 是堆中的对象。</p>
<p><code>i4 == i5 + i6</code> 为什么是 true 呢？因为， <code>i5</code> 和 <code>i6</code> 会进行自动拆箱操作，进行数值相加，即 <code>i4 == 40</code> 。 <code>Integer</code> 对象无法与数值进行直接比较，所以 <code>i4</code> 自动拆箱转为 int 值 40，最终这条语句转为 <code>40 == 40</code> 进行数值比较</p>
</li>
</ul>
<blockquote>
<p>对于String对象:</p>
<ol>
<li>使用new关键字创建的字符串对象存储在堆的普通内存部分</li>
<li>不使用new 关键字创建的字符串对象存储在堆的字符串常量池部分</li>
</ol>
</blockquote>
</li>
</ul>
<h3 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h3><h4 id="空间担保"><a href="#空间担保" class="headerlink" title="空间担保"></a>空间担保</h4><ul>
<li><p>保证在Minor GC之前，老年代本身还有空间容纳新生代</p>
</li>
<li><p>JDK 6 Update 24 之前，在发生 Minor GC 之前，虚拟机必须先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那这一次 Minor GC 可以确保是安全的。如果不成立，则虚拟机会先查看 <code>-XX:HandlePromotionFailure</code> 参数的设置值是否允许担保失败(Handle Promotion Failure);如果允许，那会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试进行一次 Minor GC，尽管这次 Minor GC 是有风险的;如果小于，或者 <code>-XX: HandlePromotionFailure</code> 设置不允许冒险，那这时就要改为进行一次 Full GC。</p>
</li>
<li><p>JDK 6 Update 24 之后的规则变为只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小，就会进行 Minor GC，否则将进行 Full GC</p>
</li>
</ul>
<h4 id="判断对象死亡？"><a href="#判断对象死亡？" class="headerlink" title="判断对象死亡？"></a>判断对象死亡？</h4><ul>
<li><strong>引用计数法</strong>：给对象中添加一个引用计数器，每当有一个地方引用它，计数器就加 1；当引用失效，计数器就减 1；任何时候计数器为 0 的对象就是不可能再被使用的<ul>
<li>主流虚拟机不使用，因为无法解决循环引用问题，两个对象互相引用的情形</li>
</ul>
</li>
<li><strong>可达性分析算法</strong>：以 <strong>“GC Roots”</strong> 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的，需要被回收<ul>
<li>可作为GC Roots的对象：<ul>
<li>虚拟机栈(栈帧中的本地变量表)中引用的对象</li>
<li>本地方法栈(Native 方法)中引用的对象</li>
<li>方法区中类静态属性引用的对象</li>
<li>方法区中常量引用的对象</li>
<li>所有被同步锁持有的对象</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>对象可以被回收，就代表一定会被回收吗？</strong></p>
<p>即使在可达性分析法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑阶段”，要真正宣告一个对象死亡，至少要经历两次标记过程；可达性分析法中不可达的对象被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行 <code>finalize</code> 方法。当对象没有覆盖 <code>finalize</code> 方法，或 <code>finalize</code> 方法已经被虚拟机调用过时，虚拟机将这两种情况视为没有必要执行。</p>
<p>被判定为需要执行的对象将会被放在一个队列中进行第二次标记，除非这个对象与引用链上的任何一个对象建立关联，否则就会被真的回收。</p>
</blockquote>
<h4 id="引用分类"><a href="#引用分类" class="headerlink" title="引用分类"></a>引用分类</h4><ul>
<li><strong>强引用</strong>：代码中普遍存在的引用赋值，只要强引用存在，垃圾回收就<strong>永远不会</strong>回收该对象</li>
<li><strong>软引用</strong>：系统将要发生内存溢出之前，这些对象会被列入回收范围。垃圾回收之后内存还不足，才会报OOM，可以和一个引用队列（ReferenceQueue）联合使用</li>
<li><strong>弱引用</strong>：被GC发现就会被回收，不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象，可以和一个引用队列（ReferenceQueue）联合使用</li>
<li><strong>虚引用</strong>：设置虚引用的唯一目的是为了对象在被回收时收到系统通知，在任何时候都有可能被回收，<strong>必须</strong>和引用队列（ReferenceQueue）联合使用</li>
</ul>
<blockquote>
<p>特别注意，在程序设计中一般很少使用弱引用与虚引用，使用软引用的情况较多，这是因为<strong>软引用可以加速 JVM 对垃圾内存的回收速度，可以维护系统的运行安全，防止内存溢出（OutOfMemory）等问题的产生</strong></p>
</blockquote>
<h4 id="如何判断一个常量是废弃的？或者一个类是无用的类？"><a href="#如何判断一个常量是废弃的？或者一个类是无用的类？" class="headerlink" title="如何判断一个常量是废弃的？或者一个类是无用的类？"></a>如何判断一个常量是废弃的？或者一个类是无用的类？</h4><ul>
<li>假如在字符串常量池中存在字符串 “abc”，如果当前没有任何 String 对象引用该字符串常量的话，就说明常量 “abc” 就是废弃常量，如果这时发生内存回收的话而且有必要的话，”abc” 就会被系统清理出常量池了</li>
<li>同时满足3 个条件才能算是 <strong>“无用的类”</strong> ：<ul>
<li>该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。</li>
<li>加载该类的 <code>ClassLoader</code> 已经被回收。</li>
<li>该类对应的 <code>java.lang.Class</code> 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li>
</ul>
</li>
</ul>
<h4 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h4><ul>
<li><p><strong>标记-清除算法</strong>：首先标记出所有不需要回收的对象，在标记完成后统一回收掉所有没有被标记的对象</p>
<ul>
<li><p>清除并不是真的清空，而是把需要清除的对象内存地址保存在地址列表中，有对象需要分配内存时，再进行判断</p>
</li>
<li><p>效率低；会产生不连续内存空间，产生内存碎片</p>
</li>
</ul>
</li>
<li><p><strong>标记-复制算法</strong>：将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。这样就使每次的内存回收都是对内存区间的一半进行回收</p>
<ul>
<li>需要两倍的内存空间；GC需要维护region之间对象引用关系，时间和内存消耗</li>
<li>适用场景：存活的对象不多，大部分都是垃圾，因此适用于新生代</li>
</ul>
<p><img src="/2022/01/03/day29/day29_12.png" alt="复制算法"></p>
</li>
</ul>
<ul>
<li><p><strong>标记-整理（压缩）算法</strong>：标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存</p>
<ul>
<li>优点：在标记清除算法的基础上加了碎片整理；没有额外空间</li>
<li>缺点：效率低于复制算法；需要调整引用地址；有STW</li>
<li>适用于老年代</li>
</ul>
<p><img src="/2022/01/03/day29/day29_13.png" alt="标记-整理算法 "></p>
</li>
</ul>
<h4 id="HotSpot-为什么要分为新生代和老年代？"><a href="#HotSpot-为什么要分为新生代和老年代？" class="headerlink" title="HotSpot 为什么要分为新生代和老年代？"></a>HotSpot 为什么要分为新生代和老年代？</h4><ul>
<li><p>当前虚拟机的垃圾收集都采用分代收集算法，根据对象存活周期的不同将内存分为几块。一般将 java 堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。</p>
</li>
<li><p>比如在新生代中，每次收集都会有大量对象死去，所以可以选择<strong>”标记-复制“算法</strong>，只需要付出少量对象的复制成本就可以完成每次垃圾收集。而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择<strong>“标记-清除”或“标记-整理”算法</strong>进行垃圾收集。</p>
</li>
</ul>
<h4 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h4><ul>
<li><strong>Serial收集器</strong>：用一条垃圾收集线程去完成垃圾收集工作，在进行垃圾收集工作的时候必须暂停其他所有的工作线程（ <strong>“Stop The World”</strong> ），直到它收集结束<ul>
<li><strong>新生代采用标记-复制算法，老年代采用标记-整理算法</strong></li>
<li>STW时间较长；没有线程切换开销；适合运行再client模式下的虚拟机</li>
</ul>
</li>
<li><strong>Serial Old 收集器</strong>：<strong>Serial 收集器的老年代版本</strong>，它同样是一个单线程收集器。它主要有两大用途：一种用途是在 JDK1.5 以及以前的版本中与 Parallel Scavenge 收集器搭配使用，另一种用途是作为 CMS 收集器的后备方案</li>
<li><strong>ParNew 收集器</strong>：Serial 收集器的多线程版本，除了使用多线程进行垃圾收集外，其余行为（控制参数、收集算法、回收策略等等）和 Serial 收集器完全一样<ul>
<li><strong>新生代采用标记-复制算法，老年代采用标记-整理算法</strong></li>
<li>适用运行再server模式下的虚拟机</li>
</ul>
</li>
<li><strong>Parallel Scavenge 收集器</strong>：几乎和 ParNew 都一样，<strong>关注点是吞吐量（高效率的利用 CPU），所谓吞吐量就是 CPU 中用于运行用户代码的时间与 CPU 总消耗时间的比值。</strong>Parallel Scavenge 收集器提供了很多参数供用户找到最合适的停顿时间或最大吞吐量<ul>
<li><strong>新生代采用标记-复制算法，老年代采用标记-整理算法</strong></li>
<li>JDK8默认收集器</li>
</ul>
</li>
<li><strong>Parallel Old 收集器</strong>：<strong>Parallel Scavenge 收集器的老年代版本</strong>。使用多线程和“标记-整理”算法。在注重吞吐量以及 CPU 资源的场合，都可以优先考虑 Parallel Scavenge 收集器和 Parallel Old 收集器</li>
<li><strong>CMS收集器</strong>：注重用户体验，获取最短的STW时间，基于<strong>标记-清除算法实现</strong>，主要分为四个步骤：<ul>
<li><strong>初始标记：</strong> 暂停所有的其他线程，并记录下直接与 root 相连的对象，速度很快 ；</li>
<li><strong>并发标记：</strong> 同时开启 GC 和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以 GC 线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。</li>
<li><strong>重新标记：</strong> 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短</li>
<li><strong>并发清除：</strong> 开启用户线程，同时 GC 线程开始对未标记的区域做清扫</li>
<li>缺点：对CPU资源敏感；无法处理浮动垃圾；会有空间碎片产生</li>
<li>不采用<strong>标记-压缩</strong>算法是因为CMS在工作时，用户线程也在工作，整理内存可能会使用户线程无法正常工作</li>
</ul>
</li>
<li><strong>G1收集器</strong>：面向服务器的垃圾收集器，主要针对配备多颗处理器及大容量内存的机器。以极高概率满足 GC 停顿时间要求的同时，还具备高吞吐量性能特征<ul>
<li>将堆内存分割成很多个不相关的区域，使用不同的Region表示Eden、幸存者0区、幸存者1区等。G1有计划地避免在整个Java堆中进行垃圾回收，G1跟踪每个Region里面的垃圾堆积价值大小，在后台维护优先列表，根据允许的收集时间，每次优先回收价值最大的Region</li>
<li>并行与并发<ul>
<li>并行性：多个GC线程同时工作，此时用户线程STW</li>
<li>并发性：G1拥有与应用程序交替执行的能力，部分工作和应用程序同时执行</li>
</ul>
</li>
<li>分代收集<ul>
<li>会区分年轻代和老年代，但是不要求他们物理地址连续，也不再坚持固定大小固定数量</li>
<li>同时兼顾年轻代和老年代</li>
</ul>
</li>
<li>空间整合<ul>
<li>G1内存的回收是以region为单位的，Region之间是复制算法，整体上可以看作标记-压缩算法，可以解决碎片化问题</li>
</ul>
</li>
<li>可预测的停顿：<ul>
<li>可以指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不超过N毫秒</li>
<li>G1选择部分区域进行回收，因此全局停顿的发生得到了控制</li>
<li>优先收集价值最大的Region</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="/2022/01/03/day29/day29_14.png" alt="对比"></p>
<h3 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h3><h4 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h4><ul>
<li>加载：<ul>
<li>通过全类名获取定义此类的二进制字节流</li>
<li>将字节流所代表的静态存储结构转换为方法区的运行时数据结构</li>
<li>在内存中生成一个代表该类的 <code>Class</code> 对象，作为方法区这些数据的访问入口</li>
</ul>
</li>
<li>验证：<ul>
<li>文件格式验证：字节流是否符合Class文件格式的规范</li>
<li>元数据验证：对字节码描述的信息进行语义分析，是否符合java语言规范。例如：是否继承了不能被继承的类</li>
<li>字节码验证：确定程序语义是否合法、是否符合逻辑</li>
<li>符号引用验证：确保解析能正确运行</li>
</ul>
</li>
<li>准备：为类变量分配内存并设置类变量初始值，这些内存都将在方法区中分配<ul>
<li>只对类变量进行初始化</li>
<li>JDK8之后，将字符串常量池、静态变量移到堆中，因此类变量也放在了堆中</li>
<li>在准备阶段就可以确定的值，不需要赋为初始值</li>
</ul>
</li>
<li>解析：虚拟机将常量池内的符号引用替换为直接引用，主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用限定符 7 类符号引用进行</li>
<li>初始化：初始化阶段是执行初始化方法 <code>&lt;clinit&gt; ()</code>方法的过程，是类加载的最后一步，这一步 JVM 才开始真正执行类中定义的 Java 程序代码(字节码)。<ul>
<li>如果没有静态变量和静态代码块，就不会存在clinit方法</li>
<li>若该类有父类，JVM会保证父类的<code>&lt;clinit&gt;</code>先执行完成</li>
<li><code>&lt;clinit&gt;</code>保证在多线程下同步，一个类保证只被加载一次</li>
</ul>
</li>
</ul>
<h4 id="类加载器分类"><a href="#类加载器分类" class="headerlink" title="类加载器分类"></a>类加载器分类</h4><ul>
<li><p><strong>BootstrapClassLoader(启动类加载器)</strong> ：最顶层的加载类，由 C++实现，负责加载 <code>%JAVA_HOME%/lib</code>目录下的 jar 包和类或者被 <code>-Xbootclasspath</code>参数指定的路径中的所有类。</p>
</li>
<li><p><strong>ExtensionClassLoader(扩展类加载器)</strong> ：主要负责加载 <code>%JRE_HOME%/lib/ext</code> 目录下的 jar 包和类，或被 <code>java.ext.dirs</code> 系统变量所指定的路径下的 jar 包。</p>
</li>
<li><p><strong>AppClassLoader(应用程序类加载器)</strong> ：面向我们用户的加载器，负责加载当前应用 classpath 下的所有 jar 包和类</p>
</li>
<li><p><strong>用户自定义类加载器</strong>：需要继承java.lang.ClassLoader类，重写findClass()方法</p>
</li>
</ul>
<h4 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h4><ul>
<li><p>加载的时候，首先会把该请求委派给父类加载器的 <code>loadClass()</code> 处理，因此所有的请求最终都应该传送到顶层的启动类加载器 <code>BootstrapClassLoader</code> 中。当父类加载器无法处理时，才由自己来处理。当父类加载器为 null 时，会使用启动类加载器 <code>BootstrapClassLoader</code> 作为父类加载器。</p>
<p><img src="/2022/01/03/day29/day29_15.png" alt="双亲委派机制"></p>
</li>
<li><p>好处：保证了 Java 程序的稳定运行，可以避免类的重复加载（JVM 区分不同类的方式不仅仅根据类名，相同的类文件被不同的类加载器加载产生的是两个不同的类），也保证了 Java 的核心 API 不被篡改。如果没有使用双亲委派模型，而是每个类加载器加载自己的话就会出现一些问题，比如我们编写一个称为 <code>java.lang.Object</code> 类的话，那么程序运行的时候，系统就会出现多个不同的 <code>Object</code> 类</p>
</li>
<li><p><strong>打破双亲委派机制</strong>：</p>
<ul>
<li><strong>不进行委派</strong>：自定义加载类，不重写<code>findClass()</code>方法，重写<code>loadClass()</code>方法</li>
<li><strong>向下委派</strong>：通过spi机制，使用SeviceLoader.load加载，需要有配置文件</li>
</ul>
</li>
</ul>
<h2 id="Java8新特性"><a href="#Java8新特性" class="headerlink" title="Java8新特性"></a>Java8新特性</h2><h3 id="Interface"><a href="#Interface" class="headerlink" title="Interface"></a>Interface</h3><ul>
<li>新 interface 的方法可以用<code>default</code> 或 <code>static</code>修饰，这样就可以有方法体，实现类也不必重写此方法<ul>
<li><code>default</code>修饰的方法，是普通实例方法，可以用<code>this</code>调用，可以被子类继承、重写</li>
<li><code>static</code>修饰的方法，使用上和一般类静态方法一样。但它不能被子类继承，只能用<code>Interface</code>调用</li>
</ul>
</li>
<li>Function-Interface(函数式接口)，支持Lamba表达式</li>
</ul>
<h3 id="Stream流"><a href="#Stream流" class="headerlink" title="Stream流"></a>Stream流</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  List&lt;String&gt; strings = Arrays.asList(<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;def&quot;</span>, <span class="string">&quot;gkh&quot;</span>, <span class="string">&quot;abc&quot;</span>);</span><br><span class="line">    <span class="comment">//返回符合条件的stream</span></span><br><span class="line">    Stream&lt;String&gt; stringStream = strings.stream().filter(s -&gt; <span class="string">&quot;abc&quot;</span>.equals(s));</span><br><span class="line">    <span class="comment">//计算流符合条件的流的数量</span></span><br><span class="line">    <span class="keyword">long</span> count = stringStream.count();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//forEach遍历-&gt;打印元素</span></span><br><span class="line">    strings.stream().forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//limit 获取到1个元素的stream</span></span><br><span class="line">    Stream&lt;String&gt; limit = strings.stream().limit(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//toArray 比如我们想看这个limitStream里面是什么，比如转换成String[],比如循环</span></span><br><span class="line">    String[] array = limit.toArray(String[]::<span class="keyword">new</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//map 对每个元素进行操作返回新流</span></span><br><span class="line">    Stream&lt;String&gt; map = strings.stream().map(s -&gt; s + <span class="string">&quot;22&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//sorted 排序并打印</span></span><br><span class="line">    strings.stream().sorted().forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Collectors collect 把abc放入容器中</span></span><br><span class="line">    List&lt;String&gt; collect = strings.stream().filter(string -&gt; <span class="string">&quot;abc&quot;</span>.equals(string)).collect(Collectors.toList());</span><br><span class="line">    <span class="comment">//把list转为string，各元素用，号隔开</span></span><br><span class="line">    String mergedString = strings.stream().filter(string -&gt; !string.isEmpty()).collect(Collectors.joining(<span class="string">&quot;,&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对数组的统计，比如用</span></span><br><span class="line">    List&lt;Integer&gt; number = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    IntSummaryStatistics statistics = number.stream().mapToInt((x) -&gt; x).summaryStatistics();</span><br><span class="line">    System.out.println(<span class="string">&quot;列表中最大的数 : &quot;</span>+statistics.getMax());</span><br><span class="line">    System.out.println(<span class="string">&quot;列表中最小的数 : &quot;</span>+statistics.getMin());</span><br><span class="line">    System.out.println(<span class="string">&quot;平均数 : &quot;</span>+statistics.getAverage());</span><br><span class="line">    System.out.println(<span class="string">&quot;所有数之和 : &quot;</span>+statistics.getSum());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//concat 合并流</span></span><br><span class="line">    List&lt;String&gt; strings2 = Arrays.asList(<span class="string">&quot;xyz&quot;</span>, <span class="string">&quot;jqx&quot;</span>);</span><br><span class="line">    Stream.concat(strings2.stream(),strings.stream()).count();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注意 一个Stream只能操作一次，不能断开，否则会报错。</span></span><br><span class="line">    Stream stream = strings.stream();</span><br><span class="line">    <span class="comment">//第一次使用</span></span><br><span class="line">    stream.limit(<span class="number">2</span>);</span><br><span class="line">    <span class="comment">//第二次使用</span></span><br><span class="line">    stream.forEach(System.out::println);</span><br><span class="line">    <span class="comment">//报错 java.lang.IllegalStateException: stream has already been operated upon or closed</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//但是可以这样, 连续使用</span></span><br><span class="line">    stream.limit(<span class="number">2</span>).forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h1 id="数据库-amp-中间件"><a href="#数据库-amp-中间件" class="headerlink" title="数据库 &amp; 中间件"></a>数据库 &amp; 中间件</h1><h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><h3 id="基础-1"><a href="#基础-1" class="headerlink" title="基础"></a>基础</h3><h4 id="三大范式"><a href="#三大范式" class="headerlink" title="三大范式"></a>三大范式</h4><ul>
<li>1NF：数据库每个字段都不能再分为多个字段（最基本要求），例如<strong>班级字段可分为专业和班号</strong>，<strong>解决方法拆字段</strong></li>
<li>2NF：满足1NF的情况下，在<strong>存在主键时，不能有部分依赖</strong>。(主要<strong>针对复合主键</strong>的)。例如订单号和商品号作为复合主键，商品信息只依赖商品号，<strong>解决方法是拆表</strong></li>
<li>3NF：满足1NF,2NF，确保数据库每个字段都和主键直接相关，而不是间接相关，例如学号为主键，课程号和学号并不是直接相关，<strong>解决方法是拆表</strong></li>
</ul>
<h4 id="drop、delete、和truncate区别？"><a href="#drop、delete、和truncate区别？" class="headerlink" title="drop、delete、和truncate区别？"></a>drop、delete、和truncate区别？</h4><ul>
<li><strong>用法不同</strong><ul>
<li>drop：删除整个表，包括表结构</li>
<li>truncate：清空整个表，保留表结构</li>
<li>delete：删除表中的某一列数据，不加条件，清空整个表，保留表结构</li>
</ul>
</li>
<li><strong>属于不同的数据库语言</strong><ul>
<li>truncate和drop属于DDL语言，原数据不会放入rollback segment中，无法回滚</li>
<li>delete是DML语言，会将原数据放入rollback segment中，可以回滚</li>
</ul>
</li>
</ul>
<blockquote>
<p><code>delete</code>命令执行的时候会产生数据库的<code>binlog</code>日志，而日志记录是需要消耗时间的，但是也有个好处方便数据回滚恢复。</p>
<p><code>truncate</code>命令执行的时候不会产生数据库日志，因此比<code>delete</code>要快。除此之外，还会把表的自增值重置和索引恢复到初始大小等。</p>
<p><code>drop</code>命令会把表占用的空间全部释放掉。</p>
</blockquote>
<h4 id="设计数据集步骤"><a href="#设计数据集步骤" class="headerlink" title="设计数据集步骤"></a>设计数据集步骤</h4><ul>
<li><strong>需求分析</strong> : 分析用户的需求，包括数据、功能和性能需求。</li>
<li><strong>概念结构设计</strong> : 主要采用 E-R 模型进行设计，包括画 E-R 图。</li>
<li><strong>逻辑结构设计</strong> : 通过将 E-R 图转换成表，实现从 E-R 模型到关系模型的转换。</li>
<li><strong>物理结构设计</strong> : 主要是为所设计的数据库选择合适的存储结构和存取路径。</li>
<li><strong>数据库实施</strong> : 包括编程、测试和试运行</li>
<li><strong>数据库的运行和维护</strong> : 系统的运行与数据库的日常维护</li>
</ul>
<h4 id="MyISAM和InnoDB区别"><a href="#MyISAM和InnoDB区别" class="headerlink" title="MyISAM和InnoDB区别"></a>MyISAM和InnoDB区别</h4><ul>
<li><strong>锁</strong>：MyISAM只有表级锁；InnoDB支持表级锁和行级锁</li>
<li><strong>事务</strong>：MyISAM不支持事务；InnoDB支持事务，可以提交和回滚</li>
<li><strong>外键</strong>：MyISAM不支持外键；InnoDB支持外键</li>
<li><strong>安全恢复</strong>：MyISAM不支持异常崩溃后的安全回复；InnoDB支持，恢复的过程依赖于 <code>redo log</code></li>
<li><strong>索引结构</strong>：MyISAM索引使用B+树，叶子节点存放的是数据记录的地址，索引文件和数据文件是分开的；InnoDB索引使用B+树，叶子节点存放的是完整的数据记录，非聚簇索引存放的是主键的值</li>
</ul>
<h4 id="事务ACID特性"><a href="#事务ACID特性" class="headerlink" title="事务ACID特性"></a>事务ACID特性</h4><ul>
<li><p><strong>原子性</strong>（<code>Atomicity</code>） ： 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用</p>
</li>
<li><p><strong>一致性</strong>（<code>Consistency</code>）： 执行事务前后，数据保持一致，例如转账业务中，无论事务是否成功，转账者和收款人的总额应该是不变的</p>
</li>
<li><p><strong>隔离性</strong>（<code>Isolation</code>）： 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的</p>
</li>
<li><p><strong>持久性</strong>（<code>Durability</code>）： 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响</p>
<blockquote>
<p>实现原理：</p>
<p>MySQL InnoDB 引擎使用 <strong>redo log(重做日志)</strong> 保证事务的<strong>持久性</strong>，使用 <strong>undo log(回滚日志)</strong> 来保证事务的<strong>原子性</strong>。</p>
<p>MySQL InnoDB 引擎通过 <strong>锁机制</strong>、<strong>MVCC</strong> 等手段来保证事务的隔离性（ 默认支持的隔离级别是 <strong><code>REPEATABLE-READ</code></strong> ）。</p>
<p>保证了事务的持久性、原子性、隔离性之后，一致性才能得到保障。</p>
</blockquote>
</li>
</ul>
<h4 id="并发事务带来的问题"><a href="#并发事务带来的问题" class="headerlink" title="并发事务带来的问题"></a>并发事务带来的问题</h4><ul>
<li><strong>脏读</strong>：一个事务读取了另一个事务未提交的数据<ul>
<li>添加写锁</li>
</ul>
</li>
<li><strong>丢失修改</strong>：两个事务同时操作同一个数据，同时读取了数据，修改之后提交，可能有一个事务的修改操作没有生效</li>
<li><strong>不可重复读</strong>：在同一个事务内，多次读取同一个数据，由于其他事务对数据的修改，多次读取的数据不同<ul>
<li>给查询范围内的数据加读锁并且读取之后不会马上释放</li>
<li>其他事务无法施加写锁，无法修改数据；但是可以插入数据，导致幻读</li>
</ul>
</li>
<li><strong>幻读</strong>：在同一个事务内，查询同一个表中的数据，由于其他事务添加或删除数据，发现多次查询总的数据量不同<ul>
<li>间隙锁加行锁</li>
</ul>
</li>
</ul>
<h4 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h4><ul>
<li><p><strong>READ-UNCOMMITTED(读取未提交)：</strong> 最低的隔离级别，允许读取尚未提交的数据变更</p>
</li>
<li><p><strong>READ-COMMITTED(读取已提交)：</strong> 允许读取并发事务已经提交的数据</p>
</li>
<li><p><strong>REPEATABLE-READ(可重复读)：</strong> 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，<strong>MySQL默认隔离级别</strong></p>
</li>
<li><p><strong>SERIALIZABLE(可串行化)：</strong> 最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行</p>
<p><img src="/2022/01/03/day29/day29_19.png" alt="事务隔离"></p>
</li>
</ul>
<h4 id="join的使用和原理"><a href="#join的使用和原理" class="headerlink" title="join的使用和原理"></a>join的使用和原理</h4><ul>
<li><p><code>left join</code>：保留左表的数据，左表没有的数据设置为null，外连接</p>
</li>
<li><p><code>right join</code>：保留右表的数据，右表没有的数据设置为null，外连接</p>
</li>
<li><p><code>join(inner join)</code>：取左右表数据的交集，内连接</p>
</li>
<li><p>原理：嵌套循环（Nested-Loop Join），需要区分驱动表和被驱动表，先访问驱动表，筛选出结果集</p>
<ul>
<li><p>SNLJ（Simple Nested-Loop Join）：简单嵌套循环，将驱动表中的数据一行一行读取出来进行匹配，每行数据都会出发被驱动表的整表扫描，对比数据，将结果加入结果集，不需要回表</p>
<p><img src="/2022/01/03/day29/day29_25.png" alt="SNLJ"></p>
</li>
<li><p>INLJ（Index Nested-Loop join）：索引嵌套循环。和SNLJ类似，最大的区别是用来join的字段在被驱动表中建立了索引，<strong>如果是非聚簇索引需要进行回表，聚簇索引不需要回表</strong></p>
<ul>
<li>SNLJ算法被驱动表需要每次全表查询，INLJ算法使用索引查询，性能提高</li>
</ul>
</li>
<li><p>BNLJ（Block Nested-Loop Join）：块嵌套循环，没有索引的情况下一种优化，降低被驱动表的扫描次数，使用join buffer缓冲区</p>
<ul>
<li>join bufffer缓存join所需的字段，在与被驱动表进行对比时，将buffer中的所有字段和被驱动表一起对比，如果buffer足够大，只需要对被驱动表查询一次</li>
</ul>
<p><img src="/2022/01/03/day29/day29_26.png" alt="BNLJ"></p>
</li>
</ul>
</li>
</ul>
<h4 id="SQL语句执行流程"><a href="#SQL语句执行流程" class="headerlink" title="SQL语句执行流程"></a>SQL语句执行流程</h4><p><img src="/2022/01/03/day29/day29_29.png" alt="执行流程"></p>
<h4 id="datetime和timestamp区别"><a href="#datetime和timestamp区别" class="headerlink" title="datetime和timestamp区别"></a>datetime和timestamp区别</h4><ul>
<li>共同点：存储精度都精确到秒</li>
<li>区别：<ul>
<li>datetime日期范围1001——9999年，timestamp范围为1970——2038年</li>
<li>datetime存储时间与时区无关，timestamp和时区相关</li>
<li>datetime占8个字节，timestamp占4字节</li>
<li>datetime默认值为null,timestamp默认为当前时间</li>
</ul>
</li>
</ul>
<h4 id="varchar和char区别"><a href="#varchar和char区别" class="headerlink" title="varchar和char区别"></a>varchar和char区别</h4><ul>
<li>char定长，varchar是变长的，用一个字符表示占用长度</li>
<li>检索效率char&gt;varchar，如果确认某个字段的值，使用char，例如MD5加密后的密码</li>
</ul>
<h4 id="in和exists区别"><a href="#in和exists区别" class="headerlink" title="in和exists区别"></a>in和exists区别</h4><ul>
<li>in先执行子查询，后执行主查询，exists相反。通常<strong>in+小表，exists+大表</strong>，遵循小表驱动大表原则，减少数据库连接次数</li>
</ul>
<h3 id="高性能优化"><a href="#高性能优化" class="headerlink" title="高性能优化"></a>高性能优化</h3><h4 id="字段设计规范"><a href="#字段设计规范" class="headerlink" title="字段设计规范"></a>字段设计规范</h4><ul>
<li><p><strong>优先选择符合存储需要的最小数据类型</strong>：建立索引的空间越小，一页中能够存储的索引节点数量也就越多，遍历时的IO次数就越少</p>
<ul>
<li><strong>将字符串转换成数字类型存储,如:将 IP 地址转换成整形数据</strong></li>
</ul>
</li>
<li><p><strong>避免使用 TEXT,BLOB 数据类型</strong>：可以将BLOB或是TEXT列分离到单独的扩展表中，查询时只取出必要的列</p>
<ul>
<li>大数据类型不能适用内存临时表，必须使用磁盘临时表，MySQL要进行二次查询，很慢</li>
</ul>
</li>
<li><p><strong>避免使用ENUM类型</strong>：修改ENUM值需要使用ALTER语句，排序效率很低</p>
</li>
<li><p><strong>尽可能把所有列定义为NOT NULL</strong>：索引NULL列需要额外的空间，会占用更多的空间，进行计算和比较时，也需要特殊处理</p>
</li>
<li><p><strong>使用TIMESTAMP（4字节）或DATETIME（8字节）存储时间</strong>：不要使用字符串存储日期</p>
</li>
<li><p><strong>财务类相关金额数据必须使用decimal类型</strong>：精准浮点数</p>
</li>
</ul>
<h4 id="索引设计规范"><a href="#索引设计规范" class="headerlink" title="索引设计规范"></a>索引设计规范</h4><ul>
<li><strong>建议单张表的索引不超过5个</strong>：索引在增加查询效率的同时，也会降低插入和更新的效率。MySQL在进行查询操作时，会对每一个可以使用的索引进行评估，选择最优的索引进行查询，索引太多会导致计划的时间变长，降低效率</li>
<li><strong>每个Innodb都必须有主键</strong>：Innodb按照主键索引的顺序来组织表<ul>
<li>不使用更新频繁的列作为主键</li>
<li>不要使用UUID,MD5,HASH字符串作为主键，无法保证数据的顺序增长</li>
<li>主键建议使用自增ID值</li>
</ul>
</li>
<li><strong>设置为索引的列</strong>：<ul>
<li>出现在WHERE从句中的列</li>
<li>包含在ORDER BY、GROUP BY、DISTINCT中的字段</li>
<li>不要对符合前两个条件的每个列都建立索引，建立联合索引效果更好</li>
<li>多表join的关联列</li>
</ul>
</li>
<li><strong>索引列的顺序</strong>：<ul>
<li>区分度最高的放在联合索引的最左侧</li>
<li>字段小的索引放在联合索引的最左侧</li>
<li>使用最频繁的列放在联合索引的最左侧</li>
</ul>
</li>
<li><strong>对于频繁的查询优先考虑使用覆盖索引</strong>：<ul>
<li><strong>避免 Innodb 表进行索引的二次查询:</strong> 对于 Innodb 来说，二级索引在叶子节点中所保存的是行的主键信息，如果是用二级索引查询数据的话，在查找到相应的键值后，还要通过主键进行二次查询才能获取我们真实所需要的数据。而在覆盖索引中，二级索引的键值中可以获取所有的数据，避免了对主键的二次查询 ，减少了 IO 操作，提升了查询效率。</li>
<li><strong>可以把随机 IO 变成顺序 IO 加快查询效率:</strong> 由于覆盖索引是按键值的顺序存储的，对于 IO 密集型的范围查找来说，顺序获取比随机获取每一行的数据 IO 要少的多，因此利用覆盖索引在访问时也可以把磁盘的随机读取的 IO 转变成索引查找的顺序 IO</li>
</ul>
</li>
</ul>
<h4 id="超-100-万行的批量写-UPDATE-DELETE-INSERT-操作-要分批多次进行操作"><a href="#超-100-万行的批量写-UPDATE-DELETE-INSERT-操作-要分批多次进行操作" class="headerlink" title="超 100 万行的批量写 (UPDATE,DELETE,INSERT) 操作,要分批多次进行操作"></a>超 100 万行的批量写 (UPDATE,DELETE,INSERT) 操作,要分批多次进行操作</h4><ul>
<li><p><strong>大批量操作可能会造成严重的主从延迟</strong></p>
<p>主从环境中,大批量操作可能会造成严重的主从延迟，大批量的写操作一般都需要执行一定长的时间， 而只有当主库上执行完成后，才会在其他从库上执行，所以会造成主库与从库长时间的延迟情况</p>
</li>
<li><p><strong>binlog 日志为 row 格式时会产生大量的日志</strong>：大批量写操作会产生大量日志，特别是对于 row 格式二进制数据而言，由于在 row 格式中会记录每一行数据的修改，我们一次修改的数据越多，产生的日志量也就会越多，日志的传输和恢复所需要的时间也就越长，这也是造成主从延迟的一个原因</p>
</li>
<li><p><strong>避免产生大事务操作</strong>：大批量修改数据，一定是在一个事务中进行的，这就会造成表中大批量数据进行锁定，从而导致大量的阻塞，阻塞会对 MySQL 的性能产生非常大的影响。</p>
</li>
<li><p>特别是长时间的阻塞会占满所有数据库的可用连接，这会使生产环境中的其他应用无法连接到数据库，因此一定要注意大批量写操作要进行分批</p>
</li>
</ul>
<h3 id="索引详解"><a href="#索引详解" class="headerlink" title="索引详解"></a>索引详解</h3><h4 id="索引优缺点"><a href="#索引优缺点" class="headerlink" title="索引优缺点"></a>索引优缺点</h4><ul>
<li>优点：大大加快数据的检索速度；通过创建唯一性索引，可以保证数据库中每一行数据的唯一性</li>
<li>缺点：<ul>
<li>创建维护索引需要耗时，对数据进行增删改查也需要改变索引</li>
<li>索引需要物理空间存储</li>
<li>数据库数据量不大时，索引不一定有很好的效果</li>
</ul>
</li>
</ul>
<h4 id="索引底层数据结构？为什么不使用HashMap"><a href="#索引底层数据结构？为什么不使用HashMap" class="headerlink" title="索引底层数据结构？为什么不使用HashMap?"></a>索引底层数据结构？为什么不使用HashMap?</h4><ul>
<li><p><code>不使用HashMap</code>：HashMap不支持顺序和范围查询，无法很快查找某个范围类的数据</p>
</li>
<li><p>使用B+树作为索引数据结构</p>
<blockquote>
<p>使用B树或B+树作为索引结构主要是为了减少磁盘IO的次数，降低二叉平衡查找树的高度，因此B树和B+树都为<strong>多路平衡查找树</strong></p>
<ul>
<li><p>一个m阶的B树具有如下几个特征：</p>
<ul>
<li>根结点至少有两个子女</li>
<li>每个中间节点都包含k-1个元素和k个孩子，其中 m/2 &lt;= k &lt;= m</li>
<li>每一个叶子节点都包含k-1个元素，其中 m/2 &lt;= k &lt;= m</li>
<li>所有的叶子结点都位于同一层</li>
<li>每个节点中的元素从小到大排列，节点当中k-1个元素正好是k个孩子包含的元素的值域分划</li>
<li>每个结点都有卫星数据</li>
</ul>
</li>
<li><p>插入操作：判断当前结点key的个数是否小于等于m-1，如果满足，直接插入即可，如果不满足，将节点的中间的key将这个节点分为左右两部分，中间的节点放到父节点中即可</p>
</li>
<li><p>一个m阶的B+树具有如下特征：</p>
<ul>
<li>有k个子树的中间节点包含有k个元素，每个元素不保存数据，只用来索引，所有数据都保存在叶子节点（m/2 &lt;= k &lt;=m）</li>
<li>所有的叶子结点中包含了全部元素的信息，及指向含这些元素记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接</li>
<li>所有的中间节点元素都同时存在于子节点，在子节点元素中是最大（或最小）元素</li>
<li>根节点的最大（或最小）元素也就是整个B+树中最大（或最小）的元素，要一直保持</li>
<li>只有叶子节点有卫星数据</li>
</ul>
</li>
<li><p>B+树的优势：</p>
<ul>
<li>单一节点存储更多的元素，使得查询的IO次数更少</li>
<li>所有查询都要查找到叶子节点，查询性能稳定</li>
<li>所有叶子节点形成有序链表，便于范围查询</li>
</ul>
</li>
</ul>
</blockquote>
</li>
<li><p>MyISAM中，B+树叶节点的data域中存放的是数据记录的地址，取出data域的值后，还需要根据相应的地址取出相应的数据记录，这被称为<code>非聚簇索引</code></p>
</li>
<li><p>InnoDB中，其数据本身就是索引文件，树的叶节点data域保存了完整的数据记录，这被称为<code>聚簇索引</code>，这个索引的key是数据表的主键，而其余的索引都是辅助索引。辅助索引的data域存的是主键的值。</p>
<ul>
<li>根据主索引查找时，可以直接取出查找的数据</li>
<li>根据辅助索引查找时，首先查询到主键的值，再走主索引取出相应的值</li>
</ul>
</li>
</ul>
<h4 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h4><ul>
<li><strong>主键索引</strong>：主键列使用的索引。InnoDB 的表中，当没有显示的指定表的主键时，InnoDB 会自动先检查表中是否有唯一索引且不允许存在null值的字段，如果有，则选择该字段为默认的主键，否则 InnoDB 将会自动创建一个 6Byte 的自增主键</li>
<li><strong>二级索引（辅助索引）</strong>：<ul>
<li>唯一索引：唯一索引的属性列<strong>不能出现重复的数据</strong>，允许数据为NULL，一张表可以创建多个唯一索引。一般是为了数据的唯一性，而不是为了查询效率</li>
<li>普通索引：为了快速查询数据，可以创建多个普通索引，允许数据重复和NULL</li>
<li>前缀索引：只适用于字符串数据，对文本的前几个字符创建的索引，相比普通索引建立的数据更小，<strong>会导致覆盖索引优化失效</strong></li>
<li>全文索引：为了检索大文本数据中的关键字信息</li>
</ul>
</li>
</ul>
<h4 id="唯一索引和普通索引"><a href="#唯一索引和普通索引" class="headerlink" title="唯一索引和普通索引"></a>唯一索引和普通索引</h4><ul>
<li><p>二者查询性能差不多。主要区别在于更新的记录目标页不在内存中时，<strong>普通索引</strong>更新会使用change Buffer。<strong>唯一索引</strong>，由于需要校验数据的唯一性，因此每次更新操作都需要读磁盘把数据载进内存，涉及IO操作</p>
<ul>
<li>在不影响数据一致性的前提下， InnoDB会将这些更新操作缓存在change buffer中， 这样就不需要从磁盘中读入这个数据页了。 在下次查询需要访问这个数据页的时候， 将数据页读入内存， 然后执行change buffer中与这个页有关的操作。 通过这种方式就能保证这个数据逻辑的正确性</li>
<li>change buffer中的操作应用到原数据页，得到最新结果的过程称为merge<ol>
<li>访问这个数据页会触发merge。</li>
<li>系统有后台线程会定期merge。</li>
<li>在数据库正常关闭（shutdown） 的过程中，也会执行merge操作</li>
</ol>
</li>
</ul>
<blockquote>
<p>change Buffer与redo log 区别</p>
<ul>
<li>change Buffer主要用于减少读磁盘的次数，在必要读磁盘时再更新数据。</li>
<li>redo log 则是减少内存更新后，写磁盘的次数</li>
</ul>
<p>merge的执行流程是这样的：</p>
<ol>
<li>从磁盘读入数据页到内存（老版本的数据页）；</li>
<li>从change buffer里找出这个数据页的change buffer 记录(可能有多个），依次应用，得到新版数据页；</li>
<li>写redo log。这个redo log包含了数据的变更和change buffer的变更</li>
</ol>
</blockquote>
</li>
</ul>
<h4 id="聚集索引和非聚集索引"><a href="#聚集索引和非聚集索引" class="headerlink" title="聚集索引和非聚集索引"></a>聚集索引和非聚集索引</h4><ul>
<li><strong>聚集索引</strong>：索引结构和数据一起存放的索引。主键索引属于聚集索引，物理地址连续<ul>
<li>优点：查询速度快，不需要进行二次查询</li>
<li>缺点：<ul>
<li>依赖于有序的数据：如果索引的数据不是有序的，需要在插入时排序</li>
<li>更新代价大：被索引的列进行修改时，对应的索引也要修改，而叶子节点也包含着数据，也要更新，代价比较大。所以对于主键索引来说，一般不可被修改</li>
</ul>
</li>
</ul>
</li>
<li><strong>非聚集索引</strong>：索引结构和数据分开存放的索引。二级索引属于非聚集索引，逻辑上连续，物理地址不连续<ul>
<li>优点：更新代价比聚集索引小</li>
<li>缺点：<ul>
<li>依赖于有序的数据</li>
<li>可能会产生二次查询</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>非聚集索引不一定回表查询：查询的字段刚好建立了索引，直接返回就行了</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> name <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> name<span class="operator">=</span><span class="string">&#x27;guang19&#x27;</span>;</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h4><ul>
<li>一个索引包含（或者说覆盖）所有需要查询的字段的值，我们就称之为“覆盖索引”。覆盖索引就是把要查询出的列和索引是对应的，不做回表操作</li>
</ul>
<h4 id="索引失效"><a href="#索引失效" class="headerlink" title="索引失效"></a>索引失效</h4><ul>
<li>where语句中包含or时，可能会导致索引失效<ul>
<li>若or的条件中包含非索引，就会只用全表扫描的。如果or的条件两边都是索引，那么会使用<code>index_merge</code>的优化技术</li>
<li>index_merge：<strong>对多个索引分别进行条件扫描，然后将它们各自的结果进行合并</strong></li>
</ul>
</li>
<li>where语句中索引列使用了负向查询，可能会导致索引失效<ul>
<li>负向查询包括：NOT、!=、&lt;&gt;、!&lt;、!&gt;、NOT IN、NOT LIKE等</li>
</ul>
</li>
<li>对索引列进行<strong>运算</strong>，一定会导致索引失效</li>
<li>在索引列上使用<strong>内置函数</strong>，一定会导致索引失效</li>
<li>like通配符可能会导致索引失效，未满足最左匹配原则。</li>
<li>隐式类型转换导致的索引失效，如索引列user_id为varchar类型，使用int做条件关联。或者关联表字符集编码不一致。</li>
<li>索引字段可以为null，使用is null或is not null时，可能会导致索引失效</li>
<li>联合索引未满足最左匹配原则</li>
</ul>
<h4 id="建立索引的注意事项"><a href="#建立索引的注意事项" class="headerlink" title="建立索引的注意事项"></a>建立索引的注意事项</h4><ul>
<li><p><strong>选择合适的字段创建索引：</strong></p>
<ul>
<li><p><strong>不为 NULL 的字段</strong> ：索引字段的数据应该尽量不为 NULL，因为对于数据为 NULL 的字段，数据库较难优化。如果字段频繁被查询，但又避免不了为 NULL，建议使用 0,1,true,false 这样语义较为清晰的短值或短字符作为替代。</p>
</li>
<li><p><strong>被频繁查询的字段</strong> ：我们创建索引的字段应该是查询操作非常频繁的字段。</p>
</li>
<li><p><strong>被作为条件查询的字段</strong> ：被作为 WHERE 条件查询的字段，应该被考虑建立索引。</p>
</li>
<li><p><strong>频繁需要排序的字段</strong> ：索引已经排序，这样查询可以利用索引的排序，加快排序查询时间。</p>
</li>
<li><p><strong>被经常频繁用于连接的字段</strong> ：经常用于连接的字段可能是一些外键列，对于外键列并不一定要建立外键，只是说该列涉及到表与表的关系。对于频繁被连接查询的字段，可以考虑建立索引，提高多表连接查询的效率。</p>
</li>
</ul>
</li>
<li><p><strong>被频繁更新的字段应该慎重建立索引</strong>：虽然索引能带来查询上的效率，但是维护索引的成本也是不小的。 如果一个字段不被经常查询，反而被经常修改，那么就更不应该在这种字段上建立索引了。</p>
</li>
<li><p><strong>尽可能的考虑建立联合索引而不是单列索引</strong>：因为索引是需要占用磁盘空间的，可以简单理解为每个索引都对应着一颗 B+树。如果一个表的字段过多，索引过多，那么当这个表的数据达到一个体量后，索引占用的空间也是很多的，且修改索引时，耗费的时间也是较多的。如果是联合索引，多个字段在一个索引上，那么将会节约很大磁盘空间，且修改数据的操作效率也会提升。</p>
</li>
<li><p><strong>注意避免冗余索引</strong>：冗余索引指的是索引的功能相同，能够命中索引(a, b)就肯定能命中索引(a) ，那么索引(a)就是冗余索引。如（name,city ）和（name ）这两个索引就是冗余索引，能够命中前者的查询肯定是能够命中后者的 在大多数情况下，都应该尽量扩展已有的索引而不是创建新索引。</p>
</li>
<li><p><strong>考虑在字符串类型的字段上使用前缀索引代替普通索引</strong>：前缀索引仅限于字符串类型，较普通索引会占用更小的空间，所以可以考虑使用前缀索引带替普通索引</p>
</li>
</ul>
<h4 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h4><ul>
<li>最左匹配原则：查询条件中必须要有联合索引的第一个字段才可以使用索引</li>
<li>索引覆盖：不满足最左匹配原则的情况下，如果查询的字段都在联合索引中，也可以使用到索引，并且不需要回表操作</li>
</ul>
<h3 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h3><h4 id="redo-log-重做日志"><a href="#redo-log-重做日志" class="headerlink" title="redo log(重做日志)"></a>redo log(重做日志)</h4><ul>
<li><p>InnoDB独有，在系统崩溃时可以通过<code>redo log</code>恢复数据</p>
</li>
<li><p>MySQL中，查询记录是会一次将一页的信息都查询出来，加载到<code>Buffer Pool</code>中，后续查询都在<code>Buffer Pool</code>中进行，减少IO开销，更新数据也会在<code>Buffer Pool</code>中更新。然后会把在这个数据页上所做的修改，记录到<code>redo log buffer</code>中，接着刷盘到<code>redo log</code>文件中</p>
<blockquote>
<p>理想情况下，事务一提交就会进行刷盘，但实际情况下，刷盘的实际是根据策略来进行的</p>
<p> 每条redo记录由<code>表空间号+数据页号+偏移量+修改数据长度+具体修改数据</code>组成</p>
</blockquote>
</li>
<li><p><strong>刷盘时机</strong>：通过设置<code>innodb_flush_log_at_trx_commit</code>参数，支持三种策略</p>
<ul>
<li><p>0：每次事务提交时不进行刷盘操作，宕机或者崩溃可能会有1秒的数据损失</p>
</li>
<li><p>1：每次事务提交时进行刷盘操作（默认），不会有数据损失</p>
</li>
<li><p>2：每次事务提交时，只把redo log buffer内容写入page cache，MySQL崩溃不会有损失，宕机可能会有一秒损失</p>
</li>
<li><p>除此之外，InnoDB引擎有一个后台线程，每隔1秒，会把<code>redo log buffer</code>中的内容写入文件系统缓存（page cache）中，然后调用<code>fsync</code>进行刷盘。当<code>redo log buffer</code>占用空间即将达到<code>innodb_log_buffer_size</code>一半时，后台线程也会主动刷盘</p>
</li>
</ul>
<p><img src="/2022/01/03/day29/day29_20.png" alt="刷盘"></p>
</li>
<li><p><strong>日志文件组</strong>：硬盘上存储的 <code>redo log</code> 日志文件不只一个，而是以一个<strong>日志文件组</strong>的形式出现的，每个的<code>redo</code>日志文件大小都是一样的</p>
<ul>
<li><strong>write pos</strong> ：当前记录的位置，一边写一边后移</li>
<li><strong>checkpoint</strong> ：当前要擦除的位置，也是往后推移</li>
<li>每次刷盘写入日志时，write pos会后移；每次MySQL加载日志文件组恢复数据时，会清空加载过的<code>redo log</code>，checkpoint会后移</li>
</ul>
</li>
</ul>
<h4 id="binlog"><a href="#binlog" class="headerlink" title="binlog"></a>binlog</h4><ul>
<li><p>binlog是逻辑日志，记录内容是语句的原始逻辑，属于<code>MySQL Server</code>层。不管使用什么引擎，只要发生表更新，都会产生binlog。<strong>主要用于主从复制和数据恢复</strong></p>
</li>
<li><p><strong>三种格式</strong>：</p>
<ul>
<li>statement：记录SQL语句原文</li>
<li>row：记录SQL原句和操作的具体数据，比较占用空间</li>
<li>mixed：statement和row的混合，如果SQL语句会引起数据不一致，使用row；否则，使用statement</li>
</ul>
</li>
<li><p><strong>写入时机</strong>：事务执行过程中，先将日志写到binlog cache，事务提交时，再将binlog cache写入binlog文件中。</p>
<ul>
<li>一个事务的<code>binlog</code>不能被拆开，无论这个事务多大，也要确保一次性写入，所以系统会给每个线程分配一个块内存作为<code>binlog cache</code></li>
<li>设置<code>sync_binlog</code>控制刷盘时机：<ul>
<li>0：每次提交事务只write，系统自行判断执行fsync</li>
<li>1：每次提交事务都fsync</li>
<li>N：累计N个事务再执行fsync</li>
</ul>
</li>
</ul>
<p><img src="/2022/01/03/day29/day29_21.png" alt="binlog"></p>
</li>
</ul>
<h4 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a>两阶段提交</h4><ul>
<li><p><code>redo log</code>（重做日志）让<code>InnoDB</code>存储引擎拥有了崩溃恢复能力；<code>binlog</code>（归档日志）保证了<code>MySQL</code>集群架构的数据一致性，但二者的写入时机不同</p>
<p><img src="/2022/01/03/day29/day29_22.png" alt="写入时机"></p>
</li>
<li><p>为了防止binlog和redo log数据不一致，将<code>redo log</code>的写入拆成了两个步骤<code>prepare</code>和<code>commit</code>两个阶段</p>
<ul>
<li>在使用<code>redo log</code>恢复数据时，如果发现redo log还处于 prepare阶段，并且没有对应的binlog，就会回滚该事务</li>
</ul>
<p><img src="/2022/01/03/day29/day29_23.png" alt="两阶段提交"></p>
</li>
</ul>
<h4 id="undo-log-回滚日志"><a href="#undo-log-回滚日志" class="headerlink" title="undo log(回滚日志)"></a>undo log(回滚日志)</h4><ul>
<li>保证事务的原子性，所有事务的修改都会先记录到undo log中，在执行相关操作。回滚日志会优先于数据持久化到磁盘上，宕机也可以回滚</li>
</ul>
<h3 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h3><h4 id="InnoDB对MVCC的实现"><a href="#InnoDB对MVCC的实现" class="headerlink" title="InnoDB对MVCC的实现"></a>InnoDB对MVCC的实现</h4><ul>
<li>通过隐藏字段、Read View和undo log实现MVCC<ul>
<li>隐藏字段：每行数据有三个隐藏字段<ul>
<li><code>DB_TRX_ID</code>：最后一次插入或者更新该行的事务id</li>
<li><code>DB_ROLL_PTR</code>：回滚指针，指向改行的undo log</li>
<li><code>DB_ROW_ID</code>：没有主键且没有唯一非空索引的情况下，<code>InnoDB</code>会使用该id生成聚簇索引</li>
</ul>
</li>
<li>ReadView：主要用来做可见性判断，保存了当前对本事务不可见的其他活跃事务<ul>
<li><code>m_low_limit_id</code>：目前出现过的最大的事务 ID+1，即下一个将被分配的事务 ID。大于等于这个 ID 的数据版本均不可见</li>
<li><code>m_up_limit_id</code>：活跃事务列表 <code>m_ids</code> 中最小的事务 ID，如果 <code>m_ids</code> 为空，则 <code>m_up_limit_id</code> 为 <code>m_low_limit_id</code>。小于这个 ID 的数据版本均可见</li>
<li><code>m_ids</code>：<code>Read View</code> 创建时其他未提交的活跃事务 ID 列表。创建 <code>Read View</code>时，将当前未提交事务 ID 记录下来，后续即使它们修改了记录行的值，对于当前事务也是不可见的。<code>m_ids</code> 不包括当前事务自己和已提交的事务（正在内存中）</li>
<li><code>m_creator_trx_id</code>：创建该 <code>Read View</code> 的事务 ID</li>
</ul>
</li>
<li>undo log：若该记录被其他事务占用或当前版本对该事务不可见，则可以通过 <code>undo log</code> 读取之前的版本数据，以此实现非锁定读</li>
</ul>
</li>
<li><strong>数据可见性算法</strong>：本次事务中读取某一行的数据<ul>
<li>如果<code>DB_TRX_ID</code>&lt;<code>m_up_limit_id</code>，则可见</li>
<li>如果<code>DB_TRX_ID</code>&gt;=<code>m_low_limit_id</code>，表明事务快照之后才出现这一行数据，不可见</li>
<li><code>m_ids</code>为空，表示当前事务是最新的事务，可见</li>
<li>如果<code>m_up_limit_id</code>&lt;=<code>DB_TRX_ID</code>&lt;<code>m_low_limit_id</code>，若该事务id存在m_ids中，则不可见，否则可见</li>
<li>如果事务不可见，可以通过<code>DB_ROLL_PTR</code>指针，查询该行的历史数据是否可见</li>
</ul>
</li>
</ul>
<h4 id="RC和RR隔离级别下MVCC的ReadView生成时机不同"><a href="#RC和RR隔离级别下MVCC的ReadView生成时机不同" class="headerlink" title="RC和RR隔离级别下MVCC的ReadView生成时机不同"></a>RC和RR隔离级别下MVCC的ReadView生成时机不同</h4><ul>
<li>RC下，每次查询前都要生成一个ReadView</li>
<li>RR下，只有第一次查询生成一个ReadView</li>
</ul>
<h4 id="MVCC-Next-key-Lock防止幻读（RR隔离级别）"><a href="#MVCC-Next-key-Lock防止幻读（RR隔离级别）" class="headerlink" title="MVCC+Next-key-Lock防止幻读（RR隔离级别）"></a>MVCC+Next-key-Lock防止幻读（RR隔离级别）</h4><ul>
<li>执行普通的select语句：为快照读，只在第一次查询时生成ReadView，后续事务提交不影响，可以解决幻读</li>
<li>执行select…for update/lock in share mode、insert、update、delete等语句：为锁定读，读取的是最新的数据。InnoDB使用Next-key-Lock锁定读取到的记录以及它们之间的间隙，防止其他事务在查询范围内插入数据，防止了幻读</li>
</ul>
<p><img src="/2022/01/03/day29/day29_24.png" alt="SQL语句执行流程"></p>
<blockquote>
<ul>
<li>查询语句的执行流程如下：权限校验（如果命中缓存）—&gt;查询缓存—&gt;分析器—&gt;优化器—&gt;权限校验—&gt;执行器—&gt;引擎</li>
<li>更新语句执行流程如下：分析器—-&gt;权限校验—-&gt;执行器—&gt;引擎—redo log(prepare 状态)—&gt;binlog—&gt;redo log(commit状态)</li>
</ul>
</blockquote>
<h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><h4 id="锁分类"><a href="#锁分类" class="headerlink" title="锁分类"></a>锁分类</h4><ul>
<li>全局锁：对整个数据库实例加锁，命令：<code>Flush tables with read lock (FTWRL)</code><ul>
<li>应用场景：全库逻辑备份</li>
</ul>
</li>
<li>表锁：分为表锁和元数据锁<ul>
<li>表锁：<code>lock tables t1 read,t2 write</code><ul>
<li>对其他线程来说，t1表，可以读，不可以写；t2表，读写都不可以</li>
<li>对本线程来说，t1表只能读，t2表只能读写</li>
</ul>
</li>
<li>元数据锁：Metadata Lock(MDL)，面向DML和DDL之间得并发控制，元数据锁不需要我们显式的加，系统默认会加<ul>
<li>当做DML操作时，会申请一个MDL读锁</li>
<li>当做DDL操作时，会申请一个MDL写锁</li>
<li>读锁之间不互斥，读写和写写之间都互斥</li>
</ul>
</li>
</ul>
</li>
<li>行锁：InnoDB的行锁是针对索引加的，而不是针对记录，该索引不能失效，否则会升级为表锁<ul>
<li><code>select * from t lock in share mode</code></li>
</ul>
</li>
</ul>
<h4 id="两阶段锁"><a href="#两阶段锁" class="headerlink" title="两阶段锁"></a>两阶段锁</h4><ul>
<li><p>在InnoDB事务中， 行锁是在需要的时候才加上的， 但并不是不需要了就立刻释放， 而是要等到事务结束时才释放</p>
<ul>
<li>事务B要在事务A提交之后才会执行</li>
</ul>
<p><img src="/2022/01/03/day29/day29_30.png" alt="示例"></p>
</li>
<li><p>出现死锁：</p>
<ul>
<li>进入等待，超时</li>
<li>发起死锁检测，回滚死锁链中的某一个事务，打破死锁</li>
</ul>
</li>
</ul>
<h4 id="加锁原则"><a href="#加锁原则" class="headerlink" title="加锁原则"></a>加锁原则</h4><ul>
<li>原则1： 加锁的基本单位是next-keylock，前开后闭区间</li>
<li>原则2： 查找过程中访问到的对象才会加锁</li>
<li>优化1： 索引上的等值查询， 给唯一索引加锁的时候， next-keylock退化为行锁</li>
<li>优化2： 索引上的等值查询， 向右遍历时且最后一个值不满足等值条件的时候， next-key lock退化为间隙锁。</li>
<li>一个bug： 唯一索引上的范围查询会访问到不满足条件的第一个值为止。</li>
</ul>
<h3 id="特殊情况处理"><a href="#特殊情况处理" class="headerlink" title="特殊情况处理"></a>特殊情况处理</h3><h4 id="超大分页如何处理？"><a href="#超大分页如何处理？" class="headerlink" title="超大分页如何处理？"></a>超大分页如何处理？</h4><ul>
<li>使用主键id优化，找到上次分页的最大ID，利用主键索引进行查询。<strong>要求ID必须是连续的</strong></li>
<li>覆盖索引优化，先查出索引的主键ID，再使用主键索引拿数据</li>
</ul>
<h4 id="优化SQL？"><a href="#优化SQL？" class="headerlink" title="优化SQL？"></a>优化SQL？</h4><ul>
<li>添加合适索引：索引创建原则</li>
<li>优化表结构：数据类型越小越好、尽量少使用NULL</li>
<li>优化查询语句：是否命中索引等</li>
</ul>
<h4 id="分布式主键方案？"><a href="#分布式主键方案？" class="headerlink" title="分布式主键方案？"></a>分布式主键方案？</h4><ul>
<li>数据库自增序列</li>
<li>UUID</li>
<li>Redis生成ID</li>
<li>等</li>
</ul>
<h4 id="分库分表？"><a href="#分库分表？" class="headerlink" title="分库分表？"></a>分库分表？</h4><ul>
<li><p>分表：单表数据量过大，会影响查询性能。将一个表的数据放在多个表中</p>
<ul>
<li><p>垂直分表：把一个表的多个字段拆分为多个表，一般将字段作冷热拆分，冷字段一个表，热字段一个表</p>
<p><img src="/2022/01/03/day29/day29_31.png" alt="垂直分表案例"></p>
</li>
<li><p>水平分表：减少单个表中的数据量</p>
</li>
</ul>
</li>
<li><p>分库：单库的并发量最多到2000，将一个库的数据拆分到多个库中，可以增加并发量</p>
<ul>
<li><p>垂直分库：将关联度低的表存放在不同的库中</p>
<p><img src="/2022/01/03/day29/day29_32.png" alt="垂直分库案例"></p>
</li>
<li><p>水平分库：提升单个业务系统的QPS</p>
<p><img src="/2022/01/03/day29/day29_33.png" alt="水平分库案例"></p>
</li>
</ul>
</li>
<li><p>垂直切分的优缺点：</p>
<ul>
<li>优点：切合业务系统结构；方便对数据进行管理；提升系统的高并发性能</li>
<li>缺点：没有解决单表数据量过大的问题；分布式事务处理复杂</li>
</ul>
</li>
<li><p>水平切分的优缺点：</p>
<ul>
<li>优点：提升系统性能，不存在性能瓶颈；对业务没有影响</li>
<li>缺点：数据多次扩展难度和维护大</li>
</ul>
</li>
</ul>
<h4 id="大表查询优化"><a href="#大表查询优化" class="headerlink" title="大表查询优化"></a>大表查询优化</h4><ul>
<li>优化sql语句，增加索引</li>
<li>增加缓存，使用redis</li>
<li>主从复制，读写分离</li>
<li>分库分表</li>
</ul>
<h4 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h4><p><img src="/2022/01/03/day29/day29_34.png" alt="主从复制过程"></p>
<ul>
<li><ol>
<li><p>Master的更新事件(update、insert、delete)会按照顺序写入bin-log中。当Slave连接到Master的后,Master机器会为Slave开启  binlog dump线程,该线程会去读取bin-log日志  </p>
</li>
<li><p>Slave连接到Master后,Slave库有一个I/O线程 通过请求binlog dump thread读取bin-log日志,然后写入从库的relay log日志中。  </p>
</li>
<li><p>Slave还有一个 SQL线程,实时监控 relay-log日志内容是否有更新,解析文件中的SQL语句,在Slave数据库中去执行。</p>
</li>
</ol>
</li>
</ul>
<h4 id="主从复制同步方式"><a href="#主从复制同步方式" class="headerlink" title="主从复制同步方式"></a>主从复制同步方式</h4><ul>
<li><strong>异步复制</strong>  ：Mysql主从同步 默认是异步复制的。就是上面三步中,只有第一步是同步的(也就是Mater写入bin log日志),就是主库写入binlog日志后即可成功返回客户端，无须等待binlog日志传递给从库的过程。  Master 不关心 Slave 的数据有没有写入成功。因此如果Master和Slave之间有网络延迟，就会造成暂时的数据不一致的现象；如果Master出故障，而数据还没有复制过去，则会造成数据丢失；但也有好处，<strong>效率较其他两种复制方式最高</strong>。 </li>
<li><strong>同步复制</strong>  ：Master主机将事件发送给Slave主机后会触发一个等待，直到所有Slave节点（如果有多个Slave）返回数据复制成功的信息给Master。 这种复制方式最安全，但是同时，效率也是最差的。  </li>
<li><strong>半同步复制</strong>  ：对于半同步复制而言，Master主机将事件发送给Slave主机后会触发一个等待，直到其中一个Slave节点（如果有多个Slave）返回数据复制成功的信息给Master。  由此增强了数据的一致性，但是因为Master主机的确认开销，会损耗一部分的性能； 另外，半同步复制除了不需要等待所有Slave主机确认事件的接收外，半同步数据复制并不要求那些事件完全地执行，因此，仍有可能看到在Slave主机上数据复制延迟的发生，如果因为网络延迟等原因造成Slave迟迟没有返回复制成功的信息，超过了Master设置的超时时长，<strong>半同步复制就降级为异步复制方式</strong>，而后继续数据复制。</li>
</ul>
<h4 id="Mysql主从同步延时产生原因-怎么优化？"><a href="#Mysql主从同步延时产生原因-怎么优化？" class="headerlink" title="Mysql主从同步延时产生原因?怎么优化？"></a>Mysql主从同步延时产生原因?怎么优化？</h4><ul>
<li>原因：<ul>
<li>主节点如果执行一个很大的事务，会对主从延迟产生较大的影响</li>
<li>网络延迟，日志较大，slave数量过多</li>
<li>机器性能问题，从节点是否使用了“烂机器”</li>
</ul>
</li>
<li>优化：<ul>
<li>大事务：将大事务分为小事务，分批更新数据</li>
<li>减少Slave的数量，不要超过5个，减少单次事务的大小</li>
</ul>
</li>
</ul>
<h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><h3 id="Redis为什么快？"><a href="#Redis为什么快？" class="headerlink" title="Redis为什么快？"></a>Redis为什么快？</h3><ul>
<li><strong>基于内存</strong>：Redis是使用内存存储，没有磁盘IO上的开销。数据存在内存中，读写速度快。</li>
<li><strong>单线程实现</strong>（ Redis 6.0以前）：Redis使用单个线程处理请求，避免了多个线程之间线程切换和锁资源争用的开销。</li>
<li><strong>IO多路复用模型</strong>：Redis 采用 IO 多路复用技术。Redis 使用单线程来轮询描述符，将数据库的操作都转换成了事件，不在网络I/O上浪费过多的时间。</li>
<li><strong>高效的数据结构</strong>：Redis 每种数据类型底层都做了优化，目的就是为了追求更快的速度。</li>
</ul>
<h3 id="Redis应用场景有哪些？"><a href="#Redis应用场景有哪些？" class="headerlink" title="Redis应用场景有哪些？"></a>Redis应用场景有哪些？</h3><ul>
<li><strong>缓存热点数据</strong>，缓解数据库的压力。 </li>
<li>利用 Redis 原子性的自增操作，可以实现<strong>计数器</strong>的功能，比如统计用户点赞数、用户访问数等。 </li>
<li><strong>简单的消息队列</strong>，可以使用Redis自身的发布/订阅模式或者List来实现简单的消息队列，实现异步操作。 </li>
<li><strong>限速器</strong>，可用于限制某个用户访问某个接口的频率，比如秒杀场景用于防止用户快速点击带来不必要的压力。 </li>
<li><strong>好友关系</strong>，利用集合的一些命令，比如交集、并集、差集等，实现共同好友、共同爱好之类的功能。</li>
</ul>
<h3 id="Redis-数据类型有哪些？"><a href="#Redis-数据类型有哪些？" class="headerlink" title="Redis 数据类型有哪些？"></a>Redis 数据类型有哪些？</h3><ul>
<li><p><strong>基本数据类型</strong>：</p>
<ul>
<li><strong>String</strong>：String类型的值可以是字符串、数字或者二进制，但值最大不能超过512MB。可以存储编码后的数据<ul>
<li>String的数据结构为**简单动态字符串(Simple Dynamic String,缩写SDS)**。内部结构实现上类似于Java的ArrayList，采用预分配冗余空间的方式来减少内存的频繁分配</li>
</ul>
</li>
<li><strong>Hash</strong>：Hash 是一个键值对集合。适合存储对象<ul>
<li>Hash类型对应的数据结构是两种：ziplist（压缩列表），hashtable（哈希表）。当field-value长度较短且个数较少时，使用ziplist，否则使用hashtable</li>
</ul>
</li>
<li><strong>Set</strong>：无序去重的集合。Set 提供了交集、并集等方法，对于实现共同好友、共同关注等功能特别方便<ul>
<li>底层是一个value为null的hash表</li>
</ul>
</li>
<li><strong>List</strong>：有序可重复的集合，实际上是一个双向链表。<ul>
<li>List的数据结构采用快速链表quickList</li>
<li>在列表元素较少的情况下会使用一块连续的内存存储，这个结构是ziplist，也即是压缩列表<ul>
<li>ziplist将所有的元素紧挨着一起存储，分配的是一块连续的内存</li>
</ul>
</li>
<li>当数据量比较多的时候才会改成quickList<ul>
<li>quickList将链表和ziplist进行结合，构成了快速链表，减少了空间冗余</li>
</ul>
</li>
</ul>
</li>
<li><strong>SortedSet</strong>：有序Set。内部维护了一个<code>score</code>的参数来实现。适用于排行榜和带权重的消息队列等场景。<ul>
<li>zset底层使用了两个数据结构:<ul>
<li>hash，hash的作用就是关联元素value和权重score，保障元素value的唯一性，可以通过元素value找到相应的score值</li>
<li>跳跃表，跳跃表的目的在于给元素value排序，根据score的范围获取元素列表。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>特殊的数据类型</strong>：</p>
<ul>
<li><strong>Bitmap</strong>：位图，其实是一个字符串，字符串每一位只能是0或1,下标在 Bitmap 中叫做偏移量。可以用于统计用户状态，例如是否订阅新闻。比较节约空间</li>
<li><strong>Hyperloglog</strong>。HyperLogLog 是用来做基数统计，也就是求解集合中不重复元素个数。其优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定的、并且是很小的。<strong>典型的使用场景是统计独立访客。他只是统计数量，并不能返回统计的元素</strong></li>
<li><strong>Geospatial</strong> ：主要用于存储地理位置信息，并对存储的信息进行操作，适用场景如定位、附近的人等。</li>
</ul>
</li>
</ul>
<h3 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h3><ul>
<li><p>RDB：在指定的<strong>时间间隔</strong>内，将内存中的<strong>数据集快照</strong>写入到磁盘中。恢复时将快照文件直接读到内存里</p>
<ul>
<li>优点：RDB恢复数据速度高于AOF；使用子线程进行持久化，主线程继续处理，性能更高</li>
<li>缺点：出现异常会丢失最后一次持久化的数据；<strong>RDB方式<a target="_blank" rel="noopener" href="https://www.nowcoder.com/jump/super-jump/word?word=%E6%95%B0%E6%8D%AE">数据</a>无法做到实时持久化</strong>。因为<code>BGSAVE</code>每次运行都要执行<code>fork</code>操作创建子进程，属于重量级操作，频繁执行成本比较高。</li>
</ul>
<p><img src="/2022/01/03/day29/day29_35.png" alt="RDB持久化流程"></p>
</li>
<li><p>AOF:以日志的形式记录<strong>写操作</strong>（不记录读操作），将Redis执行过的所有指令记录下来，<strong>只允许追加文件不允许修改文件</strong>。redis启动之初会读取该文件重新构建数据。主要作用是<strong>解决了<a target="_blank" rel="noopener" href="https://www.nowcoder.com/jump/super-jump/word?word=%E6%95%B0%E6%8D%AE">数据</a>持久化的实时性</strong>，AOF 是Redis持久化的主流方式。</p>
<ul>
<li><p>AOF缓冲区根据AOF持久化策略**[always,everysec,no]**将操作sync同步到磁盘的AOF文件中</p>
<ul>
<li>always：每次写入都记入日志</li>
<li>everysec：每秒记录一次</li>
<li>no：redis不主动同步，将同步时机交给操作系统</li>
</ul>
</li>
<li><p>优点：AOF可以更好的保护<a href>数据</a>不丢失，可以配置 AOF 每秒执行一次<code>fsync</code>操作，如果Redis进程挂掉，最多丢失1秒的数据；</p>
<p>AOF以<code>append-only</code>的模式写入，所以没有磁盘寻址的开销，写入性能非常高</p>
</li>
<li><p>缺点：数据恢复慢；AOF文件大<br><img src="/2022/01/03/day29/day29_36.png" alt="AOF流程"></p>
</li>
</ul>
</li>
</ul>
<h3 id="主从复制-1"><a href="#主从复制-1" class="headerlink" title="主从复制"></a>主从复制</h3><ul>
<li>当启动一个从节点时，它会发送一个 <code>PSYNC</code> 命令给主节点；</li>
<li>如果是从节点初次连接到主节点，那么会触发一次全量复制。此时主节点会启动一个后台线程，开始生成一份 <code>RDB</code> 快照文件；同时还会将从客户端 client 新收到的所有写命令缓存在内存中。<code>RDB</code> 文件生成完毕后， 主节点会将<code>RDB</code>文件发送给从节点，从节点会先将<code>RDB</code>文件<strong>写入本地磁盘，然后再从本地磁盘加载到内存中</strong>； 接着主节点会将内存中缓存的写命令发送到从节点，从节点同步这些<a href>数据</a>； </li>
<li>如果从节点跟主节点之间网络出现故障，连接断开了，会自动重连，连接之后主节点仅会将部分缺失的<a href>数据</a>同步给从节点。</li>
</ul>
<h3 id="过期键的删除策略？"><a href="#过期键的删除策略？" class="headerlink" title="过期键的删除策略？"></a>过期键的删除策略？</h3><ul>
<li><p><strong>被动删除</strong>。在访问key时，如果发现key已经过期，那么会将key删除。</p>
</li>
<li><p><strong>主动删除</strong>。定时清理key，每次清理会依次遍历所有DB，从db随机取出20个key，如果过期就删除，如果其中有5个key过期，那么就继续对这个db进行清理，否则开始清理下一个db。</p>
</li>
<li><p><strong>内存不够时清理</strong>。Redis有最大内存的限制，通过maxmemory参数可以设置最大内存，当使用的内存超过了设置的最大内存，就要进行内存释放， 在进行内存释放的时候，会按照配置的淘汰策略清理内存</p>
</li>
</ul>
<h3 id="内存淘汰策略有哪些？"><a href="#内存淘汰策略有哪些？" class="headerlink" title="内存淘汰策略有哪些？"></a>内存淘汰策略有哪些？</h3><ul>
<li><p>当Redis的内存超过最大允许的内存之后，Redis 会触发内存淘汰策略，删除一些不常用的<a href>数据</a>，以保证Redis服务器正常运行。</p>
</li>
<li><p><strong>volatile-lru</strong>：LRU（<code>Least Recently Used</code>），<strong>最近使用</strong>。利用LRU<a href>算法</a>移除设置了过期时间的key </p>
</li>
<li><p><strong>allkeys-lru</strong>：从<a href>数据</a>集中移除<strong>最近最少使用</strong>的key </p>
</li>
<li><p><strong>volatile-ttl</strong>：从已设置过期时间的<a href>数据</a>集中挑选<strong>将要过期的数据淘汰</strong> </p>
</li>
<li><p><strong>volatile-random</strong>：从已设置过期时间的<a href>数据</a>集中<strong>任意选择<a href>数据</a>淘汰</strong> </p>
</li>
<li><p><strong>allkeys-random</strong>：从<a href>数据</a>集中<strong>任意选择<a href>数据</a>淘汰</strong> </p>
</li>
<li><p><strong>no-eviction</strong>：**禁止删除<a href>数据</a>**，当内存不足以容纳新写入<a href>数据</a>时，新写入操作会报错 </p>
</li>
<li><p><strong>volatile-lfu</strong>：LFU，Least Frequently Used，最少使用，从已设置过期时间的<a href>数据</a>集中挑选<strong>最不经常使用的<a href>数据</a>淘汰</strong>。 </p>
</li>
<li><p><strong>allkeys-lfu</strong>：当内存不足以容纳新写入<a href>数据</a>时，<strong>从<a href>数据</a>集中移除最不经常使用的key</strong>。 </p>
</li>
</ul>
<h3 id="如何保证缓存与数据库双写时的数据一致性？"><a href="#如何保证缓存与数据库双写时的数据一致性？" class="headerlink" title="如何保证缓存与数据库双写时的数据一致性？"></a>如何保证缓存与数据库双写时的数据一致性？</h3><ul>
<li><p><strong>先删除缓存再更新数据库</strong>：进行更新操作时，先删除缓存，然后更新<a href>数据</a>库，后续的请求再次读取时，会从<a href>数据</a>库读取后再将新<a href>数据</a>更新到缓存。</p>
<ul>
<li>问题：删除缓存<a href>数据</a>之后，更新<a href>数据</a>库完成之前，<strong>这个时间段内如果有新的读请求过来</strong>，就会从<a href>数据</a>库读取旧<a href>数据</a>重新写到缓存中，再次造成不一致，并且后续读的都是旧<a href>数据</a>。</li>
</ul>
</li>
<li><p><strong>先更新<a href>数据</a>库再删除缓存</strong>：进行更新操作时，先更新MySQL，成功之后，删除缓存，后续读取请求时再将新<a href>数据</a>回写缓存。</p>
<ul>
<li>问题：<strong>更新MySQL和删除缓存这段时间内，请求读取的还是缓存的旧数据</strong>，不过等<a href>数据</a>库更新完成，就会恢复一致，影响相对比较小。</li>
</ul>
</li>
<li><p><strong>异步更新缓存</strong>：<a href>数据</a>库的更新操作完成后不直接操作缓存，而是把这个操作命令封装成消息扔到消息队列中，然后由Redis自己去消费更新<a href>数据</a>，消息队列可以保证<a href>数据</a>操作顺序一致性，确保缓存系统的<a href>数据</a>正常。</p>
</li>
</ul>
<h2 id="kafka"><a href="#kafka" class="headerlink" title="kafka"></a>kafka</h2><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul>
<li>异步处理：将原本串行处理的业务，转为分块异步处理</li>
<li>应用解耦：<ul>
<li>A系统进行订单创建，需要通知B、C系统作相应操作。A系统是强依赖BC系统的，如果此时BC系统出现了问题，换成了另一个D系统，则代码就需要进行修改</li>
<li>使用消息队列的方式，A系统只用发送消息即可，不用再关心BC系统的状态，进行了解耦</li>
</ul>
</li>
<li>流量削峰：<ul>
<li>某个系统平时qps比较低，做活动时qps激增，但系统的处理能力达不到，可以使用消息队列的形式，一方面可以缓解qps压力，另一方面也可以控制参加活动人数，超过限制就丢弃</li>
</ul>
</li>
</ul>
<h3 id="kafka的消费者是pull还是push模式，这种模式有什么好处？"><a href="#kafka的消费者是pull还是push模式，这种模式有什么好处？" class="headerlink" title="kafka的消费者是pull还是push模式，这种模式有什么好处？"></a>kafka的消费者是pull还是push模式，这种模式有什么好处？</h3><ul>
<li>producer将消息push到broker，consumer从broker对消息进行pull</li>
<li>优点：pull模式消费者自主决定是否批量从broker拉取数据，而push模式在无法知道消费者消费能力情况下，不易控制推送速度，太快可能造成消费者奔溃，太慢又可能造成浪费</li>
<li>缺点：如果 broker 没有可供消费的消息，将导致 consumer 不断在循环中轮询，直到新消息到到达</li>
</ul>
<h3 id="kafka集群组成"><a href="#kafka集群组成" class="headerlink" title="kafka集群组成"></a>kafka集群组成</h3><p><img src="/2022/01/03/day29/day29_58.png" alt="kafka组成"></p>
<ul>
<li>  <strong>Broker</strong>：消息中间件处理节点，一个Kafka节点就是一个Broker，一个或者多个Broker可以组成一个Kafka集群</li>
<li>  <strong>Topic</strong>：每条发布到Kafka集群的消息都有一个类别，这个类别被称为Topic。（物理上不同Topic的消息分开存储，逻辑上一个Topic的消息虽然保存于一个或多个broker上但用户只需指定消息的Topic即可生产或消费数据而不必关心数据存于何处）</li>
<li>  <strong>Partition</strong>：用于存放消息的队列，存放的消息都是<strong>有序</strong>的。同一个topic可以分多个partition</li>
<li>  <strong>Producer</strong>：消息生产者，向Broker发送消息的客户端</li>
<li>  <strong>Consumer</strong>：消息消费者，从Broker读取消息的客户端，通过offset进行标识消息被消费的位置</li>
<li>  <strong>Consumer Group</strong>：每个consumer都属于一个group，一条消息可以发送到多个不同的group，但是一个group内只有一个consumer能够消费该信息</li>
<li>  <strong>ZooKeeper</strong>：主要用于在集群中不同节点之间的通信。如: leader 检测、分布式同步、配置管理、识别新节点何时离开或连接、集群、节点实时状态等</li>
</ul>
<h3 id="kafka消息可靠性"><a href="#kafka消息可靠性" class="headerlink" title="kafka消息可靠性"></a>kafka消息可靠性</h3><ul>
<li>每个partition提供多个副本，将副本分布到所有的broker中。副本中会有一个leader节点，其他为follower节点</li>
<li>消息备份：<ul>
<li>ISR：一个partition中与leader保持同步的副本列表，在max.ms时间内与leader保持同步。follower会周期性向leader发fetchRequest，请求数据同步</li>
<li>ACKs：生产者发送消息中包含acks字段，代表leader应答生产者前，leader收到的应答数<ul>
<li>acks=0：生产者无需服务端确认，无法保证数据被发送到broker</li>
<li>acks=1：leader在接收到消息之后立刻应答，不需要等到follower同步完成。如果leader宕机，消息可能丢失</li>
<li>acks=all：所有follower同步完消息之后leader再进行应答</li>
</ul>
</li>
<li>副本对象的重要字段：<ul>
<li>LEO（log end offset）：日志末端偏移。指向副本中下一条消息的写入位置</li>
<li>HW（high watermark）：已同步消息标识。HW以下的数据都已经备份，leader的HW值为ISR中所有备份的LEO最小值决定（最慢的机器）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="kafka故障恢复"><a href="#kafka故障恢复" class="headerlink" title="kafka故障恢复"></a>kafka故障恢复</h3><ul>
<li><p>Broker故障恢复：</p>
<ul>
<li><p>Broker和其他的Broker断开，ZooKeeper还和Broker0连接，认为它还存活</p>
<ul>
<li>leader：当leader超过max.ms没有收到follower的fectchRequest之后，broker0会将leader的ISR收缩到只有broker0本身，并将ISR的变更通知到zookeeper</li>
<li>follower：超过max.ms后，leader会将broker0从ISR中删除</li>
</ul>
<p><img src="/2022/01/03/day29/day29_59.png" alt="情形1"></p>
</li>
<li><p>Broker和ZooKeeper断开连接，ZooKeeper会认为Broker0宕机</p>
<ul>
<li>leader：<ul>
<li>zookeeper将broker0删除，controller收到通知，从ISR中选择新的leader，并通知其他broker</li>
<li>当Broker0与ZooKeeper恢复连接后，发现自己不再是Partition0的Leader，于是将本地日志截断(为了保证和Leader数据一致性)。在broker0失联期间，所有写入broker0的消息都会丢失</li>
</ul>
</li>
<li>follower：broker之间的连接未断，还是可以向leader发送fetchRequest进行同步</li>
</ul>
<p><img src="/2022/01/03/day29/day29_60.png" alt="情形2"></p>
</li>
</ul>
</li>
<li><p>Controller故障恢复：</p>
<ul>
<li>controller与zookeeper断开连接：zookeeper会将controller删除，并重新选举出新的controller。当重新恢复连接之后，作为一个普通的broker</li>
<li>Controller与某个broker断开连接：该broker中的leader会被重新选举，而broker并不知道leader已经更换，所以会出现broker和zookeeper断开连接时，短暂服务不可用和可能发生数据丢失的情况</li>
</ul>
</li>
</ul>
<h3 id="kafka高性能"><a href="#kafka高性能" class="headerlink" title="kafka高性能"></a>kafka高性能</h3><ul>
<li><p>批量发送：producer在发送消息到broker时，采用批量发送的方式，减少网络消耗，提高性能</p>
<ul>
<li>Producer将消息分发到多个本地Partition的消息队列中，每个Partition消息队列中的消息会写入到不同的Leader节点</li>
<li><strong>发送流程</strong>：producer生产消息，序列化压缩之后，追加到本地的记录收集器，sender不断轮询，满足一定条件才将收集器中的数据发送到broker中（消息大小达到阈值、消息等待时间到达阈值）</li>
</ul>
<p><img src="/2022/01/03/day29/day29_61.png" alt="批量发送"></p>
</li>
<li><p>顺序写+零拷贝：提高broker在持久化消息、读取消息的性能</p>
<ul>
<li>顺序IO：数据分布在一起，找到第一块数据后，其他需要的数据就在第一块数据的后面，不需要多次切换寻址，读取速度较快<ul>
<li>producer传递给broker的每条消息都有一个顺序值，代表producer生产消息的顺序。producer创建的消息集中，每条消息的顺序值只是相对于本批次的序号，服务端会将每条消息的顺序值转换为绝对偏移量。kafka通过nextOffset来记录存储在日志中最近一条消息的偏移量</li>
</ul>
</li>
<li>零拷贝：减少数据拷贝次数和上下文切换次数（详见操作系统部分）</li>
</ul>
</li>
</ul>
<h2 id="thrift"><a href="#thrift" class="headerlink" title="thrift"></a>thrift</h2><p><img src="/2022/01/03/day29/day29_56.png" alt="thrift基本框架"></p>
<ul>
<li><p>Client端：</p>
<ul>
<li><p>netty client：客户端与服务端的网络通信由netty完成。</p>
</li>
<li><p>客户端代理：RPC要求像调用本地函数一样调用远程函数，需要向调用方屏蔽调用细节。</p>
</li>
<li><p>客户端filter：代理模式的具体实现，是用责任链模式衔接，为框架提供了高可扩展性。Filter 中包含：服务监控、服务路由、故障注入、服务鉴权、服务降级、服务调用等模块</p>
</li>
<li><p>连接池：调用端做IO操作时需要创建的对象。一个客户端可以和多个服务端相连，这些连接在服务端的连接池中维护</p>
</li>
<li><p>线程池：收到服务端返回的数据后，通知业务线程</p>
</li>
<li><p>netty client：客户端与服务端的网络通信由netty完成。其包含 Boss（ Reactor 模型中的 MainReactor ）、Worker（Reactor 模型中的 SubReactor）以及基于Channel 的 Pipeline</p>
</li>
<li><ul>
<li>boss：在客户端中，负责发起connect请求；在服务端中，负责accept客户端发起的connect请求</li>
<li>worker：负责轮询连接是否有数据到达，并负责将数据读写到相应的channel中</li>
<li>pipeline：负责对channel中的数据进行加工</li>
</ul>
</li>
</ul>
</li>
<li><p>server端：</p>
<ul>
<li>服务端filter：与客户端filter对应，请求在进入业务代码前，要经过服务监控、服务鉴权、服务限流等模块</li>
<li>线程池：将业务逻辑从I/O中剥离，数据准备好后，业务代码将在业务线程中执行</li>
<li>netty server：与netty client类似</li>
</ul>
</li>
</ul>
<h3 id="远程服务调用的执行过程"><a href="#远程服务调用的执行过程" class="headerlink" title="远程服务调用的执行过程"></a>远程服务调用的执行过程</h3><p><img src="/2022/01/03/day29/day29_57.png" alt="RPC调用过程"></p>
<ul>
<li><p>首先在客户端调用远程服务方法时，其真正调用的是 InvocationHandler 的 invoke 方法（这里使用 JDK 的动态代理）。Pigeon 中 InvocationHandler 的实现为 ServiceInvocationProxy， 所以调用接口声明的任意方法最终都会进到ServiceInvocationProxy.invoke 方法</p>
</li>
<li><p>ServiceInvocationProxy.invoke 中会调用客户端 Filter ，请求会依次经过 监控、路由、降级、网关、鉴权 等模块后，进入 RemoteCallInvokeFilter</p>
</li>
<li><p>在 RemoteCallInvokeFilter 中调用 Client.write 方法，其逻辑为从连接池（ChannelPool）中 获取连接（获取连接的超时时间默认为：2000ms），然后将数据写进 Channel</p>
</li>
<li><p>在向服务端发送数据之前，需经过 Channel 的 Pipeline（序列化、压缩等，减少网络传输的数据量）</p>
</li>
<li><p>开始向服务端发送数据，由于 Netty 发送消息是异步的，所以如果是同步调用的话，Pigeon 这里会让业务线程主动 await ，直到收到服务端响应或超时后唤醒。</p>
</li>
<li><p>服务端收到客户端发过的消息后，从 Channel 中将消息读出来之前，也会先经过一些 Pipeline（反序列化、解压缩等）后到达 NettyServerHandler。pigeon在该步骤有服务隔离的设计</p>
</li>
<li><ul>
<li>默认的隔离机制：当超时数达到300，或超时率超过5%，将后续对应请求放入slow线程池处理；其他情况，将后续对应请求放入shared线程池处理</li>
<li>默认开启方法限流：单个方法不能占用超过380个线程</li>
<li>提供业务自定义独立线程池支持</li>
</ul>
</li>
<li><p>在选择相应的线程池并成功的拿到线程后，请求就到了服务端 Filter 中。请求会依次经过 监控、流量录制、鉴权、泛化调用、网关等模块后，进入 BusinessProcessFilter</p>
</li>
<li><p>BusinessProcessFilter 中会根据客户端传递来的服务信息和参数，通过反射调用相应的业务服务并拿到业务处理结果。然后在 WriteResponseProcessFilter 中将返回结果写入 Channel</p>
</li>
<li><p>返回结果再经过服务端的 Pipeline 处理（序列化、压缩等），就发给客户端</p>
</li>
<li><p>客户端收到消息后，经过客户端的 Pipeline 处理（反序列化、解压缩等）后到达 NettyClientHandler,然后交给 ResponseThreadPoolProcessor 线程池处理</p>
</li>
<li><p>ResponseThreadPoolProcessor 收到消息后，会通知之前 await 的业务线程，并将结果传递给他</p>
</li>
<li><p>业务线程收到 signal 通知后，就将结果返回给之前的方法调用</p>
</li>
</ul>
<h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h2 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h2><ul>
<li><p>进程是对运行时程序的封装，是<strong>操作系统进行资源调度和分配的基本单位</strong>，<strong>实现操作系统的并发</strong>。线程是进程的子任务，<strong>CPU调度和分派的基本单位</strong>，用于<strong>保证程序的实时性</strong>，<strong>实现进程内部的并发</strong>；</p>
</li>
<li><p>每个线程都独自占用一个虚拟处理器、独自的寄存器组，指令计数器和处理器状态，完成不同的任务，但是<strong>共享同一地址空间</strong>，<strong>打开的文件队列</strong>和<strong>其他内核资源</strong>；</p>
</li>
<li><p>区别：</p>
<ul>
<li>一个线程只能属于一个进程，一个进程可以有多个线程，线程依赖于进程而存在</li>
<li>进程切换开销大，在创建或撤消进程时，系统都要为之分配或回收资源。线程切换只须保存和设置少量寄存器的内容，切换速度快，同一个进程的线程都具有同一个页表，那么在切换的时候不需要切换页表。</li>
<li>进程间通信复杂。同一进程中的多个线程具有相同的地址空间，通信比较容易，例如可以使用<strong>全局变量</strong></li>
<li>进程间不会相互影响，一个线程挂掉会导致整个进程挂掉</li>
</ul>
</li>
</ul>
<h2 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h2><ul>
<li>创建状态：进程正在被创建；</li>
<li>就绪状态：进程被加入到就绪队列中等待CPU调度运行；</li>
<li>执行状态：进程正在被运行；</li>
<li>等待阻塞状态：进程因为某种原因，比如等待I/O，等待设备，而暂时不能运行；</li>
<li>终止状态：进程运行完毕；</li>
</ul>
<h2 id="进程通信方式"><a href="#进程通信方式" class="headerlink" title="进程通信方式"></a>进程通信方式</h2><ul>
<li><p>匿名管道：本质是内核缓冲区，可用于亲缘进程（父子进程，兄弟进程）间通信，半双工，一端读、一端写，先进先出；</p>
</li>
<li><p>有名管道：本质是一个文件，可以提供给没有亲缘关系的进程通信；</p>
</li>
<li><p>消息队列：存放于内核的某个消息链表，允许多个进程进行读写；</p>
</li>
<li><p>套接字：套接字主要用于不同主机的进程之间的通信；</p>
</li>
<li><p>信号：一种异步通信方式，信号可以在任何时候发给某一进程；</p>
</li>
<li><p>信号量：信号量是一个计数器，<strong>原子的P、V操作</strong>，用于进程同步；</p>
</li>
<li><p>共享内存：多个进程可以直接读写同一块内存空间，共享内存如果中间涉及到写操作，往往需要同步机制进行辅助，比如信号量；</p>
</li>
<li><p>线程间通信方式：临界区，互斥量（锁），信号量，信号</p>
</li>
</ul>
<h2 id="单核机器上写多线程程序，是否需要考虑加锁，为什么？"><a href="#单核机器上写多线程程序，是否需要考虑加锁，为什么？" class="headerlink" title="单核机器上写多线程程序，是否需要考虑加锁，为什么？"></a>单核机器上写多线程程序，是否需要考虑加锁，为什么？</h2><ul>
<li>仍然需要线程锁，因为线程锁通常用来实现线程的同步和通信，在单核机器上的多线程程序，<strong>仍然存在线程同步的问题</strong>。因为在<strong>抢占式操作系统中</strong>，通常为每个线程分配一个时间片，当某个线程时间片耗尽时，操作系统会将其挂起，然后运行另一个线程，（如果这两个线程共享某些数据，不使用线程锁的前提下，可能会导致共享数据修改引起冲突）</li>
</ul>
<h2 id="协程（微线程，极高的运行效率，没有线程切换开销、没有锁机制开销）"><a href="#协程（微线程，极高的运行效率，没有线程切换开销、没有锁机制开销）" class="headerlink" title="协程（微线程，极高的运行效率，没有线程切换开销、没有锁机制开销）"></a>协程（微线程，极高的运行效率，没有线程切换开销、没有锁机制开销）</h2><ul>
<li><p>协程看上去也是子程序，<strong>但内部可中断</strong>，然后转而执行别的子程序，在适当的时候再返回来接着执行；</p>
</li>
<li><p>协程和线程区别，<strong>协程有极高的运行效率，没有线程切换开销、没有锁机制开销</strong></p>
<ul>
<li>和多线程比，协程最大的优势就是<strong>没有线程切换的开销</strong>，线程数量越多，协程的性能优势就越明显；</li>
<li><strong>没有锁机制的开销（只需判断状态）</strong>，因为只有一个线程，不存在同时写变量冲突；</li>
</ul>
</li>
</ul>
<h2 id="进程调度策略"><a href="#进程调度策略" class="headerlink" title="进程调度策略"></a>进程调度策略</h2><ul>
<li>先来先服务：可能会导致阻塞</li>
<li>最短作业优先调度：提高吞吐量，但是长任务可能无法被调度</li>
<li>高相应比优先调度：根据公式计算相应比，等待时间/要求服务的时间，要求服务的时间不可预知，不实用</li>
<li>时间片轮转：每个进程使用固定长度的CPU时间。时间设置太低，进程切换频繁，效率低；时间片太大，短作业的响应时间变长</li>
<li>最高优先级调度: 可能导致低优先级作业无法被调度</li>
<li>多级反馈队列调度：多个队列之间是最高优先级调度；单个队列里面是时间片轮转</li>
</ul>
<h2 id="内存页面置换算法"><a href="#内存页面置换算法" class="headerlink" title="内存页面置换算法"></a>内存页面置换算法</h2><ul>
<li>最佳页面置换算法：替换掉未来最长时间不访问的页面。但无法预测未来情况，只是一种理想算法</li>
<li>先进先出置换算法</li>
<li>最近最久未使用置换算法（LRU）：选择最近最长时间没有被访问过的页面进行置换。需要在内存中维护一个所有页面的链表，实现难度大。</li>
<li>时钟页面置换算法：类似于LRU和FIFO的结合。所有页面保存在类似钟面的环形链表，缺页中断时判断表针指向页面，<strong>若页面R位为0</strong>，则选择此页面进行置换；<strong>否则R=1</strong>，清除R位直到找到R=0的页面为止；</li>
<li>最近最少使用置换算法（LFU）：<strong>选择「访问次数」最少的那个页面，并将其淘汰</strong>。使用计数器，记录每个页面被访问次数</li>
</ul>
<h2 id="IO模型"><a href="#IO模型" class="headerlink" title="IO模型"></a>IO模型</h2><ul>
<li>阻塞IO：调用者调用一个函数，需要等待这个函数返回之后，才可以继续进行操作</li>
<li>非阻塞IO：每隔一段时间区检测IO事件，检测间隙可以继续操作</li>
<li>信号驱动IO：运行端准备好数据，给调用端一个信号，调用端接收数据，不需要频繁检测</li>
<li>多路复用IO：不需要尝试获取数据，而是先开启另外一个线程来监控数据的状态，等到有数据的时候再同步获取数据，而在没数据的时候也是不需要等待的</li>
<li>异步IO：通过调用aio_read函数，那么内核会先将数据读取好，并且复制到用户空间之后，再执行回调函数通知应用程序，此时应用程序就可以直接从用户空间中读取数据，而不需要再从内核中读取数据</li>
</ul>
<h2 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h2><p><img src="/2022/01/03/day29/day29_37.png" alt="上下文切换对比"></p>
<h2 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a>零拷贝</h2><ul>
<li><p>最原始数据拷贝过程：整个过程都需要CPU参与</p>
<p><img src="/2022/01/03/day29/day29_38.png" alt="原始过程"></p>
</li>
<li><p>DMA：在IO设备和内存之间搬运数据，不需要CPU参与</p>
<p><img src="/2022/01/03/day29/day29_39.png" alt="DMA"></p>
<p><img src="/2022/01/03/day29/day29_40.png" alt="传统数据拷贝"></p>
</li>
<li><p>零拷贝</p>
<ul>
<li><p>mmap+write：<code>mmap()</code> 系统调用函数会直接把内核缓冲区里的数据<strong>映射</strong>到用户空间，这样，操作系统内核与用户空间就不需要再进行任何的数据拷贝操作。<strong>仍然有4次上下文切换</strong></p>
<ul>
<li>应用进程调用了 <code>mmap()</code> 后，DMA 会把磁盘的数据拷贝到内核的缓冲区里。接着，应用进程跟操作系统内核「共享」这个缓冲区；</li>
<li>应用进程再调用 <code>write()</code>，操作系统直接将内核缓冲区的数据拷贝到 socket 缓冲区中，这一切都发生在内核态，由 CPU 来搬运数据；</li>
<li>最后，把内核的 socket 缓冲区里的数据，拷贝到网卡的缓冲区里，这个过程是由 DMA 搬运的</li>
</ul>
<p><img src="/2022/01/03/day29/day29_41.png" alt="mmap+write"></p>
</li>
<li><p>sendfile：一次系统调用，2次上下文切换，3次数据拷贝</p>
<ul>
<li>如果网卡支持SG-DMA技术，可以缩减为2次数据拷贝</li>
</ul>
<p><img src="/2022/01/03/day29/day29_42.png" alt="sendfile"></p>
</li>
</ul>
<p><img src="/2022/01/03/day29/day29_43.png" alt="SG-DMA"></p>
</li>
</ul>
<h2 id="Select-poll-epoll"><a href="#Select-poll-epoll" class="headerlink" title="Select/poll/epoll"></a>Select/poll/epoll</h2><ul>
<li>select：注册事件数量有限制<ul>
<li>从用户空间拷贝fd_set（注册的事件集合）到内核空间</li>
<li>遍历所有fd文件，并将当前进程挂到每个fd的等待队列中，当某个fd文件设备收到消息后，会唤醒设备等待队列上睡眠的进程，那么当前进程就会被唤醒</li>
<li>如果遍历完所有的fd没有I/O事件，则当前进程进入睡眠，当有某个fd文件有I/O事件或当前进程睡眠超时后，当前进程重新唤醒再次遍历所有fd文件</li>
</ul>
</li>
<li>poll：和select类似，但使用链表存储注册事件，数量无限制</li>
<li>epoll：采用的是事件驱动机制，每个fd上有注册有回调函数，当网卡接收到数据时会回调该函数，同时将该fd的引用放入<strong>rdlist就绪列表</strong>中。调用<strong>epoll_wait</strong>检查是否有事件发生时，只需要检查eventpoll对象中的rdlist双链表中是否有epitem元素即可。如果rdlist不为空，则把发生的事件复制到用户态，同时将事件数量返回给用户。</li>
</ul>
<h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h2 id="七层结构、四层结构"><a href="#七层结构、四层结构" class="headerlink" title="七层结构、四层结构"></a>七层结构、四层结构</h2><p><img src="/2022/01/03/day29/day29_46.png" alt="七层结构"></p>
<p><img src="/2022/01/03/day29/day29_47.png" alt="四层结构"></p>
<h2 id="输入网址到页面显示整个过程"><a href="#输入网址到页面显示整个过程" class="headerlink" title="输入网址到页面显示整个过程"></a>输入网址到页面显示整个过程</h2><p><img src="/2022/01/03/day29/day29_48.png" alt="网址解析"></p>
<ul>
<li><p>首先查看浏览器缓存，如果缓存中有该URL对应的资源，且没有过期，直接显示页面。</p>
</li>
<li><p>解析URL，生成发送给服务器的HTTP请求信息。确定Web服务器和文件名</p>
<p><img src="/2022/01/03/day29/day29_49.png" alt="URL组成"></p>
</li>
</ul>
<p><img src="/2022/01/03/day29/day29_50.png" alt="HTTP消息格式"></p>
<ul>
<li>DNS查询，查询服务器域名对应的IP地址。DNS查询步骤<ul>
<li>首先查看浏览器缓存是否有相应数据</li>
<li>问根域名服务器，根域名服务器会告诉本地DNS应该去哪个顶级域名服务器查询</li>
<li>顶级域名服务器，他会告诉本地域名服务器应该去哪个权威域名服务器查询</li>
<li>权威域名服务器解析域名对应的IP</li>
</ul>
</li>
<li>建立于目标主机的TCP连接</li>
<li>发送HTTP请求（将报文在TCP/IP架构中向下传递并层层封装）</li>
<li>服务器处理HTTP请求并返回响应HTTP报文（将报文在TCP/IP架构中向上传递并层层解封装）</li>
<li>浏览器解析渲染页面</li>
<li>当不需要连接后断开TCP连接（四次挥手）</li>
</ul>
<h2 id="TCP和UDP区别"><a href="#TCP和UDP区别" class="headerlink" title="TCP和UDP区别"></a>TCP和UDP区别</h2><ul>
<li><p>连接不同：tcp是面向连接的，传输数据前要先建立连接；udp是不需要连接的即刻传输数据。</p>
</li>
<li><p>服务对象：tcp只支持一对一的数据传输；udp支持一对一、一对多、多对多的通信。</p>
</li>
<li><p>可靠性方面：tcp是提供可靠交付的，数据可以无差错、不丢失、不重复的按需到达；udp是尽最大努力交付，不保证可靠交付。</p>
</li>
<li><p>拥塞控制和流量控制方面：tcp有拥塞控制和流量控制，能保证数据的安全性；但udp没有，即使网络非常拥堵了也不会影响udp的发送速率。</p>
</li>
<li><p>首部开销方面：tcp首部长度较长，开销会稍大一些，在没有使用选项字段时是20字节，使用了会更多；udp的是首部只有8字节，是固定不变的。开销较小。</p>
</li>
<li><p>传输方式方面：tcp是流式传输，没有边界，但保证顺序可靠；udp是一个包一个包的发送，有边界，但可能会丢包和乱序。</p>
</li>
<li><p>分片方式方面：tcp的数据大小如果大于MSS，会在传输层进行分片，目的主机收到后，在传输层组装tcp数据包，如果中途丢失了一个分片，子需要传输丢失的分片；udp的数据大小如果大于MTU会在网络层分片，目的主机收到后在网络层组装完数据向上层传输，如果丢失分片，则需要重传所有数据包，所以一般udp传输的报文数据应该小于MTU。</p>
<p><img src="/2022/01/03/day29/day29_52.png" alt="UDP头部格式"></p>
</li>
</ul>
<p><img src="/2022/01/03/day29/day29_51.png" alt="TCP头部格式"></p>
<h2 id="TCP三次握手，四次挥手"><a href="#TCP三次握手，四次挥手" class="headerlink" title="TCP三次握手，四次挥手"></a>TCP三次握手，四次挥手</h2><p><img src="/2022/01/03/day29/day29_53.png" alt="三次握手"></p>
<p><img src="/2022/01/03/day29/day29_54.png" alt="4次挥手"></p>
<h2 id="为什么是三次握手"><a href="#为什么是三次握手" class="headerlink" title="为什么是三次握手"></a>为什么是三次握手</h2><ul>
<li><strong>避免历史连接</strong>：由于网络延迟，旧的syn报文比新的syn报文提前到达服务端。如果是三次握手，在第三次时客户端会给服务端发送rst报文终止连接，而两次握手没办法做到</li>
<li>同步双方序列号</li>
<li>三次握手可以解决，不需要更多次握手浪费资源</li>
</ul>
<h2 id="SYN攻击"><a href="#SYN攻击" class="headerlink" title="SYN攻击"></a>SYN攻击</h2><ul>
<li>攻击者短时间内伪造不同的IP地址，向服务器发送SYN报文，让服务器接受以为有正常的连接，会在SYN接收队列中记录并回复应答报文，但没有后续，直到将服务器的SYN接收队列占满，真正正常的用户无法连接服务器</li>
<li>可以增大SYN接受队列的长度、减少SYN+ACK重传次数</li>
</ul>
<h2 id="为什么四次挥手"><a href="#为什么四次挥手" class="headerlink" title="为什么四次挥手"></a>为什么四次挥手</h2><ul>
<li>因为需要双方都处理完数据之后才能关闭连接，因此需要双方都主动发送FIN报文，并接收到对方回应</li>
</ul>
<h2 id="为什么TIME-WAIT等待时间为2MSL"><a href="#为什么TIME-WAIT等待时间为2MSL" class="headerlink" title="为什么TIME_WAIT等待时间为2MSL"></a>为什么TIME_WAIT等待时间为2MSL</h2><ul>
<li>如果第四次挥手ACK报文丢失，服务端没有断开连接，服务端会重发FIN报文，所以客户端在发送完ACK报文后需要等待。2MSL正好是允许报文丢失一次的时间</li>
</ul>
<h2 id="TCP保证可靠传输"><a href="#TCP保证可靠传输" class="headerlink" title="TCP保证可靠传输"></a>TCP保证可靠传输</h2><ul>
<li><p>重传机制：根据序列号和确认应答号，判断是否收到数据包。<strong>重传解决数据包丢失情况</strong></p>
<ul>
<li>超时重传：数据包丢失；确认应答丢失。<strong>超时重传时间应该略大于报文往返时间RTT</strong>。每遇到超时重传，会把下次超时时间翻倍，两次超时后，不再进行重传</li>
<li>快速重传：连续收到3次相同的ACK，说明中间有包丢失，进行重传。解决了超时时间设置问题。但不知道重传哪几个报文</li>
<li>SACK：选择性确认。在TCP头部字段中加入SACK，将已接受到的数据发送给发送方，发送方就知道重传哪些报文</li>
<li>D-SACK：有哪些数据被重复接受了。可以判断到底是，数据包丢失或ACK丢失或网络延迟</li>
</ul>
</li>
<li><p>滑动窗口：窗口大小（字节数）就是指<strong>无需等待确认应答，而可以继续发送数据长度的最大值</strong>。TCP头部的Window字段就是窗口大小，一般由接收方决定。</p>
</li>
<li><p>流量控制：根据接收方的接受能力控制发送数据量。</p>
<ul>
<li>接收端没有及时处理缓冲区的数据，导致接收窗口变小，发送窗口也变小</li>
<li>窗口大小为0后，发送方无法给接受方发送数据。发送方隔一段时间，会向接收方发送窗口探测报文</li>
</ul>
</li>
<li><p>拥塞控制：在网络拥挤的情况下，避免发送的数据填满整个网络。<strong>拥塞窗口，根据网络情况动态改变的窗口大小，发送窗口最终的值为拥塞窗口和流量控制窗口的最小值</strong></p>
<ul>
<li>慢启动：刚开始拥塞窗口大小成指数型增强：1，2，4…..</li>
<li>拥塞避免：当窗口大小超过thresh阈值后，拥塞窗口大小成线性增长，每收到一个ACK增加<strong>1/窗口大小</strong>，接收到一整个窗口ACK，增加1</li>
<li>拥塞发生：触发重传机制。<strong>超时重传</strong>后，拥塞窗口值直接变为1，thresh阈值为原来的1/2。<strong>快速重传</strong>后，拥塞窗口的值变为原来的1/2，阈值不变</li>
<li>快速恢复：在快速重传后使用，拥塞窗口变为thresh+3，重传数据包，如果收到重复的ACK，拥塞窗口值+1。收到新的ACK后，恢复过程结束，窗口大小变为thresh阈值</li>
</ul>
<p><img src="/2022/01/03/day29/day29_55.png" alt="拥塞控制"></p>
</li>
</ul>
<h2 id="TCP半连接和全连接队列"><a href="#TCP半连接和全连接队列" class="headerlink" title="TCP半连接和全连接队列"></a>TCP半连接和全连接队列</h2><ul>
<li>服务端收到客户端发起的 SYN 请求后，<strong>内核会把该连接存储到半连接队列</strong>，并向客户端响应 SYN+ACK，接着客户端会返回 ACK，服务端收到第三次握手的 ACK 后，<strong>内核会把连接从半连接队列移除，然后创建新的完全的连接，并将其添加到 accept 队列，等待进程调用 accept 函数时把连接取出来。</strong></li>
</ul>
<h2 id="HTTP和HTTPS区别"><a href="#HTTP和HTTPS区别" class="headerlink" title="HTTP和HTTPS区别"></a>HTTP和HTTPS区别</h2><ul>
<li>HTTP是明文传输，存在安全风险。HTTPS对传输数据进行加密，更加安全</li>
<li>HTTP连接建立只需要TCP三次握手，而HTTPS还需要进行SSL/TLS握手</li>
<li>HTTP端口号为80，HTTPS为443</li>
<li>HTTPS需要向CA申请数字证书，证明服务器的身份</li>
</ul>
<h2 id="常见状态码"><a href="#常见状态码" class="headerlink" title="常见状态码"></a>常见状态码</h2><ul>
<li><code>1xx</code> 类状态码属于<strong>提示信息</strong>，是协议处理中的一种中间状态，实际用到的比较少</li>
<li><code>2xx</code> 类状态码表示服务器<strong>成功</strong>处理了客户端的请求，也是我们最愿意看到的状态<ul>
<li>200：一切正常</li>
</ul>
</li>
<li><code>3xx</code> 类状态码表示客户端请求的资源发生了变动，需要客户端用新的 URL 重新发送请求获取资源，也就是<strong>重定向</strong><ul>
<li>301：永久重定向</li>
<li>302：临时重定向</li>
<li>304：重定向存在缓存文件</li>
</ul>
</li>
<li><code>4xx</code> 类状态码表示客户端发送的<strong>报文有误</strong>，服务器无法处理，也就是错误码的含义<ul>
<li>400：表示客户端请求的报文有错误</li>
<li>403：服务器禁止访问资源</li>
<li>404：请求资源不存在或找不到</li>
</ul>
</li>
<li><code>5xx</code> 类状态码表示客户端请求报文正确，但是<strong>服务器处理时内部发生了错误</strong>，属于服务器端的错误码<ul>
<li>500：服务端有错误</li>
<li>501：客户端请求功能还不支持</li>
<li>503：服务器很忙，无法响应</li>
</ul>
</li>
</ul>
<h2 id="GET和POST区别"><a href="#GET和POST区别" class="headerlink" title="GET和POST区别"></a>GET和POST区别</h2><ul>
<li>GET是从服务器获得指定资源，POST是请求对指定资源做相应的处理</li>
<li>GET的请求参数一般在URL中，浏览器会对URL长度有限制，POST数据在报文body中</li>
</ul>
<h2 id="Cookie和Session区别"><a href="#Cookie和Session区别" class="headerlink" title="Cookie和Session区别"></a>Cookie和Session区别</h2><ul>
<li>Cookie一般用来保存用户信息（登录信息，在cookie中放入token）。Session主要在服务端记录用户状态（添加购物车，使用session表明用户身份）</li>
<li>Cookie 数据保存在客户端(浏览器端)，Session 数据保存在服务器端</li>
</ul>
<h2 id="HTTPS建立连接过程"><a href="#HTTPS建立连接过程" class="headerlink" title="HTTPS建立连接过程"></a>HTTPS建立连接过程</h2><ul>
<li>ClientHello：由客户端向服务器发起加密通信请求，包含了SSL协议版本、客户端随机数C、支持的密码套件</li>
<li>SeverHello：确认SSL协议版本、服务端随机数S、确认采用的密码套件、CA证书</li>
<li>客户端回应<ul>
<li>首先通过浏览器或操作系统中的CA公钥，验证服务器身份</li>
<li>从数字证书中取出<strong>服务器公钥</strong>，使用它加密报文：随机数pre-master、之前数据的摘要。之后都采用加密传输</li>
</ul>
</li>
<li>服务器回应<ul>
<li>根据pre-master、C、S计算出后续数据传输的密钥</li>
<li>将之前的信息摘要，通过密钥加密后发送给客户端</li>
</ul>
</li>
</ul>
<h2 id="CA证书验证过程"><a href="#CA证书验证过程" class="headerlink" title="CA证书验证过程"></a>CA证书验证过程</h2><ul>
<li>CA 签发证书的过程：<ul>
<li>首先 CA 会把持有者的公钥、用途、颁发者、有效时间等信息打成一个包，然后对这些信息进行 Hash 计算，得到一个 Hash 值；</li>
<li>然后 CA 会使用自己的私钥将该 Hash 值加密，生成 Certificate Signature，也就是 CA 对证书做了签名；</li>
<li>最后将 Certificate Signature 添加在文件证书上，形成数字证书</li>
</ul>
</li>
<li>客户端校验服务端的数字证书的过程：<ul>
<li>首先客户端会使用同样的 Hash 算法获取该证书的 Hash 值 H1；</li>
<li>通常浏览器和操作系统中集成了 CA 的公钥信息，浏览器收到证书后可以使用 CA 的公钥解密 Certificate Signature 内容，得到一个 Hash 值 H2 ；</li>
<li>最后比较 H1 和 H2，如果值相同，则为可信赖的证书，否则则认为证书不可信。</li>
</ul>
</li>
</ul>
<h2 id="HTTP1-1"><a href="#HTTP1-1" class="headerlink" title="HTTP1.1"></a>HTTP1.1</h2><ul>
<li>简单：基本报文格式header+body，头部信息key-value的形式，容易理解</li>
<li>灵活易扩展：状态码、头字段等都没有固定死，允许开发人员自定义</li>
<li>应用广泛跨平台</li>
<li>长连接：没有主动断开连接，就不断开连接。超过一定的时间，断开连接</li>
<li>无状态</li>
<li>明文传输不安全</li>
<li>管道网络传输：可以同时发起多个请求，解决了请求的队头阻塞问题。但响应需要按顺序接受，响应存在对头阻塞问题</li>
</ul>
<h2 id="HTTP2基于HTTPS"><a href="#HTTP2基于HTTPS" class="headerlink" title="HTTP2基于HTTPS"></a>HTTP2基于HTTPS</h2><ul>
<li>头部压缩：同时发出多个请求，如果头部信息相同，会消除重复部分。<code>HPACK</code>,维护一张头信息表</li>
<li>二进制格式：头信息和数据体都是二进制格式</li>
<li>并发传输：提出了Stream概念，多个Stream复用同一个TCP。不同的请求具有不同的streamID</li>
</ul>
<h2 id="HTTP和RPC"><a href="#HTTP和RPC" class="headerlink" title="HTTP和RPC"></a>HTTP和RPC</h2><ul>
<li>HTTP和RPC都是协议，底层都可以基于TCP或UDP进行实现，只是定义了不同消息格式的应用层协议</li>
<li>RPC要比HTTP1.1效率更高</li>
<li>RPC实现服务调用时，需要双方都使用统一的RPC框架，跨操作系统，同一编程语言。HTTP不需要关注对方使用的编程语言，通用性灵活度更强</li>
</ul>
<h1 id="多线程编程"><a href="#多线程编程" class="headerlink" title="多线程编程"></a>多线程编程</h1><h2 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Semaphore fooSema = <span class="keyword">new</span> Semaphore(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">private</span> Semaphore barSema = <span class="keyword">new</span> Semaphore(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">fooSema.acquire(); <span class="comment">//获得</span></span><br><span class="line">barSema.release(); <span class="comment">//释放</span></span><br></pre></td></tr></table></figure>

<h2 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> CyclicBarrier cb = <span class="keyword">new</span> CyclicBarrier(<span class="number">2</span>); <span class="comment">//两个线程到达后，放行</span></span><br><span class="line"></span><br><span class="line">cb.await(); <span class="comment">//线程到达</span></span><br></pre></td></tr></table></figure>

<h2 id="Thread-yield"><a href="#Thread-yield" class="headerlink" title="Thread.yield()"></a>Thread.yield()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Thread.yield() <span class="comment">//从执行态变为就绪态</span></span><br></pre></td></tr></table></figure>

<h2 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> BlockingQueue&lt;Integer&gt; fooQueue = <span class="keyword">new</span> LinkedBlockingQueue&lt;Integer&gt;() &#123;&#123;</span><br><span class="line">        add(<span class="number">0</span>);</span><br><span class="line">    &#125;&#125;;</span><br><span class="line"><span class="keyword">private</span> BlockingQueue&lt;Integer&gt; barQueue = <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;();</span><br><span class="line"></span><br><span class="line">fooQueue.take();<span class="comment">//取元素</span></span><br><span class="line">barQueue.add();<span class="comment">//添加元素</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Object lock = <span class="keyword">new</span> Object();<span class="comment">//对象锁</span></span><br><span class="line"><span class="keyword">synchronized</span>(lock)&#123;</span><br><span class="line">    <span class="keyword">while</span>(condition)&#123;</span><br><span class="line">       lock.await();<span class="comment">//等待 </span></span><br><span class="line">    &#125;</span><br><span class="line">	lock.notifyAll();<span class="comment">//唤醒其他线程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="系统设计"><a href="#系统设计" class="headerlink" title="系统设计"></a>系统设计</h1><h2 id="高可用、高并发、高性能系统设计"><a href="#高可用、高并发、高性能系统设计" class="headerlink" title="高可用、高并发、高性能系统设计"></a>高可用、高并发、高性能系统设计</h2><ul>
<li>冗余：消除单点，负载均衡<ul>
<li>首先拆分整个系统，分成多个微服务，形成<strong>隔离</strong>，单个微服务挂掉不影响其他服务</li>
<li>消除单点：数据库成是单点，我们的手段有：主-备，主-备-从，分库，分表，分库分表，冗余数据的同时，数据的的“读”、“写”能力也在提升。缓存层，拿主流的redis来讲，主从、哨兵模式、cluster等都是其冗余手段；</li>
<li>负载均衡：冗余的点分担流量。制定降级策略，当下级某个机器挂掉，就停止调用，将流量分配给其他机器，或者停止服务</li>
</ul>
</li>
<li>取舍：冗余会导致加机器，但是也不能无限加机器，成本会很高<ul>
<li>限流：保证系统不过载，在压测时确定</li>
<li>重试：服务调用失败时可以重试，但不能一直重试，例如系统崩溃、系统升级等</li>
<li>熔断机制：防止应用程序不断地尝试执行可能会失败的操作，例如设置重试次数、超时时间等</li>
<li>降级：解决资源不足或访问量过大问题。无法调用相应的服务，简化操作步骤或流程，或者本地简单处理。</li>
</ul>
</li>
</ul>
<h2 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h2><h3 id="设计理念"><a href="#设计理念" class="headerlink" title="设计理念"></a>设计理念</h3><ul>
<li>中心化设计：分为主和从，强烈依赖与主节点<ul>
<li>主节点正常响应问题，采用主备方案解决</li>
<li>主节点性能瓶颈，影响请求分发</li>
</ul>
</li>
<li>去中心化：由节点自由选择中心<ul>
<li>问题：脑裂问题，由于网络故障，整体被分为两个独立的个体，会产生数据冲突和错误</li>
<li>方案：较小的个体自杀或拒绝服务</li>
</ul>
</li>
</ul>
<h3 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h3><ul>
<li><p>XA规范：实现分布式事务系统的概念模型</p>
<ul>
<li>AP：application program，应用程序，定义了事务的边界，以及指定了组成一个事务的行为，可以理解为就是事务发起的某个微服务</li>
<li>RMs：resource managers，资源管理器，可以理解为分布式数据库中的每一个数据实例</li>
<li>TM：transaction manager，事务管理器，负责协调管理事务，控制全局事务</li>
</ul>
</li>
<li><p>TM和RM之间实现事务的完成和回滚，使用<strong>2PC协议</strong></p>
</li>
<li><p><strong>CAP理论：</strong></p>
<ul>
<li>强一致性（Consistency）：系统在执行过某项操作后仍然处于一致的状态。在分布式系统中，更新操作执行成功后所有的用户都应该读到最新的值，这样的系统被认为是具有强一致性的</li>
<li>可用性（Availability）：每一个操作都能在一定的时间内返回结果</li>
<li>分区容错性（Partition Tolerance）：存在网络分区的情况下，仍然可以接受请求（满足CA）。网络分区是指由于某种原因，网络被分为多个单独个体，个体之间互不相通</li>
</ul>
<blockquote>
<p>实际情况中很难同时兼顾CAP</p>
<ol>
<li>放弃可用性（CP）：意味着我们将假设一旦网络发生分区，节点之间的信息同步时间可以无限制地延长，此时，问题相当于退化到前面“全局事务”中一个系统使用多个数据源的场景之中，我们可以通过 2PC/3PC 等手段，同时获得分区容忍性和一致性。<strong>一般用于对数据质量要求很高的场合中</strong></li>
<li>放弃一致性（AP）：意味着我们将假设一旦发生分区，节点之间所提供的数据可能不一致。AP系统目前主流选择，因为P是分布式特性，无法丢弃，A是我们构建分布式系统的目标。</li>
</ol>
</blockquote>
</li>
<li><p><strong>刚性事务</strong>：遵循ACID原则，强一致性。<strong>2PC</strong> 和 <strong>3PC</strong> 都是一种在分布式环境中仍追求强一致性的事务处理方案，对于多节点而且互相调用彼此服务的场合（微服务系统）是极不合适的，今天它几乎只实际应用于单服务多数据源的场合中</p>
<ul>
<li><p>2PC（两阶段提交）：协调者（TM），参与者（RM）</p>
<ul>
<li>第一阶段：当要执行一个分布式事务的时候，事务发起者首先向协调者发起事务请求，然后协调者会给所有参与者发送 prepare 请求（其中包括事务内容）告诉参与者需要执行事务。如果能执行发送的事务内容那么就先执行但不提交，执行后回复。参与者收到 prepare 消息后，他们会开始执行事务（但不提交），并将 <strong>Undo 和 Redo 信息记入事务日志</strong>中，之后参与者就向协调者反馈是否准备好了。</li>
<li>第二阶段：提交事务或者回滚事务。比如这个时候 所有的参与者 都返回了准备好了的消息，这个时候就进行事务的提交，协调者此时会给所有的参与者发送 Commit 请求 ，当参与者收到 Commit 请求的时候会执行前面执行的事务的提交操作 ，提交完毕之后将给协调者发送提交成功的响应。<br>如果<strong>在第一阶段有参与者返回了未准备好的消息</strong>，那么此时协调者将会给所有参与者发送 回滚事务的 rollback 请求，参与者收到之后将会 回滚它在第一阶段所做的事务处理。</li>
<li><strong>问题</strong>：<ul>
<li>单点故障：协调者挂掉，整个事务不可用。参与者等待协调者指令时无法超时处理</li>
<li>性能问题：prepare后，参与者只会执行事务，但不提交，会一直占用资源。<strong>最主要问题</strong></li>
<li>数据不一致：协调者在第二阶段宕机，只给部分参与者发送了commit。脑裂情况</li>
<li>网络传输导致空回滚和资源悬挂：没收到prepare，但收到了rollback；prepare由于延迟，导致先收到了rollback，后续又收到了prepare</li>
</ul>
</li>
</ul>
<p><img src="/2022/01/03/day29/day29_44.png" alt="2PC"></p>
</li>
<li><p>3PC（三阶段提交）</p>
<ul>
<li><p>CanCommit阶段：协调者向所有参与者发送 CanCommit 请求，参与者收到请求后会根据自身情况查看是否能执行事务，如果可以则返回 YES 响应并进入预备状态，否则返回 NO 。</p>
</li>
<li><p>PreCommit阶段：协调者根据参与者返回的响应来决定是否可以进行下面的 PreCommit 操作。</p>
<ul>
<li>如果上面参与者都返回 YES，那么协调者将向所有参与者发送 PreCommit 预提交请求，参与者收到预提交请求后，会进行事务的执行操作，并将 Undo 和 Redo 信息写入事务日志中 ，最后如果参与者顺利执行了事务则给协调者返回成功的响应。</li>
<li>如果在第一阶段协调者收到了 任何一个 NO 的信息，或者 在一定时间内 并没有收到全部的参与者的响应，那么就会中断事务，它会向所有参与者发送中断请求（abort）</li>
</ul>
</li>
<li><p>DoCommit阶段：如果协调者收到了所有参与者在 PreCommit 阶段的 YES 响应，那么协调者将会给所有参与者发送 DoCommit 请求，<strong>参与者收到 DoCommit 请求后则会进行事务的提交工作</strong>，完成后则会给协调者返回响应，协调者收到所有参与者返回的事务提交成功的响应之后则完成事务。若协调者在 PreCommit 阶段 收到了任何一个 NO 或者在一定时间内没有收到所有参与者的响应 ，那么就会进行中断请求的发送，参与者收到中断请求后则会 <strong>通过上面记录的回滚日志 来进行事务的回滚操作，并向协调者反馈回滚状况，协调者收到参与者返回的消息后，中断事务</strong>。</p>
<p><img src="/2022/01/03/day29/day29_45.png" alt="3PC"></p>
</li>
<li><p>总结：3PC加入的超时机制缓解了阻塞问题</p>
</li>
<li><p>缺点：无法解决网络分区问题；没有解决2PC性能差的问题，增加一个阶段，导致性能更差</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>柔性事务</strong>：遵循BASE理论，最终一致性；与刚性事务不同，柔性事务<strong>允许一定时间内，不同节点的数据不一致，但要求最终一致</strong>。</p>
<ul>
<li><p>BASE </p>
<ul>
<li>Basically Available（基本可用） ：分布式系统在出现不可预知故障的时候，允许损失部分可用性。</li>
<li>Soft-state（软状态，柔性事务） ：允许系统中的数据存在中间状态，并认为该中间状态的存在不会影响系统的整体可用性，即允许系统在不同节点的数据副本之间进行数据同步的过程存在延时。</li>
<li>Eventually Consistent（最终一致性）：系统中所有的数据副本，在经过一段时间的同步后，最终能够达到一个一致的状态。</li>
</ul>
</li>
<li><p>实现方案：补偿型和通知型</p>
<ul>
<li><p>补偿型：TCC和Saga</p>
<ul>
<li><p>TCC（Try-Confirm-Cancel）：业务侵入式较强的事务方案，要求业务处理过程必须拆分为“预留业务资源”和“确认/释放消费资源”两个子过程。 具体分为以下三个阶段</p>
<ul>
<li><strong>Try</strong>：尝试执行阶段，完成所有业务可执行性的检查（保障一致性），并且预留好全部需用到的业务资源（保障隔离性）。（购买时，冻结账户余额、冻结库存、生成预收款）</li>
<li><strong>Confirm</strong>：确认执行阶段，不进行任何业务检查，直接使用 Try 阶段准备的资源来完成业务处理。（账务服务扣减余额、仓库扣减库存、商家服务支付首款）</li>
<li><strong>Cancel</strong>：取消执行阶段，释放 Try 阶段预留的业务资源。（操作超时或者操作失败，进行cancel操作，取消资源预留操作）</li>
<li>特定：在业务层实现，几乎不涉及锁和资源的争用，性能高。但是开发和替换成本高</li>
</ul>
</li>
<li><p>Saga：与外部系统交互，无法使用TCC。</p>
<ul>
<li>将整个事务分成多个子事务，Ti，每个子事务都是原子的，而且有对应的补偿事务Ci</li>
<li>理想情况下，所有Ti都执行成功。否则进行恢复<ul>
<li>前向恢复：重复失败的子事务，直到成功。这种情况不需要Ci</li>
<li>反向恢复：对所有已完成事务进行回滚</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="领域驱动设计"><a href="#领域驱动设计" class="headerlink" title="领域驱动设计"></a>领域驱动设计</h2><ul>
<li>领域驱动指的是以领域作为解决问题切入点，面对业务需求，先提炼出领域概念，并构建领域模型来表达业务问题，而构建过程中我们应该尽可能避免牵扯技术方案或技术细节。而编码实现更像是对领域模型的代码翻译，代码（变量名、方法名、类名等）中要求能够表达领域概念，让人见码明义。</li>
<li><strong>思维模式转变</strong>：实践 DDD 以前，<strong>最常使用的是数据驱动设计</strong>。它的核心思路针对业务需求进行数据建模：<strong>根据业务需求提炼出类</strong>，然后把类映射为表结构，并根据读写性能要求使用范式优化表与表之间的关联关系。数据驱动是从技术的维度解决业务问题，得出的<strong>数据模型是对业务需求的直接翻译</strong>，并没有蕴含稳定的领域知识/规则。一旦需求发生变化，数据模型就得发生变化，对应的库表的设计也需要进行调整。<strong>这种设计思维导致变化从需求穿透到了数据层</strong>，中间并没有稳定的，不易变的层级进行阻隔，最终导致系统响应变化的能力很差。</li>
<li><strong>协同模式转变</strong>：DDD 通过解锁新角色”领域专家”以及模型驱动设计，<strong>有效地降低产品和研发的认知差异</strong>。领域专家是具有丰富行业经验和领域知识储备的人，他们能够在易变的、定制化的需求中提炼出清晰的边界，稳定的、可复用的领域概念和业务规则，并携手产品和研发共同构建出领域模型。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/12/19/day28/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Kaixuan Wang">
      <meta itemprop="description" content="只争朝夕">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Magic">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/12/19/day28/" class="post-title-link" itemprop="url">Redis6</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-12-19 12:55:31" itemprop="dateCreated datePublished" datetime="2021-12-19T12:55:31+08:00">2021-12-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-09-01 23:30:46" itemprop="dateModified" datetime="2022-09-01T23:30:46+08:00">2022-09-01</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="NoSQL"><a href="#NoSQL" class="headerlink" title="NoSQL"></a>NoSQL</h1><ul>
<li><p>用户访问量激增，会给服务器和数据库的压力很大：</p>
<ul>
<li><p>服务器：CPU和内存压力</p>
<p><img src="/2021/12/19/day28/day28_1.png" alt="解决方案"></p>
<ul>
<li>负载均衡可以通过Nginx实现</li>
<li>方案四效果最好，通过NoSQL实现</li>
</ul>
</li>
<li><p>数据库：IO压力</p>
<p><img src="/2021/12/19/day28/day28_2.png" alt="解决方案"></p>
<ul>
<li>将访问频繁的数据添加到缓存数据库中，减少IO压力</li>
</ul>
</li>
</ul>
</li>
<li><p>NoSQL（Not only SQL）数据库：非关系型数据库</p>
<ul>
<li>不依赖业务逻辑，以简单的key-value形式存储</li>
<li>不支持ACID</li>
<li>性能远超SQL</li>
</ul>
</li>
<li><p>适用场景：</p>
<ul>
<li>对数据高并发的读写</li>
<li>海量数据读写</li>
<li>数据可扩展性高</li>
</ul>
</li>
<li><p>行式存储数据库：</p>
<ul>
<li><p>行式数据库</p>
<p><img src="/2021/12/19/day28/day28_3.png" alt="行式数据库"></p>
</li>
<li><p>列式数据库</p>
<p><img src="/2021/12/19/day28/day28_4.png" alt="列式数据库"></p>
</li>
</ul>
</li>
<li><p>图关系型数据库：社会关系、公共交通网络、地图饥网络拓扑</p>
<p><img src="/2021/12/19/day28/day28_5.png" alt="图关系型数据库"></p>
</li>
</ul>
<h1 id="Redis概述"><a href="#Redis概述" class="headerlink" title="Redis概述"></a>Redis概述</h1><ul>
<li><p>特点：</p>
<ul>
<li><p> Redis是一个开源的key-value存储系统</p>
</li>
<li><p>支持存储的value类型相对更多，包括string(字符串)、list(链表)、set(集合)、zset(sorted set –有序集合)和hash（哈希类型）</p>
</li>
<li><p>这些数据类型都支持push/pop、add/remove及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的</p>
</li>
<li><p>Redis支持各种不同方式的排序。</p>
</li>
<li><p>为了保证效率，数据都是缓存在内存中。</p>
</li>
<li><p>Redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件。</p>
</li>
<li><p>实现了master-slave(主从)同步</p>
</li>
</ul>
</li>
<li><p>Redis：单线程+多路I/O复用</p>
<p>  <img src="/2021/12/19/day28/day28_6.png" alt="举例"></p>
<ul>
<li>Redis扮演黄牛角色，当有多个数据请求时，Redis接受所有请求，并单线程处理每个请求，此时每个客户端可以做自己的事情，不会出现阻塞。Redis每处理一个请求，就给相应的客户端响应</li>
</ul>
<blockquote>
<p>Redis与memcached区别：</p>
<ul>
<li>Redis支持多数据类型</li>
<li>Redis支持持久化</li>
<li>Redis是单线程+多路复用，memcached是多线程+锁</li>
</ul>
</blockquote>
</li>
</ul>
<h1 id="常用数据结构"><a href="#常用数据结构" class="headerlink" title="常用数据结构"></a>常用数据结构</h1><h2 id="Key操作"><a href="#Key操作" class="headerlink" title="Key操作"></a>Key操作</h2><ul>
<li><p>keys * ：查看当前库所有key   (匹配：keys *1)</p>
</li>
<li><p>exists key：判断某个key是否存在</p>
</li>
<li><p>type key ：查看你的key是什么类型</p>
</li>
<li><p>del key   ：删除指定的key数据</p>
</li>
<li><p>unlink key ：根据value选择非阻塞删除</p>
<p>​    仅将keys从keyspace元数据中删除，真正的删除会在后续异步操作。</p>
</li>
<li><p>expire key 10  10秒钟：为给定的key设置过期时间</p>
</li>
<li><p>ttl key 查看还有多少秒过期，-1表示永不过期，-2表示已过期</p>
</li>
<li><p>select命令切换数据库</p>
</li>
<li><p>dbsize查看当前数据库的key的数量</p>
</li>
<li><p>flushdb清空当前库</p>
</li>
<li><p>flushall通杀全部库</p>
</li>
</ul>
<h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><ul>
<li><p>二进制安全：意味着Redis的string可以包含任何数据。例如图片或者序列化的对象，都可以再通过解码变为原来的属性。</p>
</li>
<li><p>一个字符串value最多可以是512M</p>
</li>
<li><p>set  &lt;key&gt;&lt;value&gt;添加键值对</p>
<ul>
<li>NX：当数据库中key不存在时，可以将key-value添加数据库</li>
<li>XX：当数据库中key存在时，可以将key-value添加数据库，与NX参数互斥</li>
<li>EX：key的超时秒数</li>
<li>PX：key的超时毫秒数，与EX互斥</li>
</ul>
</li>
<li><p>get  &lt;key&gt;查询对应键值</p>
</li>
<li><p>append  &lt;key&gt;&lt;value&gt;将给定的&lt;value&gt; 追加到原值的末尾</p>
</li>
<li><p>strlen  &lt;key&gt;获得值的长度</p>
</li>
<li><p>setnx  &lt;key&gt;&lt;value&gt;只有在 key 不存在时   设置 key 的值</p>
</li>
<li><p>incr  &lt;key&gt;：将 key 中储存的数字值增1；只能对数字值操作，如果为空，新增值为1</p>
</li>
<li><p>decr  &lt;key&gt;：将 key 中储存的数字值减1</p>
</li>
<li><p>incrby / decrby  &lt;key&gt;&lt;步长&gt;：将 key 中储存的数字值增减。自定义步长。</p>
</li>
<li><p>mset  &lt;key1&gt;&lt;value1&gt;&lt;key2&gt;&lt;value2&gt;  ….. ：同时设置一个或多个 key-value对  </p>
</li>
<li><p>mget  &lt;key1&gt;&lt;key2&gt;&lt;key3&gt; …..：同时获取一个或多个 value  </p>
</li>
<li><p>msetnx &lt;key1&gt;&lt;value1&gt;&lt;key2&gt;&lt;value2&gt;  ….. ：同时设置一个或多个 key-value 对，当且仅当所有给定 key 都不存在</p>
</li>
</ul>
<blockquote>
<p>Redis单命令的原子性，主要是因为Redis的单线程，有一个失败就全部失败</p>
</blockquote>
<ul>
<li>getrange  &lt;key&gt;&lt;起始位置&gt;&lt;结束位置&gt;：获得值的范围，类似java中的substring</li>
<li>setrange  &lt;key&gt;&lt;起始位置&gt;&lt;value&gt;：用 &lt;value&gt;  覆写&lt;key&gt;所储存的字符串值，从&lt;起始位置&gt;开始(索引从0开始)。</li>
<li>setex  &lt;key&gt;&lt;过期时间&gt;&lt;value&gt;：设置键值的同时，设置过期时间，单位秒。</li>
<li>getset &lt;key&gt;&lt;value&gt;：以新换旧，设置了新值同时获得旧值。</li>
</ul>
<h3 id="String-的数据结构"><a href="#String-的数据结构" class="headerlink" title="String 的数据结构"></a>String 的数据结构</h3><ul>
<li><p>String的数据结构为简单动态字符串(Simple Dynamic String,缩写SDS)。内部结构实现上类似于Java的ArrayList，采用预分配冗余空间的方式来减少内存的频繁分配</p>
<p><img src="/2021/12/19/day28/day28_7.png" alt="String数据结构"></p>
</li>
<li><p>当字符串长度小于1M时，扩容都是加倍现有的空间，如果超过1M，扩容时一次只会多扩1M的空间。字符串最大长度为512M。</p>
</li>
</ul>
<h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><ul>
<li>单键多值：Redis列表可以按照插入的顺序插入到头部或尾部，底层实际上是一个双向链表</li>
<li>lpush/rpush  &lt;key&gt;&lt;value1&gt;&lt;value2&gt;&lt;value3&gt; ：从左边/右边插入一个或多个值</li>
<li>lpop/rpop  &lt;key&gt;：从左边/右边吐出一个值。值在键在，值光键亡。</li>
<li>rpoplpush  &lt;key1&gt;&lt;key2&gt;：从&lt;key1&gt;列表右边吐出一个值，插到&lt;key2&gt;列表左边。</li>
<li>lrange &lt;key&gt;&lt;start&gt;&lt;stop&gt;：按照索引下标获得元素(从左到右)<ul>
<li>-1代表右边第一个</li>
</ul>
</li>
<li>lindex &lt;key&gt;&lt;index&gt;：按照索引下标获得元素(从左到右)</li>
<li>llen &lt;key&gt;：获得列表长度 </li>
<li>linsert &lt;key&gt;  before &lt;value&gt;&lt;newvalue&gt;：在&lt;value&gt;的前面插入&lt;newvalue&gt;</li>
<li>lrem &lt;key&gt;&lt;n&gt;&lt;value&gt;：从左边删除n个value(从左到右)</li>
<li>lset&lt;key&gt;&lt;index&gt;&lt;value&gt;：将列表key下标为index的值替换成value</li>
</ul>
<h3 id="List数据结构"><a href="#List数据结构" class="headerlink" title="List数据结构"></a>List数据结构</h3><ul>
<li>List的数据结构采用快速链表quickList</li>
<li>在列表元素较少的情况下会使用一块连续的内存存储，这个结构是ziplist，也即是压缩列表<ul>
<li>ziplist将所有的元素紧挨着一起存储，分配的是一块连续的内存</li>
</ul>
</li>
<li>当数据量比较多的时候才会改成quickList<ul>
<li>quickList将链表和ziplist进行结合，构成了快速链表，减少了空间冗余</li>
</ul>
</li>
</ul>
<p><img src="/2021/12/19/day28/day28_8.png" alt="quickList"></p>
<h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><ul>
<li>和list功能类似，但是可以自动排重。是一个string类型的无序集合</li>
<li>底层是一个value为null的hash表</li>
<li>sadd &lt;key&gt;&lt;value1&gt;&lt;value2&gt; ….. ：将一个或多个 member 元素加入到集合 key 中，已经存在的 member 元素将被忽略</li>
<li>smembers &lt;key&gt;：取出该集合的所有值。</li>
<li>sismember &lt;key&gt;&lt;value&gt;：判断集合&lt;key&gt;是否为含有该&lt;value&gt;值，有1，没有0</li>
<li>scard&lt;key&gt;：返回该集合的元素个数</li>
<li>srem &lt;key&gt;&lt;value1&gt;&lt;value2&gt; ….： 删除集合中的某个元素</li>
<li>spop &lt;key&gt;：随机从该集合中吐出一个值。</li>
<li>srandmember &lt;key&gt;&lt;n&gt;：随机从该集合中取出n个值。不会从集合中删除 。</li>
<li>smove &lt;source&gt;&lt;destination&gt;&lt;value&gt;：把集合中一个值从一个集合移动到另一个集合</li>
<li>sinter &lt;key1&gt;&lt;key2&gt;：返回两个集合的交集元素。</li>
<li>sunion &lt;key1&gt;&lt;key2&gt;：返回两个集合的并集元素。</li>
<li>sdiff &lt;key1&gt;&lt;key2&gt;：返回两个集合的差集元素(key1中有的，key2中没有的)</li>
</ul>
<h3 id="set的数据结构"><a href="#set的数据结构" class="headerlink" title="set的数据结构"></a>set的数据结构</h3><ul>
<li>set的数据结构是dict字典，字典是用哈希表实现的</li>
</ul>
<h2 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h2><ul>
<li>键值对集合，string 类型的field和value的映射表，适合存储对象</li>
</ul>
<p><img src="/2021/12/19/day28/day28_9.png" alt="存储方式"></p>
<ul>
<li>hset &lt;key&gt;&lt;field&gt;&lt;value&gt;：给&lt;key&gt;集合中的  &lt;field&gt;键赋值&lt;value&gt;</li>
<li>hget &lt;key1&gt;&lt;field&gt;从&lt;key1&gt;集合&lt;field&gt;取出 value </li>
<li>hmset &lt;key1&gt;&lt;field1&gt;&lt;value1&gt;&lt;field2&gt;&lt;value2&gt;… ：批量设置value</li>
<li>hexists&lt;key1&gt;&lt;field&gt;：查看哈希表 key 中，给定域 field 是否存在。 </li>
<li>hkeys &lt;key&gt;：列出该hash集合的所有field</li>
<li>hvals &lt;key&gt;：列出该hash集合的所有value</li>
<li>hincrby &lt;key&gt;&lt;field&gt;&lt;increment&gt;：为哈希表 key 中的域 field 的值加上增量</li>
<li>hsetnx &lt;key&gt;&lt;field&gt;&lt;value&gt;：将哈希表 key 中的域 field 的值设置为 value ，当且仅当域 field 不存在 .</li>
</ul>
<h3 id="Hash数据结构"><a href="#Hash数据结构" class="headerlink" title="Hash数据结构"></a>Hash数据结构</h3><ul>
<li>Hash类型对应的数据结构是两种：ziplist（压缩列表），hashtable（哈希表）<ul>
<li>当field-value长度较短且个数较少时，使用ziplist，否则使用hashtable</li>
</ul>
</li>
</ul>
<h2 id="Zset-sorted-set"><a href="#Zset-sorted-set" class="headerlink" title="Zset(sorted set)"></a>Zset(sorted set)</h2><ul>
<li>Zset每个成员都关联了一个评分（score），这个评分（score）被用来按照从最低分到最高分的方式排序集合中的成员。集合的成员是唯一的，但是评分可以重复。类似优先队列</li>
<li>zadd  &lt;key&gt;&lt;score1&gt;&lt;value1&gt;&lt;score2&gt;&lt;value2&gt;…：将一个或多个 member 元素及其 score 值加入到有序集 key 当中。</li>
<li>zrange &lt;key&gt;&lt;start&gt;&lt;stop&gt;  [WITHSCORES]：返回有序集 key 中，下标在&lt;start&gt;&lt;stop&gt;之间的元素。带WITHSCORES，可以让分数一起和值返回到结果集。</li>
<li>zrangebyscore key minmax [withscores] [limit offset count]：返回有序集 key 中，所有 score 值介于 min 和 max 之间(包括等于 min 或 max )的成员。有序集成员按 score 值递增(从小到大)次序排列。 </li>
<li>zrevrangebyscore key maxmin [withscores] [limit offset count]：同上，改为从大到小排列。 </li>
<li>zincrby &lt;key&gt;&lt;increment&gt;&lt;value&gt;：为元素的score加上增量</li>
<li>zrem  &lt;key&gt;&lt;value&gt;：删除该集合下，指定值的元素 </li>
<li>zcount &lt;key&gt;&lt;min&gt;&lt;max&gt;：统计该集合，分数区间内的元素个数 </li>
<li>zrank &lt;key&gt;&lt;value&gt;：返回该值在集合中的排名，从0开始</li>
</ul>
<h3 id="Zset数据结构"><a href="#Zset数据结构" class="headerlink" title="Zset数据结构"></a>Zset数据结构</h3><ul>
<li>zset底层使用了两个数据结构:<ul>
<li>hash，hash的作用就是关联元素value和权重score，保障元素value的唯一性，可以通过元素value找到相应的score值</li>
<li>跳跃表，跳跃表的目的在于给元素value排序，根据score的范围获取元素列表。</li>
</ul>
</li>
</ul>
<h1 id="发布与订阅"><a href="#发布与订阅" class="headerlink" title="发布与订阅"></a>发布与订阅</h1><ul>
<li><p>发布订阅是一种通信方式：发布者发送消息，订阅者接收消息</p>
</li>
<li><p>发布者通过频道发布消息，订阅者通过频道接收消息。Redis中，客户端可以订阅任意数量的频道</p>
<p><img src="/2021/12/19/day28/day28_10.png" alt="订阅"></p>
</li>
</ul>
<p><img src="/2021/12/19/day28/day28_11.png" alt="发布"></p>
<ul>
<li>发布的信息没有持久化，订阅的客户端只能收到订阅之后发布的消息</li>
</ul>
<h1 id="新的数据类型"><a href="#新的数据类型" class="headerlink" title="新的数据类型"></a>新的数据类型</h1><h2 id="Bitmaps"><a href="#Bitmaps" class="headerlink" title="Bitmaps"></a>Bitmaps</h2><ul>
<li><p>Bitmaps本身不是一种数据类型，实际上是字符串，但可以对字符串进行位操作</p>
<p><img src="/2021/12/19/day28/day28_12.png" alt="Bitmaps"></p>
</li>
<li><p>setbit&lt;key&gt;&lt;offset&gt;&lt;value&gt;：设置Bitmaps中某个偏移量的值（0或1）</p>
<ul>
<li>偏移量从0开始</li>
<li>第一次初始化时，如果偏移量较大，初始化过程会比较慢，造成Redis阻塞</li>
</ul>
</li>
<li><p>getbit&lt;key&gt;&lt;offset&gt;：获取Bitmaps中某个偏移量的值</p>
</li>
<li><p>bitcount&lt;key&gt;[start end] ：统计字符串从start字节到end字节比特值为1的数量</p>
</li>
<li><p>bitop and(or/not/xor) &lt;destkey&gt; [key…]：复合操作， 它可以做多个Bitmaps的and（交集） 、 or（并集） 、 not（非） 、 xor（异或） 操作并将结果保存在destkey中</p>
</li>
</ul>
<h2 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h2><ul>
<li><p>基数问题：求解集合中不重复元素个数</p>
</li>
<li><p>基数问题的解决：</p>
<ul>
<li>MySQL：使用distinct count</li>
<li>Redis：提供hash、set、bitmaps等数据结构</li>
</ul>
<blockquote>
<p>问题：数据量比较大时，占用空间越来越大</p>
</blockquote>
</li>
<li><p>HyperLogLog解决基数问题，牺牲一定的精度，占用少量空间</p>
<ul>
<li>计算基数问题的空间固定，每个HyperLogLog占用12KB内存，可以计算2^64个不同元素的基数</li>
<li>只能根据输入来计算基数</li>
</ul>
</li>
<li><p>pfadd &lt;key&gt;&lt; element&gt; [element …]：  添加指定元素到 HyperLogLog 中</p>
</li>
<li><p>pfcount&lt;key&gt; [key …]：计算HLL的近似基数，可以计算多个</p>
</li>
<li><p>pfmerge&lt;destkey&gt;&lt;sourcekey&gt; [sourcekey …]：  将一个或多个HLL合并后的结果存储在另一个HLL中</p>
</li>
</ul>
<h2 id="Geospatial"><a href="#Geospatial" class="headerlink" title="Geospatial"></a>Geospatial</h2><ul>
<li>经纬度、地理位置的相关操作</li>
<li>geoadd&lt;key&gt;&lt; longitude&gt;&lt;latitude&gt;&lt;member&gt; [longitude latitude member…] ：添加地理位置（经度，纬度，名称）<ul>
<li>两级无法添加</li>
<li>有效的经度从 -180 度到 180 度。有效的纬度从 -85.05112878 度到 85.05112878 度</li>
</ul>
</li>
<li>geopos  &lt;key&gt;&lt;member&gt; [member…] ： 获得指定地区的坐标值</li>
<li>geodist&lt;key&gt;&lt;member1&gt;&lt;member2&gt;  [m|km|ft|mi ] ：获取两个位置之间的直线距离，默认米为单位</li>
<li>georadius&lt;key&gt;&lt; longitude&gt;&lt;latitude&gt;&lt;radius&gt; m|km|ft|mi ：以给定的经纬度为中心，找出某一半径内的元素</li>
</ul>
<h1 id="Jedis"><a href="#Jedis" class="headerlink" title="Jedis"></a>Jedis</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JedisDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//连接redis</span></span><br><span class="line">        Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">&quot;192.168.254.131&quot;</span>,<span class="number">6379</span>);</span><br><span class="line">        jedis.auth(<span class="string">&quot;******&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//测试</span></span><br><span class="line">        String value = jedis.ping();</span><br><span class="line">        System.out.println(value); <span class="comment">//PONG</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//操作key String</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">demo1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//连接redis</span></span><br><span class="line">        Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">&quot;192.168.254.131&quot;</span>,<span class="number">6379</span>);</span><br><span class="line">        jedis.auth(<span class="string">&quot;******&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//添加</span></span><br><span class="line">        jedis.set(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;lucy&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取</span></span><br><span class="line">        String name = jedis.get(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        System.out.println(name);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//批量操作</span></span><br><span class="line">        jedis.mset(<span class="string">&quot;key1&quot;</span>,<span class="string">&quot;v1&quot;</span>,<span class="string">&quot;key2&quot;</span>,<span class="string">&quot;v2&quot;</span>);</span><br><span class="line">        List&lt;String&gt; mget = jedis.mget(<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;key2&quot;</span>);</span><br><span class="line">        System.out.println(mget);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//获得所有的key</span></span><br><span class="line">        Set&lt;String&gt; keys = jedis.keys(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(String s:keys)&#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//操做list</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">demo2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//连接redis</span></span><br><span class="line">        Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">&quot;192.168.254.131&quot;</span>,<span class="number">6379</span>);</span><br><span class="line">        jedis.auth(<span class="string">&quot;******&quot;</span>);</span><br><span class="line"></span><br><span class="line">        jedis.flushDB();</span><br><span class="line">        jedis.lpush(<span class="string">&quot;key1&quot;</span>,<span class="string">&quot;v1&quot;</span>,<span class="string">&quot;v2&quot;</span>,<span class="string">&quot;v3&quot;</span>);</span><br><span class="line">        jedis.lset(<span class="string">&quot;key1&quot;</span>, <span class="number">0</span>, <span class="string">&quot;v4&quot;</span>);</span><br><span class="line">        List&lt;String&gt; lrange = jedis.lrange(<span class="string">&quot;key1&quot;</span>, <span class="number">0</span>, jedis.llen(<span class="string">&quot;key1&quot;</span>) - <span class="number">1</span>);</span><br><span class="line">        System.out.println(lrange);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//操做set</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">demo3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//连接redis</span></span><br><span class="line">        Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">&quot;192.168.254.131&quot;</span>,<span class="number">6379</span>);</span><br><span class="line">        jedis.auth(<span class="string">&quot;******&quot;</span>);</span><br><span class="line"></span><br><span class="line">        jedis.flushDB();</span><br><span class="line">        jedis.sadd(<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>,<span class="string">&quot;d&quot;</span>,<span class="string">&quot;e&quot;</span>,<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        Set&lt;String&gt; key1 = jedis.smembers(<span class="string">&quot;key1&quot;</span>);</span><br><span class="line">        System.out.println(key1);</span><br><span class="line">        System.out.println(jedis.srandmember(<span class="string">&quot;key1&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//操做hash</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">demo4</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//连接redis</span></span><br><span class="line">        Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">&quot;192.168.254.131&quot;</span>,<span class="number">6379</span>);</span><br><span class="line">        jedis.auth(<span class="string">&quot;******&quot;</span>);</span><br><span class="line"></span><br><span class="line">        jedis.flushDB();</span><br><span class="line">        jedis.hset(<span class="string">&quot;map1&quot;</span>,<span class="string">&quot;field1&quot;</span>,<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        String hget = jedis.hget(<span class="string">&quot;map1&quot;</span>, <span class="string">&quot;field1&quot;</span>);</span><br><span class="line">        System.out.println(hget);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//操做zset</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">demo5</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//连接redis</span></span><br><span class="line">        Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">&quot;192.168.254.131&quot;</span>,<span class="number">6379</span>);</span><br><span class="line">        jedis.auth(<span class="string">&quot;******&quot;</span>);</span><br><span class="line"></span><br><span class="line">        jedis.flushDB();</span><br><span class="line">        jedis.zadd(<span class="string">&quot;zset01&quot;</span>, <span class="number">100d</span>, <span class="string">&quot;z3&quot;</span>);</span><br><span class="line">        jedis.zadd(<span class="string">&quot;zset01&quot;</span>, <span class="number">90d</span>, <span class="string">&quot;l4&quot;</span>);</span><br><span class="line">        jedis.zadd(<span class="string">&quot;zset01&quot;</span>, <span class="number">80d</span>, <span class="string">&quot;w5&quot;</span>);</span><br><span class="line">        jedis.zadd(<span class="string">&quot;zset01&quot;</span>, <span class="number">70d</span>, <span class="string">&quot;z6&quot;</span>);</span><br><span class="line">        Set&lt;String&gt; zset01 = jedis.zrange(<span class="string">&quot;zset01&quot;</span>, <span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">        System.out.println(zset01);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="模拟验证码发送"><a href="#模拟验证码发送" class="headerlink" title="模拟验证码发送"></a>模拟验证码发送</h2><blockquote>
<ol>
<li>发送6位数字码，2分钟有效</li>
<li>验证</li>
<li>每个手机号每天只能输入三次</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JedisDemo2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(getRandomCode());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//6位验证码</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getRandomCode</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Random random = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">int</span> rand = <span class="number">100000</span> + random.nextInt(<span class="number">899999</span>);</span><br><span class="line">        <span class="keyword">return</span> String.valueOf(rand);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//验证码放入</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">putCode</span><span class="params">(String phoneNumber)</span></span>&#123;</span><br><span class="line">        Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">&quot;192.168.254.131&quot;</span>,<span class="number">6379</span>);</span><br><span class="line">        jedis.auth(<span class="string">&quot;wan.1314&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//拼接key</span></span><br><span class="line">        String codeKey = <span class="string">&quot;VerifyCode &quot;</span>+phoneNumber+<span class="string">&quot; code:&quot;</span>;</span><br><span class="line">        String countKey = <span class="string">&quot;VerifyCode &quot;</span>+phoneNumber+<span class="string">&quot; count:&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//三次限制</span></span><br><span class="line">        String count = jedis.get(countKey);</span><br><span class="line">        <span class="keyword">if</span> (count == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//一次都没有</span></span><br><span class="line">            jedis.setex(countKey, <span class="number">24</span>*<span class="number">60</span>*<span class="number">60</span>, <span class="string">&quot;1&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (Integer.parseInt(count) &lt;= <span class="number">2</span>)&#123;</span><br><span class="line">            jedis.incr(countKey);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;无法多次发送！&quot;</span>);</span><br><span class="line">            jedis.close();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//存放验证码</span></span><br><span class="line">        jedis.setex(codeKey, <span class="number">2</span>*<span class="number">60</span>, getRandomCode());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//校验</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">verifyCode</span><span class="params">(String phoneNumber,String code)</span></span>&#123;</span><br><span class="line">        Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">&quot;192.168.254.131&quot;</span>,<span class="number">6379</span>);</span><br><span class="line">        jedis.auth(<span class="string">&quot;wan.1314&quot;</span>);</span><br><span class="line">        String codeKey = <span class="string">&quot;VerifyCode &quot;</span>+phoneNumber+<span class="string">&quot; code:&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> code.equals(jedis.get(codeKey));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="SpringBoot整合Redis"><a href="#SpringBoot整合Redis" class="headerlink" title="SpringBoot整合Redis"></a>SpringBoot整合Redis</h1><ul>
<li><p>添加依赖</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">     <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-pool2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>配置参数</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.254</span><span class="number">.131</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">    <span class="attr">database:</span> <span class="number">0</span></span><br><span class="line">    <span class="comment">#链接超时（毫秒）</span></span><br><span class="line">    <span class="attr">connect-timeout:</span> <span class="number">1800000</span></span><br><span class="line">    <span class="attr">lettuce:</span></span><br><span class="line">      <span class="attr">pool:</span></span><br><span class="line">        <span class="comment">#最大连接数</span></span><br><span class="line">        <span class="attr">max-active:</span> <span class="number">20</span></span><br><span class="line">        <span class="comment">#最大阻塞时间（-1表示没有限制）</span></span><br><span class="line">        <span class="attr">max-wait:</span> <span class="number">-1</span></span><br><span class="line">        <span class="comment">#最大空闲链接</span></span><br><span class="line">        <span class="attr">max-idle:</span> <span class="number">5</span></span><br><span class="line">        <span class="attr">min-idle:</span> <span class="number">0</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><ul>
<li><p>Redis事务：事务中的所有命令都会序列化、按顺序地执行。不会被其他客户端发送来的命令请求所打断。</p>
<ul>
<li>串联多个命令，不允许别的命令插队</li>
</ul>
</li>
<li><p>事务操作：</p>
<ul>
<li><strong>Multi</strong>：开启事务，进入组队阶段<ul>
<li>组队阶段报错，提交会失败</li>
<li>组队成功，提交也有可能失败</li>
</ul>
</li>
<li><strong>Exec</strong>：执行事务</li>
<li><strong>discard</strong>：放弃事务</li>
</ul>
<p><img src="/2021/12/19/day28/day28_13.png" alt="Redis事务"></p>
<ul>
<li><strong>组队阶段报错，执行时整个队列都会被取消；执行阶段报错，只有报错的命令不会被执行，其他的都会执行，不会回滚</strong></li>
</ul>
</li>
</ul>
<h2 id="悲观锁和乐观锁"><a href="#悲观锁和乐观锁" class="headerlink" title="悲观锁和乐观锁"></a>悲观锁和乐观锁</h2><ul>
<li><p>事务冲突</p>
<p><img src="/2021/12/19/day28/day28_14.png" alt="事务冲突"></p>
</li>
<li><p>悲观锁：每次对数据进行操作，在获得数据后，会给数据加锁，不允许其他程序操作。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁、读锁、写锁等，都是在做操作之前先上锁</p>
<ul>
<li>效率低</li>
</ul>
<p><img src="/2021/12/19/day28/day28_15.png" alt="悲观锁"></p>
</li>
<li><p>乐观锁：每次对数据操作不加锁，在更新的时候会判断在此期间该数据有没有被更改，可以采用<strong>版本号</strong>等机制。</p>
<ul>
<li>效率高，适用于多读的情形，提高吞吐量。Redis就是采用<strong>check-and-set</strong>的机制</li>
</ul>
<p><img src="/2021/12/19/day28/day28_16.png" alt="乐观锁"></p>
</li>
<li><p>**WATCH key / [key…]**：执行muti之前，先执行WATCH，监视一个或多个key，事务执行阶段如果被监视的key被其他操作改动，事务将被打断</p>
<ul>
<li><strong>UNWATCH</strong>：取消所有key的监视</li>
</ul>
</li>
</ul>
<h2 id="Redis事务三大特性"><a href="#Redis事务三大特性" class="headerlink" title="Redis事务三大特性"></a>Redis事务三大特性</h2><ul>
<li>单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，<strong>不会被其他客户端发送来的命令请求所打断</strong></li>
<li>没有隔离级别概念</li>
<li>不保证原子性</li>
</ul>
<h2 id="简单秒杀案例"><a href="#简单秒杀案例" class="headerlink" title="简单秒杀案例"></a>简单秒杀案例</h2><ul>
<li><p>未加入并发</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//秒杀过程</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">doSecKill</span><span class="params">(String uid,String prodid)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">	<span class="comment">//uid和 prodid 非空判断</span></span><br><span class="line">	<span class="keyword">if</span> (uid==<span class="keyword">null</span> || prodid==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  </span><br><span class="line">	<span class="comment">//连接redis</span></span><br><span class="line">	Jedis jedis =<span class="keyword">new</span> Jedis(<span class="string">&quot;192.168.44.168&quot;</span>,<span class="number">6379</span>);</span><br><span class="line">	jedis.auth(<span class="string">&quot;wan.1314&quot;</span>);</span><br><span class="line">  </span><br><span class="line">	<span class="comment">//拼接key</span></span><br><span class="line">	String kcKey = <span class="string">&quot;sk:&quot;</span> + prodid + <span class="string">&quot;:qt&quot;</span>;</span><br><span class="line">	String userKey = <span class="string">&quot;sk:&quot;</span> + prodid + <span class="string">&quot;:user&quot;</span>;</span><br><span class="line">  </span><br><span class="line">	String kc = jedis.get(kcKey);</span><br><span class="line">	<span class="keyword">if</span> (kc == <span class="keyword">null</span>)&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;秒杀还未开始，请等待！&quot;</span>);</span><br><span class="line">		jedis.close();</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">  </span><br><span class="line">	<span class="comment">//判断是否重复秒杀</span></span><br><span class="line">	<span class="keyword">if</span> (jedis.sismember(userKey, uid))&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;已经参加过秒杀，不能重复秒杀&quot;</span>);</span><br><span class="line">		jedis.close();</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">  </span><br><span class="line">	<span class="comment">//判断库存</span></span><br><span class="line">	<span class="keyword">if</span> (Integer.parseInt(kc) &lt; <span class="number">1</span>)&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;秒杀结束&quot;</span>);</span><br><span class="line">		jedis.close();</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">  </span><br><span class="line">	<span class="comment">//秒杀过程</span></span><br><span class="line">	jedis.decr(kcKey);</span><br><span class="line">	jedis.sadd(userKey, uid);</span><br><span class="line">	System.out.println(<span class="string">&quot;秒杀成功!&quot;</span>);</span><br><span class="line">	jedis.close();</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>并发场景问题：</p>
<ul>
<li>连接超时问题：redis无法同时处理很多个请求</li>
<li>超卖问题</li>
</ul>
</li>
<li><p><strong>连接超时问题</strong>：使用连接池解决</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JedisPoolUtil</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> JedisPool jedisPool = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">JedisPoolUtil</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> JedisPool <span class="title">getJedisPoolInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">null</span> == jedisPool) &#123;</span><br><span class="line">			<span class="keyword">synchronized</span> (JedisPoolUtil.class) &#123;</span><br><span class="line">				<span class="keyword">if</span> (<span class="keyword">null</span> == jedisPool) &#123;</span><br><span class="line">					JedisPoolConfig poolConfig = <span class="keyword">new</span> JedisPoolConfig();</span><br><span class="line">					poolConfig.setMaxTotal(<span class="number">200</span>);</span><br><span class="line">					poolConfig.setMaxIdle(<span class="number">32</span>);</span><br><span class="line">					poolConfig.setMaxWaitMillis(<span class="number">100</span>*<span class="number">1000</span>);</span><br><span class="line">					poolConfig.setBlockWhenExhausted(<span class="keyword">true</span>);</span><br><span class="line">					poolConfig.setTestOnBorrow(<span class="keyword">true</span>);  <span class="comment">// ping  PONG</span></span><br><span class="line">				 </span><br><span class="line">					jedisPool = <span class="keyword">new</span> JedisPool(poolConfig, <span class="string">&quot;192.168.44.168&quot;</span>, <span class="number">6379</span>, <span class="number">60000</span> );</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> jedisPool;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">(JedisPool jedisPool, Jedis jedis)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">null</span> != jedis) &#123;</span><br><span class="line">			jedisPool.returnResource(jedis);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>超卖问题</strong>：乐观锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//秒杀过程</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">doSecKill</span><span class="params">(String uid,String prodid)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">	<span class="comment">//uid和 prodid 非空判断</span></span><br><span class="line">	<span class="keyword">if</span> (uid==<span class="keyword">null</span> || prodid==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  </span><br><span class="line">	<span class="comment">//连接redis</span></span><br><span class="line">	JedisPool jedispool =  JedisPoolUtil.getJedisPoolInstance();</span><br><span class="line">	Jedis jedis=jedispool.getResource();</span><br><span class="line">  </span><br><span class="line">	<span class="comment">//拼接key</span></span><br><span class="line">	String kcKey = <span class="string">&quot;sk:&quot;</span> + prodid + <span class="string">&quot;:qt&quot;</span>;</span><br><span class="line">	String userKey = <span class="string">&quot;sk:&quot;</span> + prodid + <span class="string">&quot;:user&quot;</span>;</span><br><span class="line">  </span><br><span class="line">	<span class="comment">//监视库存</span></span><br><span class="line">	jedis.watch(kcKey);</span><br><span class="line">  </span><br><span class="line">	String kc = jedis.get(kcKey);</span><br><span class="line">	<span class="keyword">if</span> (kc == <span class="keyword">null</span>)&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;秒杀还未开始，请等待！&quot;</span>);</span><br><span class="line">		jedis.close();</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">  </span><br><span class="line">	<span class="comment">//判断是否重复秒杀</span></span><br><span class="line">	<span class="keyword">if</span> (jedis.sismember(userKey, uid))&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;已经参加过秒杀，不能重复秒杀&quot;</span>);</span><br><span class="line">		jedis.close();</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">  </span><br><span class="line">	<span class="comment">//判断库存</span></span><br><span class="line">	<span class="keyword">if</span> (Integer.parseInt(kc) &lt; <span class="number">1</span>)&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;秒杀结束&quot;</span>);</span><br><span class="line">		jedis.close();</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">  </span><br><span class="line">	<span class="comment">//秒杀过程,添加事务</span></span><br><span class="line">	Transaction multi = jedis.multi();</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//组队</span></span><br><span class="line">	multi.decr(kcKey);</span><br><span class="line">	multi.sadd(userKey, uid);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//执行</span></span><br><span class="line">	List&lt;Object&gt; exec = multi.exec();</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">	<span class="keyword">if</span> (exec == <span class="keyword">null</span> || exec.isEmpty())&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;秒杀失败&quot;</span>);</span><br><span class="line">		jedis.close();</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">  </span><br><span class="line">	System.out.println(<span class="string">&quot;秒杀成功!&quot;</span>);</span><br><span class="line">	jedis.close();</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>库存遗留问题</strong>：乐观锁导致很多请求失败，先秒杀的反而不如后秒杀的。</p>
<blockquote>
<p> LUA脚本解决：</p>
<ul>
<li>将复杂的或者多步的redis操作，写为一个脚本，一次提交给redis执行，减少反复连接redis的次数。提升性能</li>
<li>LUA脚本是类似redis事务，有一定的原子性，不会被其他命令插队，可以完成一些redis事务性的操作</li>
<li>实际上是redis 利用其单线程的特性，用任务队列的方式解决多任务并发问题</li>
</ul>
</blockquote>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> userid=KEYS[<span class="number">1</span>]; </span><br><span class="line"><span class="keyword">local</span> prodid=KEYS[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">local</span> qtkey=<span class="string">&quot;sk:&quot;</span>..prodid..<span class="string">&quot;:qt&quot;</span>;</span><br><span class="line"><span class="keyword">local</span> usersKey=<span class="string">&quot;sk:&quot;</span>..prodid.<span class="string">&quot;:usr&#x27;; </span></span><br><span class="line"><span class="string">local userExists=redis.call(&quot;</span>sismember<span class="string">&quot;,usersKey,userid);</span></span><br><span class="line"><span class="string">if tonumber(userExists)==1 then </span></span><br><span class="line"><span class="string">  //已经秒杀过了</span></span><br><span class="line"><span class="string">  return 2;</span></span><br><span class="line"><span class="string">end</span></span><br><span class="line"><span class="string">local num= redis.call(&quot;</span>get<span class="string">&quot; ,qtkey);</span></span><br><span class="line"><span class="string">if tonumber(num)&lt;=0 then </span></span><br><span class="line"><span class="string">  //库存不够</span></span><br><span class="line"><span class="string">  return 0; </span></span><br><span class="line"><span class="string">else </span></span><br><span class="line"><span class="string">  redis.call(&quot;</span>decr<span class="string">&quot;,qtkey);</span></span><br><span class="line"><span class="string">  redis.call(&quot;</span>sadd<span class="string">&quot;,usersKey,userid);</span></span><br><span class="line"><span class="string">end</span></span><br><span class="line"><span class="string">//秒杀成功</span></span><br><span class="line"><span class="string">return 1;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">doSecKill</span><span class="params">(String uid,String prodid)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  </span><br><span class="line">	<span class="comment">//uid和 prodid 非空判断</span></span><br><span class="line">	<span class="keyword">if</span> (uid==<span class="keyword">null</span> || prodid==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  </span><br><span class="line">	JedisPool jedispool =  JedisPoolUtil.getJedisPoolInstance();</span><br><span class="line">	Jedis jedis=jedispool.getResource();</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">	 <span class="comment">//加载lua脚本</span></span><br><span class="line">	String sha1=  jedis.scriptLoad(secKillScript);</span><br><span class="line">	Object result= jedis.evalsha(sha1, <span class="number">2</span>, uid,prodid);</span><br><span class="line">  </span><br><span class="line">	String reString=String.valueOf(result);</span><br><span class="line">	<span class="keyword">if</span> (<span class="string">&quot;0&quot;</span>.equals( reString )  ) &#123;</span><br><span class="line">		System.err.println(<span class="string">&quot;已抢空！！&quot;</span>);</span><br><span class="line">	&#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">&quot;1&quot;</span>.equals( reString )  )  &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;抢购成功！！！！&quot;</span>);</span><br><span class="line">	&#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">&quot;2&quot;</span>.equals( reString )  )  &#123;</span><br><span class="line">		System.err.println(<span class="string">&quot;该用户已抢过！！&quot;</span>);</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		System.err.println(<span class="string">&quot;抢购异常！！&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	jedis.close();</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h1><ul>
<li>持久化：将Redis数据写入到硬盘</li>
</ul>
<h2 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h2><ul>
<li><p><strong>RDB（Redis DataBase）</strong>：在指定的<strong>时间间隔</strong>内，将内存中的<strong>数据集快照</strong>写入到磁盘中。恢复时将快照文件直接读到内存里</p>
</li>
<li><p><strong>备份的执行过程</strong>：Redis会单独创建（<strong>fork</strong>）一个子进程来进行持久化，会先将数据写入到 一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。 整个过程中，<strong>主进程是不进行任何IO操作的，这就确保了极高的性能</strong></p>
<ul>
<li><p>如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方式要比AOF方式更加的高效</p>
</li>
<li><p>RDB的缺点是最后一次持久化后的数据可能丢失；需要额外空间</p>
<p><img src="/2021/12/19/day28/day28_17.png" alt="RDB过程"></p>
</li>
</ul>
</li>
<li><p><strong>Fork</strong>：复制一个与当前进程一样的进程。新进程的所有数据原进程一致，但是是一个全新的进程，并作为原进程的子进程，使用了<strong>写时复制技术</strong></p>
</li>
</ul>
<h2 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h2><ul>
<li><p><strong>AOF（Append Only File）</strong>:以日志的形式记录<strong>写操作</strong>（不记录读操作），将Redis执行过的所有指令记录下来，<strong>只允许追加文件不允许修改文件</strong>。redis启动之初会读取该文件重新构建数据</p>
</li>
<li><p>AOF执行流程：</p>
<ul>
<li><p>客户端的请求写命令会被append追加到AOF缓冲区内</p>
</li>
<li><p>AOF缓冲区根据AOF持久化策略**[always,everysec,no]**将操作sync同步到磁盘的AOF文件中</p>
<ul>
<li>always：每次写入都记入日志</li>
<li>everysec：每秒记录一次</li>
<li>no：redis不主动同步，将同步时机交给操作系统</li>
</ul>
</li>
<li><p>AOF文件大小超过重写策略或手动重写时，会对AOF文件<strong>rewrite</strong>重写，压缩AOF文件容量</p>
<ul>
<li>Rewrite：只关注结果，不关注过程，将多个操作进行合并</li>
<li>AOF文件持续增长而过大时，会<strong>fork</strong>出一条新进程来将文件重写(也是先写临时文件最后再rename)，<strong>redis4.0版本后的重写</strong>，是指上就是把<strong>rdb 的快照，以二级制的形式附在新的aof头部，作为已有的历史数据，</strong>替换掉原来的流水账操作</li>
<li>Redis会记录上次重写时的AOF大小，默认配置是当AOF文件大小是上次rewrite后大小的一倍且文件大于64M时触发</li>
</ul>
<p><img src="/2021/12/19/day28/day28_19.png" alt="重写流程"></p>
</li>
<li><p>Redis服务重启时，会重新load加载AOF文件中的写操作达到数据恢复的目的</p>
</li>
</ul>
<p><img src="/2021/12/19/day28/day28_18.png" alt="AOF"></p>
</li>
<li><p>AOF默认不开启：配置文件修改<strong>appendonly yes</strong></p>
</li>
<li><p>AOF和RDB同时开启，会使用AOF，因为不会产生数据丢失</p>
</li>
<li><p><strong>异常恢复</strong>：如遇到<strong>AOF文件损坏</strong>，通过**/usr/local/bin/redis-check-aof–fix appendonly.aof**进行恢复</p>
</li>
<li><p>优势：备份机制更稳健，丢失数据概率更低；可读的日志文本，通过操作AOF稳健，可以处理误操作</p>
</li>
<li><p>劣势：占用更多空间；恢复速度慢；每次都同步会有性能压力</p>
</li>
</ul>
<h1 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h1><ul>
<li><p>主从复制：主机数据更新后，根据配置和策略自动同步到备机的<strong>mater/slaver</strong>机制，Master以写为主，Slave以读为主，一主多从</p>
<ul>
<li>读写分离，性能扩展</li>
<li>容灾快速恢复：从服务器挂掉，可以快速切换到其他从服务器</li>
</ul>
<p><img src="/2021/12/19/day28/day28_20.png" alt="主从复制"></p>
</li>
</ul>
<h2 id="模拟主从复制"><a href="#模拟主从复制" class="headerlink" title="模拟主从复制"></a>模拟主从复制</h2><ul>
<li><p>创建配置文件，定义不同端口号，6379，6380，6381</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">include /myredis/redis.conf</span><br><span class="line">pidfile /var/run/redis<span class="built_in">_</span>6379.pid</span><br><span class="line">port 6379</span><br><span class="line">masterauth wan.1314</span><br><span class="line">dbfilename dump6379.rdb</span><br></pre></td></tr></table></figure></li>
<li><p><code>redis-server redis6380.conf</code>启动redis，<code>info replication</code>可以查看主机运行情况</p>
<p><img src="/2021/12/19/day28/day28_21.png" alt="运行状态"></p>
</li>
<li><p>配置主从：<code>slaveof  &lt;ip&gt;&lt;port&gt;</code>，从机上执行</p>
<p><img src="/2021/12/19/day28/day28_22.png" alt="一主两从"></p>
</li>
</ul>
<h2 id="常见问题及复制原理"><a href="#常见问题及复制原理" class="headerlink" title="常见问题及复制原理"></a>常见问题及复制原理</h2><ul>
<li>从服务器挂掉之后重启，会重新变成主服务器。再次变成从服务器后，会将主服务器中的数据从头开始复制</li>
<li>主服务器挂掉之后，从服务器不会改变。主服务器重启之后，还是主服务器</li>
<li>上一个slave可以是下一个slave的master，中途变更转向会清除之前的数据，重新拷贝新的数据</li>
<li>当一个master宕机后，后面的slave可以升级为master。<code>slaveof no one</code></li>
</ul>
<blockquote>
<p>复制原理：</p>
<ul>
<li>Slave启动成功连接到master后会发送一个sync命令</li>
<li>Master接到命令启动后台的存盘进程，进行持久化，获得rdb文件。master将传送rdb文件到slave，以完成一次完全同步</li>
<li>每次主服务器进行写操作后，和从服务器进行数据同步</li>
<li><strong>全量复制</strong>：而slave服务在接收到数据库文件数据后，将其存盘并加载到内存中</li>
<li><strong>增量复制</strong>：Master继续将新的所有收集到的修改命令依次传给slave,完成同步</li>
</ul>
</blockquote>
<h2 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h2><ul>
<li><p>后台监视主机是否故障，出现故障后根据投票数自动将从库转为主库</p>
</li>
<li><p>配置步骤：</p>
<ul>
<li><p>创建sentinel.conf文件</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%其中mymaster为监控对象起的服务器名称， 1 为至少有多少个哨兵同意迁移的数量</span></span><br><span class="line">sentinel monitor mymaster 127.0.0.1 6379 1</span><br></pre></td></tr></table></figure></li>
<li><p>启动哨兵：<code>redis-sentinel sentinel.conf</code></p>
</li>
</ul>
</li>
<li><p>主库宕机后，某一个从库变为主库，原主库恢复后，会变成从库</p>
</li>
<li><p>复制延时：由于只有主机才能进行写操作，将数据同步到slave上时，会有延时，当slave数量变多时，延时问题会更严重</p>
</li>
<li><p>选择条件：</p>
<ul>
<li>优先级：在配置文件中设置，值越小优先级越高</li>
<li>偏移量：获得原主机数据最全的</li>
<li>runid：每个redis启动后都会随机生成一个40位的runid</li>
</ul>
<p><img src="/2021/12/19/day28/day28_23.png" alt="哨兵模式"></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//jedis哨兵操作</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> JedisSentinelPool jedisSentinelPool=<span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  Jedis <span class="title">getJedisFromSentinel</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(jedisSentinelPool==<span class="keyword">null</span>)&#123;</span><br><span class="line">        Set&lt;String&gt; sentinelSet=<span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        sentinelSet.add(<span class="string">&quot;192.168.11.103:26379&quot;</span>);</span><br><span class="line"></span><br><span class="line">        JedisPoolConfig jedisPoolConfig =<span class="keyword">new</span> JedisPoolConfig();</span><br><span class="line">        jedisPoolConfig.setMaxTotal(<span class="number">10</span>); <span class="comment">//最大可用连接数</span></span><br><span class="line">        jedisPoolConfig.setMaxIdle(<span class="number">5</span>); <span class="comment">//最大闲置连接数</span></span><br><span class="line">        jedisPoolConfig.setMinIdle(<span class="number">5</span>); <span class="comment">//最小闲置连接数</span></span><br><span class="line">        jedisPoolConfig.setBlockWhenExhausted(<span class="keyword">true</span>); <span class="comment">//连接耗尽是否等待</span></span><br><span class="line">        jedisPoolConfig.setMaxWaitMillis(<span class="number">2000</span>); <span class="comment">//等待时间</span></span><br><span class="line">        jedisPoolConfig.setTestOnBorrow(<span class="keyword">true</span>); <span class="comment">//取连接的时候进行一下测试 ping pong</span></span><br><span class="line"></span><br><span class="line">        jedisSentinelPool=<span class="keyword">new</span> JedisSentinelPool(<span class="string">&quot;mymaster&quot;</span>,sentinelSet,jedisPoolConfig);</span><br><span class="line">        <span class="keyword">return</span> jedisSentinelPool.getResource();</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> jedisSentinelPool.getResource();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h1><ul>
<li><p>集群：对redis进行水平扩容，启动N个redis节点，将整个数据库分布存储在N个节点中</p>
<ul>
<li>可以扩充容量；高并发</li>
</ul>
</li>
<li><p>无中心化集群</p>
</li>
<li><p>配置文件</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">include redis.conf</span><br><span class="line">port 6382</span><br><span class="line">pidfile &quot;/var/run/redis<span class="built_in">_</span>6382.pid&quot;</span><br><span class="line">dbfilename &quot;dump6382.rdb&quot;</span><br><span class="line">masterauth wan.1314</span><br><span class="line">cluster-enabled yes</span><br><span class="line">cluster-config-file nodes-6382.conf</span><br><span class="line">cluster-node-timeout 15000</span><br></pre></td></tr></table></figure></li>
<li><p>启动所有redis</p>
</li>
<li><p>集群操作：<code>redis-cli --cluster create --cluster-replicas 1 192.168.11.101:6379 192.168.11.101:6380 192.168.11.101:6381 192.168.11.101:6389 192.168.11.101:6390 192.168.11.101:6391</code></p>
</li>
<li><p>分配原则：尽量保证每个主数据库运行在不同的IP地址，每个从库和主库不在一个IP地址</p>
</li>
<li><p>集群使用公式 <strong>CRC16(key) % 16384</strong> 来计算键 key 属于哪个槽， 其中 CRC16(key) 语句用于计算键 key 的 CRC16 校验和 </p>
<ul>
<li>不在同一个slot下的键值，不能使用mget,mset</li>
<li>可以通过{}来定义组的概念，使得key中{}相同内容的键值对放在同一个slot</li>
</ul>
</li>
<li><p>故障恢复：</p>
<ul>
<li>主节点下线，从节点自动升为主节点</li>
<li>主节点恢复后，变为从机</li>
<li>主机和从机都挂掉，如果<code>cluster-require-full-coverage</code>为yes，整个集群都挂掉；如果为no，只是该slot范围挂掉</li>
</ul>
</li>
</ul>
<h2 id="jedis集群"><a href="#jedis集群" class="headerlink" title="jedis集群"></a>jedis集群</h2><ul>
<li>即使连接的不是主机，也会自动切换主机存储，主机写，从机读</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JedisClusterTest</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">     Set&lt;HostAndPort&gt;set =<span class="keyword">new</span> HashSet&lt;HostAndPort&gt;();</span><br><span class="line">     set.add(<span class="keyword">new</span> HostAndPort(<span class="string">&quot;192.168.31.211&quot;</span>,<span class="number">6379</span>));</span><br><span class="line">     JedisCluster jedisCluster=<span class="keyword">new</span> JedisCluster(set);</span><br><span class="line">     jedisCluster.set(<span class="string">&quot;k1&quot;</span>, <span class="string">&quot;v1&quot;</span>);</span><br><span class="line">     System.out.println(jedisCluster.get(<span class="string">&quot;k1&quot;</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>集群优缺点：<ul>
<li>优点：实现扩容；分摊压力；无中心化配置简单</li>
<li>缺点：多建操作不被支持；多键的事务不被支持；lua脚本不被支持</li>
</ul>
</li>
</ul>
<h1 id="具体场景问题"><a href="#具体场景问题" class="headerlink" title="具体场景问题"></a>具体场景问题</h1><h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><ul>
<li>缓存穿透：key对应的数据在数据源中不存在，每次针对key的请求在缓存中无法获得，黑客可以利用这个漏洞，让服务器崩溃</li>
<li><strong>出现的原因</strong>：服务器压力变大；redis命中率低；一直查询数据库，导致崩溃<ul>
<li>redis查询不到数据库</li>
<li>出现很多非正常URL访问</li>
</ul>
</li>
<li>解决方案：<ul>
<li><strong>对空值缓存</strong>：即使访问的数据在数据库中不存在，也进行缓存，但是过期时间比较短</li>
<li><strong>设置可访问的名单（白名单）</strong>：使用bitmaps定义一个可访问的名单，名单id作为bitmaps的偏移量，如果访问的id不在bitmaps中，不允许访问</li>
<li><strong>采用布隆过滤器</strong>：将所有可能存在的数据哈希到一个足够大的bitmaps中，一个一定不存在的数据会被 这个bitmaps拦截掉，从而避免了对底层存储系统的查询压力</li>
<li><strong>进行实时监控</strong>：发现redis命中率降低时，排查访问对象和访问数据，设置黑名单</li>
</ul>
</li>
</ul>
<h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><ul>
<li><p>缓存击穿：某个key过期，突然有大量并发请求获得该key，都一起查询数据库</p>
</li>
<li><p>出现原因：数据库访问压力瞬时增加；redis里面没有出现大量key过期；redis正常运行</p>
<ul>
<li>某个热门访问的key过期</li>
</ul>
</li>
<li><p>解决方法：</p>
<ul>
<li><p><strong>预先设置热门数据</strong>：将一些热门数据提前存入到redis，并加大时长</p>
</li>
<li><p><strong>实时调整</strong>：监控哪些key比较热门，实时调整时长</p>
</li>
<li><p><strong>使用锁</strong>：</p>
<p><img src="/2021/12/19/day28/day28_24.png" alt="使用锁解决缓存击穿"></p>
</li>
</ul>
</li>
</ul>
<h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><ul>
<li>缓存雪崩：极少时间段内，查询的大量key过期，导致数据库压力变大</li>
<li>解决方案：<ul>
<li><strong>构建多级缓存架构</strong>：nginx缓存 + redis缓存 + 其他缓存等</li>
<li><strong>使用锁或队列</strong>：用加锁或者队列的方式保证来保证不会有大量的线程对数据库一次性进行读写，从而避免失效时大量的并发请求落到底层存储系统上。不适用高并发情况</li>
<li><strong>设置过期标志更新缓存</strong>：记录缓存数据是否过期，如果过期通知另一个线程更新实际key的缓存</li>
<li><strong>将缓存失效时间分散开</strong>：可以在原有的失效时间基础上增加一个随机值，防止大量key在短时间内失效</li>
</ul>
</li>
</ul>
<h1 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h1><ul>
<li>实现方案：<ul>
<li>基于数据库实现</li>
<li>基于缓存实现</li>
<li>基于Zookeeper</li>
</ul>
</li>
</ul>
<h2 id="使用Redis实现分布式锁"><a href="#使用Redis实现分布式锁" class="headerlink" title="使用Redis实现分布式锁"></a>使用Redis实现分布式锁</h2><ul>
<li><p>redis命令：<code>setnx key second value</code></p>
<p><img src="/2021/12/19/day28/day28_25.png" alt="分布式锁"></p>
</li>
<li><p>设置锁过期时间：<code>set key value ex 3000 nx</code></p>
</li>
<li><p>可能业务没有执行完，锁已经被释放：<strong>相当于没有上锁</strong></p>
<p><img src="/2021/12/19/day28/day28_26.png" alt="释放别人的锁"></p>
<ul>
<li>使用UUID防止误删：<ul>
<li>为每个操作都生成一个唯一的UUID作为value</li>
<li>释放锁时，判断value值和自己的uuid是否相同，相同才能释放</li>
</ul>
</li>
</ul>
</li>
<li><p>删除操作缺乏原子性：会发生误删</p>
<p><img src="/2021/12/19/day28/day28_27.png" alt="删除操作"></p>
<ul>
<li>lua脚本实现释放锁的原子性</li>
</ul>
</li>
<li><p>确保分布式锁可用：</p>
<ul>
<li>互斥性</li>
<li>不会发生死锁：设置过期时间</li>
<li>加锁和解锁必须是同一个客户端</li>
<li>加锁和解锁必须具有原子性</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/11/10/day27/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Kaixuan Wang">
      <meta itemprop="description" content="只争朝夕">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Magic">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/11/10/day27/" class="post-title-link" itemprop="url">操作系统</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-11-10 20:24:09" itemprop="dateCreated datePublished" datetime="2021-11-10T20:24:09+08:00">2021-11-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-12-13 19:48:20" itemprop="dateModified" datetime="2021-12-13T19:48:20+08:00">2021-12-13</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="操作系统历史回顾"><a href="#操作系统历史回顾" class="headerlink" title="操作系统历史回顾"></a>操作系统历史回顾</h1><h2 id="大型主机系统MainFrame-Systems"><a href="#大型主机系统MainFrame-Systems" class="headerlink" title="大型主机系统MainFrame Systems"></a>大型主机系统MainFrame Systems</h2><ul>
<li>Batch System:<ul>
<li>同一时间只能执行一个程序</li>
<li>用户和程序之间没有交互</li>
<li>CPU一般都处于闲置状态：因为IO和CPU速度差别太大</li>
</ul>
</li>
<li>Multi-programming System:<ul>
<li>I/O和程序的执行重叠</li>
<li>I/O的执行不需要CPU参与，CPU只需要在I/O准备好后再参与</li>
</ul>
</li>
<li>Time-sharing System<ul>
<li>提供用户和操作系统的交互</li>
<li>多用户同时操作一个电脑</li>
</ul>
</li>
</ul>
<h2 id="计算机架构"><a href="#计算机架构" class="headerlink" title="计算机架构"></a>计算机架构</h2><ul>
<li><p>Desktop Systems:PC</p>
<ul>
<li>使用较好的GUI界面</li>
<li>输入输出设备</li>
<li>有一些不同类型的操作系统：windows,unix,linux等</li>
<li>缺少文件和操作系统的保护</li>
</ul>
</li>
<li><p>Parallel Systems:</p>
<ul>
<li><p>多个cpu紧密连接</p>
</li>
<li><p>通过共享内存进行通信</p>
</li>
<li><p>Symmetric multiprocessor system(SMP):</p>
<ul>
<li>每个处理器都使用相同的OS</li>
<li>需要额外的同步机制去保护数据的完整性（能够集成的CPU不是很多）</li>
</ul>
</li>
<li><p>Asymmetric multiprocessor system:</p>
<ul>
<li><p>每个处理器处理自己的工作</p>
</li>
<li><p>其中一个或多个CPU作为管理者</p>
</li>
<li><p>通常使用在大型计算机中</p>
</li>
</ul>
</li>
<li><p>内存结构：</p>
<ul>
<li><p>Uniform Memory Access(UMA):</p>
<ul>
<li>所有CPU都相同连在Memory上，连接时间都相同</li>
</ul>
</li>
<li><p>Non-Uniform Memory Access(NUMA):</p>
</li>
</ul>
<p><img src="/2021/11/10/day27/day27_1.png" alt="NUMA"></p>
</li>
</ul>
</li>
<li><p>Distributed Systems:</p>
<ul>
<li>每个处理器都有自己的本地内存</li>
<li>处理器之间的通信需要经过通信网络</li>
<li>Client-Server Distributed System：<ul>
<li>方便管理和控制资源</li>
<li>服务器特别关键，会成为整个系统的瓶颈和单一失败结点</li>
</ul>
</li>
<li>Peer-to-Peer Distributed System:<ul>
<li>每个结点在系统中都是相同的地位</li>
</ul>
</li>
<li>Clustered Systems:<ul>
<li>每个节点共享存储，并且通过本地网络连接，速度很快</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="专用系统"><a href="#专用系统" class="headerlink" title="专用系统"></a>专用系统</h2><ul>
<li>Real-Time OS:<ul>
<li>保证有deadlines</li>
<li>保证response和reaction的时间</li>
</ul>
</li>
<li>Multimedia Systems:online TV等</li>
<li>Handheld/Embedded Systems:<ul>
<li>移动设备</li>
</ul>
</li>
</ul>
<h1 id="操作系统介绍"><a href="#操作系统介绍" class="headerlink" title="操作系统介绍"></a>操作系统介绍</h1><h2 id="什么是操作系统"><a href="#什么是操作系统" class="headerlink" title="什么是操作系统"></a>什么是操作系统</h2><ul>
<li><p>操作系统：控制和协调对硬件资源的使用</p>
<p><img src="/2021/11/10/day27/day27_2.png" alt="操作系统的控制"></p>
</li>
</ul>
<p><img src="/2021/11/10/day27/day27_3.png" alt="操作系统的协调"></p>
<ul>
<li>操作系统的目的：<ul>
<li>方便性：让电脑系统更容易使用</li>
<li>效率高：更好的使用硬件资源</li>
</ul>
</li>
</ul>
<h2 id="电脑系统组成"><a href="#电脑系统组成" class="headerlink" title="电脑系统组成"></a>电脑系统组成</h2><p><img src="/2021/11/10/day27/day27_4.png" alt="电脑系统"></p>
<ul>
<li><p>中断：可以改变CPU控制的顺序</p>
<p><img src="/2021/11/10/day27/day27_5.png" alt="IO设备的中断"></p>
</li>
<li><p>现在的OS一般都是基于中断</p>
</li>
</ul>
<h2 id="存储设备架构"><a href="#存储设备架构" class="headerlink" title="存储设备架构"></a>存储设备架构</h2><p><img src="/2021/11/10/day27/day27_6.png" alt="存储结构"></p>
<ul>
<li><p>存储系统的考虑因素：速度、成本和不稳定性</p>
</li>
<li><p>main memory:CPU可以直接读的仅有的大存储设备</p>
</li>
<li><p>disk：每个位置的数据读取速度不同</p>
<p><img src="/2021/11/10/day27/day27_7.png" alt="存储系统的介绍"></p>
</li>
<li><p>要保证存储结构中的所有数据具有一致性</p>
</li>
</ul>
<h2 id="硬件保护"><a href="#硬件保护" class="headerlink" title="硬件保护"></a>硬件保护</h2><ul>
<li>保护：一个错误的程序不会影响刀其他程序的执行</li>
<li>User Mode:用户来执行</li>
<li>Monitor Mode：操作系统来执行</li>
<li>Dual-Mode Operation：电脑硬件可以识别当前执行的程序是OS还是用户程序<ul>
<li>当中断或错误发生时，硬件设备会切换到monitor mode</li>
<li>特权操作只能由操作系统来执行</li>
</ul>
</li>
<li>I/O Protection：所有IO操作都是特权操作，只能由OS执行</li>
<li>Memory Protection：超过范围的内存被保护<ul>
<li>Base register：程序从哪里开始</li>
<li>Limit register：程序有多长</li>
<li>修改范围的操作是特权操作</li>
</ul>
</li>
<li>CPU Protection：保证用户程序不会一直持有控制<ul>
<li>Timer：计时器时间到了之后，会切换到monitor mode，使用OS进行程序执行的分配</li>
<li>修改计时器的操作是特权操作</li>
</ul>
</li>
</ul>
<h1 id="操作系统架构"><a href="#操作系统架构" class="headerlink" title="操作系统架构"></a>操作系统架构</h1><h2 id="操作系统的服务"><a href="#操作系统的服务" class="headerlink" title="操作系统的服务"></a>操作系统的服务</h2><p><img src="/2021/11/10/day27/day27_8.png" alt="操作系统的服务"></p>
<h3 id="User-Interface"><a href="#User-Interface" class="headerlink" title="User Interface"></a>User Interface</h3><ul>
<li>CLI(Command Line Interface)：<ul>
<li>从用户获得命令并且执行</li>
<li>Shell：命令行解释器，适应不同用户的行为和偏好</li>
</ul>
</li>
<li>GUI(Graphic User Interface)：</li>
</ul>
<h3 id="Communication-Models"><a href="#Communication-Models" class="headerlink" title="Communication Models"></a>Communication Models</h3><ul>
<li>message passing：通过OS将内存中的内容复制到另一个程序</li>
<li>Shared Memory：开辟共享内存空间</li>
</ul>
<h2 id="操作系统的API"><a href="#操作系统的API" class="headerlink" title="操作系统的API"></a>操作系统的API</h2><ul>
<li>System Calls：<ul>
<li>OS提供的运行程序的接口</li>
<li>是软件中断，可以改变到Monitor Mode</li>
<li>重视效率，使用汇编语言编写</li>
</ul>
</li>
<li>使用API作用：<ul>
<li>使用简单</li>
<li>效率高，API的实效更加高效</li>
<li>方便，API是统一规定的</li>
</ul>
</li>
<li>传递参数：运行的程序和OS之间的参数传递<ul>
<li>使用寄存器传递参数</li>
<li>将参数存储在数据结构中，传输数据的地址</li>
<li>将参数存储在栈中，从栈中传递</li>
</ul>
</li>
</ul>
<h2 id="OS架构"><a href="#OS架构" class="headerlink" title="OS架构"></a>OS架构</h2><ul>
<li><p>简单OS架构：只有一两层的代码</p>
<p><img src="/2021/11/10/day27/day27_9.png" alt="简单OS"></p>
<ul>
<li>缺点：不安全，难以改进</li>
</ul>
</li>
<li><p>分层的OS架构：高等级可以调用低等级</p>
<p><img src="/2021/11/10/day27/day27_10.png" alt="分层OS"></p>
<ul>
<li>好处：容易debug和维护</li>
<li>缺点：效率低，难以定义分层规则</li>
</ul>
</li>
<li><p>Microkernel OS：使用Microkernel 沟通所有的API，只要kernel不崩溃就好</p>
<p><img src="/2021/11/10/day27/day27_11.png" alt="kernel"></p>
<ul>
<li>缺点：效率低</li>
<li>优点：方便扩展</li>
</ul>
</li>
<li><p>模块化的OS架构：分成很多模块，模块都处于同一个kernel中</p>
<p><img src="/2021/11/10/day27/day27_12.png" alt="模块化"></p>
</li>
<li><p>虚拟机：</p>
<p><img src="/2021/11/10/day27/day27_13.png" alt="虚拟机"></p>
<ul>
<li><p>优点：</p>
<ul>
<li>完全保护系统资源</li>
<li>可以解决系统兼容问题</li>
<li>方便研究操作系统</li>
<li>增加云计算中资源的利用率</li>
</ul>
</li>
<li><p>Vmware(Full Virtualization):</p>
<p><img src="/2021/11/10/day27/day27_14.png" alt="Vmware"></p>
<ul>
<li>在原本的OS上，user mode下运行</li>
</ul>
</li>
<li><p>Para-virtualization:Xen</p>
<p><img src="/2021/11/10/day27/day27_15.png" alt="平行"></p>
<ul>
<li>虚拟系统和原来系统不完全等价，虚拟系统必须被修改</li>
<li>虚拟系统的硬件和设备都是虚拟的</li>
<li>在zone中执行，认为自己是唯一运行的程序</li>
</ul>
</li>
<li><p>JVM：主要是编译java字节码</p>
<p><img src="/2021/11/10/day27/day27_16.png" alt="JVM"></p>
</li>
</ul>
</li>
</ul>
<h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><ul>
<li><p>程序和进程：</p>
<ul>
<li>程序：被动的，二进制码存储在磁盘上</li>
<li>进程：主动的，在内存中正在执行的程序</li>
</ul>
</li>
<li><p>进程包含：</p>
<ul>
<li>代码段</li>
<li>数据部分：全局变量</li>
<li>栈：局部变量或类</li>
<li>堆：动态分配的变量或类</li>
<li>当前状态（程序计数器，寄存器内容）</li>
<li>一些相关的资源（例如打开文件的工具）</li>
</ul>
<p><img src="/2021/11/10/day27/day27_17.png" alt="进程在内存中的状态"></p>
</li>
</ul>
<h2 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h2><ul>
<li>线程：轻量级进程，CPU处理的最小单位<ul>
<li>属于相同进程的所有线程会共享线程中的数据：代码段，数据部分和OS资源（例如打开文件和信号）</li>
</ul>
</li>
</ul>
<p><img src="/2021/11/10/day27/day27_18.png" alt="线程和进程"></p>
<ul>
<li>每个线程都有自己的：线程ID、程序计数器、寄存器组和一个栈</li>
</ul>
<h2 id="进程的状态"><a href="#进程的状态" class="headerlink" title="进程的状态"></a>进程的状态</h2><ul>
<li><p>五种状态：</p>
<ul>
<li>New：进程正在被创建</li>
<li>Ready：进程在内存中等待被分配给执行者</li>
<li>Running：正在被CPU执行</li>
<li>Waiting：进程等待其他事情完成</li>
<li>Terminated：进程完成执行，释放资源</li>
</ul>
<p><img src="/2021/11/10/day27/day27_19.png" alt="进程的五种状态"></p>
</li>
<li><p>任何时间在任何处理器上只能执行一个进程</p>
</li>
</ul>
<h2 id="进程控制块"><a href="#进程控制块" class="headerlink" title="进程控制块"></a>进程控制块</h2><ul>
<li><p>Process Control Block(PCB)：进程在被创建时，系统会创建进程控制块来记录进程的状态</p>
<ul>
<li>进程状态</li>
<li>程序计数器</li>
<li>CPU寄存器</li>
<li>CPU调度信息</li>
<li>内存管理信息</li>
<li>I/O状态信息</li>
<li>计数信息</li>
</ul>
<p><img src="/2021/11/10/day27/day27_20.png" alt="PCB"></p>
</li>
</ul>
<h2 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h2><p><img src="/2021/11/10/day27/day27_21.png" alt="上下文切换"></p>
<ul>
<li>上下文切换其实就是在保存和加载PCB，会浪费时间</li>
</ul>
<h2 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h2><ul>
<li><p>使用队列实现进程调度</p>
<p><img src="/2021/11/10/day27/day27_22.png" alt="进程队列"></p>
</li>
<li><p>Short-term scheduler（CPU scheduler）：选择哪个进程被执行并且分配CPU（<strong>Ready-&gt;Run</strong>）</p>
<ul>
<li>执行频率很高</li>
</ul>
</li>
<li><p>Long-term scheduler（job scheduler）：选择哪个进程应该被加载到内存中并且放进Ready Queue中（<strong>New-&gt;Ready</strong>）</p>
<ul>
<li>控制有多少个线程可以同时执行</li>
<li>执行频率较低</li>
<li>选择CPU和IO混合的进程，提高系统的效率</li>
</ul>
</li>
<li><p>Medium-term scheduler：选择哪个进程应该被交换进/出内存（<strong>Ready-&gt;Wait</strong>）</p>
<ul>
<li>目的：提高进程的混合度（CPU进程和IO进程），释放内存</li>
<li>现在大多数OS都没有该调度器，因为有足够的物理内存或者使用虚拟内存</li>
</ul>
<p><img src="/2021/11/10/day27/day27_23.png" alt="调度"></p>
</li>
</ul>
<h2 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h2><p><img src="/2021/11/10/day27/day27_24.png" alt="进程树"></p>
<ul>
<li><p>父子进程的关系：</p>
<ul>
<li>资源共享：全部共享、子进程获得部分父进程资源、完全不共享</li>
<li>执行顺序：父子进程同时执行、父进程等待子进程结束</li>
<li>地址空间<ul>
<li>子进程复制父进程地址，通过共享变量通信</li>
<li>子进程加载一个程序，通过消息传递通信</li>
</ul>
</li>
</ul>
</li>
<li><p>Linux创建进程：</p>
<ul>
<li><p>fork system call:分配内存给进程的一些标志信息</p>
<ul>
<li>创建一个新的进程</li>
<li>新的进程复制父进程的地址</li>
<li>父子进程同时执行</li>
<li>子进程：fork之后返回0</li>
<li>父进程：fork之后返回子进程的PID</li>
</ul>
</li>
<li><p>execlp system call：加载代码，具体给进程的标志信息赋值</p>
<ul>
<li>加载一个新的二进制文件到内存中，破坏旧的代码</li>
</ul>
</li>
<li><p>wait system call：父进程等待一个它的子进程完成</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">int</span> A;</span><br><span class="line">     <span class="comment">/* fork another process */</span></span><br><span class="line">     A = fork( );</span><br><span class="line">     <span class="keyword">if</span> (A == <span class="number">0</span>) &#123; <span class="comment">/* child process */</span></span><br><span class="line">         <span class="built_in">printf</span>(“<span class="keyword">this</span> is from child process\n”);</span><br><span class="line">         execlp(“/bin/ls”, “ls”, <span class="literal">NULL</span>);</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123; <span class="comment">/* parent process */</span></span><br><span class="line">         <span class="built_in">printf</span>(“<span class="keyword">this</span> is from parent process\n”);</span><br><span class="line">         <span class="keyword">int</span> pid = wait(&amp;status);</span><br><span class="line">         <span class="built_in">printf</span>(“Child %d completes”, pid);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="built_in">printf</span>(“process ends %d\n”, A);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2021/11/10/day27/day27_25.png" alt="执行顺序"></p>
</li>
</ul>
</li>
<li><p>进程结束：当最后一句代码执行或者exit()执行时进程会结束</p>
<ul>
<li>所有资源被释放</li>
<li>父进程可以强制结束子进程</li>
<li>级联结束：父进程结束，所有的子进程都会被结束</li>
</ul>
</li>
</ul>
<h2 id="进程间的通信"><a href="#进程间的通信" class="headerlink" title="进程间的通信"></a>进程间的通信</h2><ul>
<li><p>Interprocess Communication(IPC)：一些方法，用来在多个线程中交换数据</p>
</li>
<li><p>Independent process：不会影响或被影响其他进程</p>
</li>
<li><p>通信方法：</p>
<ul>
<li><p>共享内存：</p>
<ul>
<li>需要用户的同步</li>
<li>使用内存实现，速度快</li>
<li>使用内存地址获得数据</li>
</ul>
</li>
<li><p>消息传递</p>
<ul>
<li>不会有冲突，对少量数据效率高</li>
<li>使用发送/接收数据</li>
<li>使用系统操作完成，效率低</li>
</ul>
<p><img src="/2021/11/10/day27/day27_26.png" alt="通信方法"></p>
</li>
<li><p>网络：</p>
<ul>
<li>使用IP和Port进行交流</li>
<li>交换非结构化的字节流</li>
</ul>
</li>
<li><p>RPC（Remote Procedure Calls）：</p>
<ul>
<li>使一个程序早另一个地址空间执行</li>
<li>参数和返回值使用消息传递</li>
</ul>
<p><img src="/2021/11/10/day27/day27_27.png" alt="RPC"></p>
</li>
</ul>
</li>
</ul>
<h3 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h3><ul>
<li><p>进程需要做：</p>
<ul>
<li>建立一个共享内存的区域<ul>
<li>通常，共享内存区域位于创建共享内存的进程的地址空间中</li>
<li>参与的进程必须统一移除OS对内存的访问约束</li>
</ul>
</li>
<li>决定数据的格式和位置</li>
<li>确保数据不会被其他进程同时修改（保证同步）</li>
</ul>
<p><img src="/2021/11/10/day27/day27_28.png" alt="共享内存的实现"></p>
</li>
</ul>
<h3 id="消息传递"><a href="#消息传递" class="headerlink" title="消息传递"></a>消息传递</h3><ul>
<li><p>不仅是要通信，还要同步线程的操作</p>
</li>
<li><p>两种操作：双方都要调用这两种操作</p>
<ul>
<li>发送信息：信息的大小固定或者可变</li>
<li>接收消息</li>
</ul>
</li>
<li><p>进程需要做：</p>
<ul>
<li>建立通信的连接<ul>
<li>物理连接：网络、总线等</li>
<li>逻辑连接<ul>
<li>有向或者无向通信</li>
<li>阻塞或者非阻塞</li>
</ul>
</li>
</ul>
</li>
<li>使用发送/接收交换消息</li>
</ul>
</li>
<li><p>有向通信：</p>
<ul>
<li><p>进程之间必须有明确的名字，发送和接收都必须明确的指出另一个进程</p>
</li>
<li><p>连接会自动建立</p>
</li>
<li><p>一对一的关系</p>
</li>
<li><p>连接有可能使无向的，但通常是单向的</p>
</li>
<li><p>限制：进程的名字如果改变，之前的名字都要更新</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*producer*/</span></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">	send (consumer, nextProduced);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*consumer*/</span></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    receive (producer, nextConsumed);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>无向通信：消息会被发送到mailboxes</p>
<ul>
<li>每个mailbox都有唯一的ID</li>
<li>共享mailbox的进程之间可以通信</li>
<li>连接只会在共享mailbox的线程之间建立</li>
<li>多对多</li>
<li>连接可能是单向或者无向的</li>
<li>mailbox可以被进程或者OS拥有</li>
</ul>
<blockquote>
<p>多个线程同时读数据时，解决方法：</p>
<ul>
<li>一个链接最多连接两个进程</li>
<li>同一时间只有一个进程能够接收信息</li>
<li>系统随机选择一个进程接收信息，拒绝其他请求</li>
</ul>
</blockquote>
</li>
<li><p>阻塞：同步</p>
<ul>
<li>发送：发送方阻塞，直到消息发送到mailbox或被接收方接收</li>
<li>接收：接收方阻塞，直到接收到可用消息</li>
</ul>
</li>
<li><p>非阻塞：异步</p>
<ul>
<li>发送：发送完消息后，恢复操作</li>
<li>接收：接收方接收到有用消息或者null</li>
</ul>
<blockquote>
<p>blocking和non-blocking的Buffer实现：</p>
<ul>
<li>O大小：阻塞</li>
<li>限制大小：如果buffer满了，发送方将会阻塞</li>
<li>无限制大小：发送方永远不会阻塞</li>
</ul>
</blockquote>
</li>
</ul>
<h3 id="socket"><a href="#socket" class="headerlink" title="socket"></a>socket</h3><p>  <img src="/2021/11/10/day27/day27_29.png" alt="socket"></p>
<ul>
<li>建立连接时，为了能够实现多个用户的连接，每次建立连接都是创建一个新的线程</li>
</ul>
<h3 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h3><ul>
<li><p>stubs：客户端代理，真实的程序在服务器上执行</p>
<p><img src="/2021/11/10/day27/day27_30.png" alt="RPC"></p>
</li>
<li><p>Client stub：</p>
<ul>
<li>将参数打包进信息（参数整理：操作系统不同，参数需要修改等问题）</li>
<li>使用OS直接发送信息给服务器</li>
<li>等待服务器的结果返回</li>
</ul>
</li>
<li><p>Server stub：</p>
<ul>
<li>从客户端接收请求</li>
<li>解析参数</li>
<li>调用响应的程序</li>
<li>返回结果给客户端</li>
</ul>
</li>
</ul>
<h1 id="多线程编程"><a href="#多线程编程" class="headerlink" title="多线程编程"></a>多线程编程</h1><ul>
<li>每个线程都有自己的<strong>线程控制块</strong>：线程ID，程序计数器，寄存器集合和栈</li>
<li>多线程的好处：<ul>
<li>响应快，且稳定</li>
<li>资源共享</li>
<li>性价比高</li>
<li>多处理器的应用</li>
</ul>
</li>
<li>多线程编程的挑战：<ul>
<li>分割活动：将一个程序分割到多个任务中</li>
<li>平衡：将任务均衡分配到核心中</li>
<li>数据分割：分配数据的权限并且被每个任务操作</li>
<li>数据依赖：同步数据的获得</li>
<li>测试和调试</li>
</ul>
</li>
</ul>
<h2 id="线程模型"><a href="#线程模型" class="headerlink" title="线程模型"></a>线程模型</h2><ul>
<li><p>用户线程：被用户层的线程包管理</p>
<ul>
<li>创建和管理都比较快</li>
<li>如果只有一个内核线程，一个用户线程阻塞，所有线程都会被阻塞</li>
</ul>
</li>
<li><p>内核线程：直接被OS管理的线程</p>
<ul>
<li>创建和管理都很慢</li>
<li>如果一个线程被阻塞，内核线程可以调度其他线程执行</li>
</ul>
</li>
<li><p>线程模型：</p>
<ul>
<li>Many-to-One<ul>
<li>多个用户线程对应一个内核线程</li>
<li>使用在不支持内核线程的系统上</li>
<li>在用户层管理线程，效率高</li>
<li>缺点：一个线程阻塞会导致整个系统阻塞；一个时间只有一个线程可以访问内核线程，多线程无法同时在多个处理器上运行</li>
</ul>
</li>
<li>One-to-One<ul>
<li>单个用户线程对应单个内核线程（内核线程的数量有限制）</li>
<li>更大的并发性</li>
<li>缺点：创建一个线程就要创建一个内核线程</li>
</ul>
</li>
<li>Many-to-Many<ul>
<li>多个用户线程对应多个内核线程（内核线程不多于用户线程）</li>
<li>可以创建足够多的用户线程</li>
<li>相应的内核线程可以同时在多处理器上运行</li>
<li>一个线程阻塞，不会导致整个系统阻塞</li>
</ul>
</li>
</ul>
<p><img src="/2021/11/10/day27/day27_31.png" alt="线程模型"></p>
</li>
</ul>
<h2 id="线程包"><a href="#线程包" class="headerlink" title="线程包"></a>线程包</h2><h3 id="共享内存编程"><a href="#共享内存编程" class="headerlink" title="共享内存编程"></a>共享内存编程</h3><ul>
<li>多个线程，通过一个共享内存空间进行交流和工作</li>
<li>优点：比消息传递更快、更有效率</li>
<li>问题：同步性、死锁和缓存一致性</li>
</ul>
<h3 id="Linux-Threads"><a href="#Linux-Threads" class="headerlink" title="Linux Threads"></a>Linux Threads</h3><ul>
<li><p>Linux不支持多线程，但是用户可以使用Pthreads实现多线程</p>
</li>
<li><p>fork()：创建一个新的进程并且复制父进程的数据</p>
</li>
<li><p>clone()：创建新的进程和一个指向关联数据的链接</p>
</li>
<li><p>clone中有许多flag用来指定父子进程的数据共享等级</p>
<p><img src="/2021/11/10/day27/day27_32.png" alt="clone-flag"></p>
</li>
</ul>
<h2 id="相关问题"><a href="#相关问题" class="headerlink" title="相关问题"></a>相关问题</h2><ul>
<li><p>fork()和exec()：</p>
<ul>
<li>一个线程使用fork()，有的操作系统会只复制当前线程，有的操作系统会复制所有线程</li>
<li>execlp()会替换整个进程</li>
</ul>
</li>
<li><p>线程撤销：</p>
<ul>
<li>异步撤销：一个线程会立刻撤销目标线程</li>
<li>延期撤销：目标线程会周期性检测自己是否被撤销，被撤销时会继续直行到撤销点，之后再被安全撤销</li>
</ul>
</li>
<li><p>信号处理：信号可以使进程知道某些事情已经发生</p>
<ul>
<li>过程：<ul>
<li>特定的事件产生信号</li>
<li>信号被送到进程</li>
<li>信号被处理</li>
</ul>
</li>
<li>情形：<ul>
<li>将信号发送给所有的线程</li>
<li>将信号发送给指定的线程</li>
<li>将信号发送给信号适用的线程</li>
<li>分配一个特定的线程接收所有的信号</li>
</ul>
</li>
</ul>
</li>
<li><p>线程池：创建一些线程在线程池里，等待工作</p>
</li>
<li><p>优点：时间快；可以控制线程数</p>
</li>
</ul>
<h1 id="进程调度-1"><a href="#进程调度-1" class="headerlink" title="进程调度"></a>进程调度</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul>
<li>I/O burst：处理I/O的程序</li>
<li>CPU burst：进行计算的程序</li>
<li>CPU-bound 程序：有许多的长CPU burst</li>
<li>I/O-bound程序：有许多短的CPU burst</li>
</ul>
<p><img src="/2021/11/10/day27/day27_33.png" alt="Burst Cycle"></p>
<ul>
<li><p>CPU调度决定会在以下情形发生：</p>
<ul>
<li>从running到waiting</li>
<li>从running到ready</li>
<li>从waiting到ready</li>
<li>terminates</li>
</ul>
</li>
<li><p>非抢占调度：</p>
<ul>
<li>会在running到waiting、terminates这两个状态做调度</li>
</ul>
</li>
<li><p>抢占式调度：</p>
<ul>
<li>在所有情形做调度</li>
</ul>
</li>
<li><p>抢占式问题：</p>
<ul>
<li>共享数据不一致：<ul>
<li>需要进程同步</li>
<li>处理花费时间</li>
</ul>
</li>
<li>影响OS内核的设计</li>
</ul>
</li>
<li><p>分发器：将CPU的控制权交给调度器选择的进程</p>
<ul>
<li>上下文切换</li>
<li>跳转到指定程序的合适位置</li>
</ul>
</li>
</ul>
<h2 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h2><ul>
<li>指标：<ul>
<li>周转时间：提交到完成的事件</li>
<li>等待时间：在ready queue中总的等待时间，不计算I/O的时间</li>
<li>响应时间：提交到第一个响应产生的时间</li>
</ul>
</li>
</ul>
<h3 id="FCFS调度"><a href="#FCFS调度" class="headerlink" title="FCFS调度"></a>FCFS调度</h3><ul>
<li><p>First-Come,First-Served调度：先到达的先执行</p>
<p><img src="/2021/11/10/day27/day27_34.png" alt="FCFS"></p>
</li>
<li><p>小线程排在大线程之前可以获得更好的效果</p>
</li>
</ul>
<h3 id="SJF调度"><a href="#SJF调度" class="headerlink" title="SJF调度"></a>SJF调度</h3><ul>
<li><p>Shortest-Job-First调度：对FCFS的改进，等待时间更短。最短的线程先执行</p>
</li>
<li><p>非抢占式和抢占式的结果不同：</p>
<ul>
<li><p>非抢占式：线程运行过程中不能打断</p>
<p><img src="/2021/11/10/day27/day27_35.png" alt="非抢占式"></p>
</li>
<li><p>抢占式：线程运行过程中可以打断，要减去已经执行的时间</p>
<p><img src="/2021/11/10/day27/day27_36.png" alt="抢占式"></p>
</li>
</ul>
</li>
<li><p>SJF的困难：无法知道下一个CPU burst的时间</p>
</li>
<li><p><strong>Approximate SJF</strong>：下一个burst的时间可以使用之前的CPU burst的时间来估计</p>
<p><img src="/2021/11/10/day27/day27_37.png" alt="估计时间"></p>
</li>
</ul>
<h3 id="Priority-调度"><a href="#Priority-调度" class="headerlink" title="Priority 调度"></a>Priority 调度</h3><ul>
<li>对每个进程都给定一个优先级，CPU会执行优先级最高的进程<ul>
<li>抢占式和非抢占式不同</li>
</ul>
</li>
<li>SJF也可以看作是Priority调度</li>
<li>问题：低优先级的程序一直不执行<ul>
<li>解决：每过一段时间增加进程的优先级</li>
</ul>
</li>
</ul>
<h3 id="RR调度"><a href="#RR调度" class="headerlink" title="RR调度"></a>RR调度</h3><ul>
<li><p>Round-Robin调度：每个进程获得CPU的一小段时间</p>
<ul>
<li>在使用时间结束后，被抢占的进程会被加到ready queue的末尾</li>
<li>使用时间如果很大，会产生FIFO的效果</li>
<li>使用时间如果很小，频繁上下文切换会增大开销</li>
</ul>
<p><img src="/2021/11/10/day27/day27_38.png" alt="RR"></p>
</li>
</ul>
<h3 id="Multilevel-Queue调度"><a href="#Multilevel-Queue调度" class="headerlink" title="Multilevel Queue调度"></a>Multilevel Queue调度</h3><ul>
<li>Ready queue被分割为独立的queues，每个queue都有自己的调度算法</li>
<li>不同的queue之间需要调度：<ul>
<li>固定的优先级调度：使用概率进行选择</li>
<li>每个queue获得一个确定的CPU时间</li>
</ul>
</li>
</ul>
<h3 id="Multilevel-Feedback-Queue调度"><a href="#Multilevel-Feedback-Queue调度" class="headerlink" title="Multilevel Feedback Queue调度"></a>Multilevel Feedback Queue调度</h3><ul>
<li><p>一个进程可以在多个queue中移动；使用年龄机制，避免进程不会被执行</p>
</li>
<li><p>根据CPU burst的特征将进程分类：</p>
<ul>
<li>I/O-bound 和交互式进程会在优先级更高的queue中</li>
<li>CPU-bound的进程会在优先级低的queue中</li>
</ul>
<p><img src="/2021/11/10/day27/day27_39.png" alt="Multilevel Feedback Queue"></p>
</li>
</ul>
<h2 id="特殊调度情形"><a href="#特殊调度情形" class="headerlink" title="特殊调度情形"></a>特殊调度情形</h2><h3 id="Multi-Processor-调度"><a href="#Multi-Processor-调度" class="headerlink" title="Multi-Processor 调度"></a>Multi-Processor 调度</h3><ul>
<li><p>非对称多处理器：有一个处理器来做调度</p>
</li>
<li><p>对称多处理器：每个处理器都自己做调度</p>
</li>
<li><p>处理器依赖性：一个进程会和一个处理器依赖，他只能由这个处理器处理</p>
<ul>
<li>一个进程会将他最常用的数据存在运行它的处理器的缓存中</li>
<li>清空并且重装高速缓存会有很大的消耗</li>
<li>软依赖：进程可以在不同处理器之间迁移</li>
<li>硬依赖：进程不能迁移到其他处理器</li>
</ul>
</li>
<li><p>负载均衡：保持所有的处理器处理的任务均衡</p>
<ul>
<li>push迁移：将高负载处理器的任务移动到低负载的处理器</li>
<li>pull迁移：低负载的处理器主动处理高负载处理器的任务</li>
</ul>
</li>
</ul>
<h3 id="Multi-core-处理器调度"><a href="#Multi-core-处理器调度" class="headerlink" title="Multi-core 处理器调度"></a>Multi-core 处理器调度</h3><ul>
<li>多核心处理器：<ul>
<li>更快，能耗更低</li>
<li>内存停顿：当获得内存时，会等待很长的时间直到数据变得有效</li>
</ul>
</li>
<li>利用内存停顿的时间，处理其他的线程，一个core实现多线程<ul>
<li>coarse-grained：当内存停顿，处理其他线程时，清除指令流水线的信息</li>
<li>fine-grained：当内存停顿，处理其他线程时，开辟内存空间存储当前流水线信息</li>
</ul>
</li>
<li>多线程多内心系统的调度：<ul>
<li>第一层：选择每个逻辑处理器应该运行的软件线程</li>
<li>第二层：每个核心决定哪个硬件线程运行</li>
</ul>
</li>
</ul>
<h3 id="Real-Time-调度"><a href="#Real-Time-调度" class="headerlink" title="Real-Time 调度"></a>Real-Time 调度</h3><ul>
<li>每个任务都有一个deadline</li>
</ul>
<h4 id="Rate-Monotonic（RM）-算法"><a href="#Rate-Monotonic（RM）-算法" class="headerlink" title="Rate-Monotonic（RM） 算法"></a>Rate-Monotonic（RM） 算法</h4><ul>
<li><p>短周期对应高优先级，优先级是固定的</p>
<p><img src="/2021/11/10/day27/day27_40.png" alt="周期出现"></p>
</li>
</ul>
<h4 id="Earliest-Deadline-First-EDF-算法"><a href="#Earliest-Deadline-First-EDF-算法" class="headerlink" title="Earliest-Deadline-First(EDF) 算法"></a>Earliest-Deadline-First(EDF) 算法</h4><ul>
<li>优先级不固定，任务的优先级由deadline决定</li>
<li>deadline越低，优先级越高</li>
</ul>
<h2 id="操作系统实例"><a href="#操作系统实例" class="headerlink" title="操作系统实例"></a>操作系统实例</h2><h3 id="Solaris调度"><a href="#Solaris调度" class="headerlink" title="Solaris调度"></a>Solaris调度</h3><ul>
<li><p>基于优先级的multilevel feedback queue调度</p>
</li>
<li><p>线程的分类，确定优先级：</p>
<ul>
<li><p>real-time,system,time sharing,interactive,fair share,fixed priority</p>
<p><img src="/2021/11/10/day27/day27_41.png" alt="确定优先级"></p>
</li>
<li><p>每个种类都有自己的调度算法</p>
</li>
<li><p>每个优先级都有对应的time quantum，超过time quantum会降低优先级；从sleep状态返回的时候，优先级也会相应改变</p>
<p><img src="/2021/11/10/day27/day27_42.png" alt="优先级变化"></p>
</li>
</ul>
</li>
</ul>
<h3 id="Windows-XP调度"><a href="#Windows-XP调度" class="headerlink" title="Windows XP调度"></a>Windows XP调度</h3><ul>
<li><p>和Solaris相同的调度方法</p>
<p><img src="/2021/11/10/day27/day27_43.png" alt="Windows XP优先级分类"></p>
</li>
</ul>
<h3 id="Linux调度"><a href="#Linux调度" class="headerlink" title="Linux调度"></a>Linux调度</h3><ul>
<li><p>基于抢占式优先级的调度：</p>
<ul>
<li>只允许用户模式下的进程被抢占</li>
<li>两种不同的进程优先级范围</li>
<li>高优先级对应长time quantum</li>
</ul>
<p><img src="/2021/11/10/day27/day27_44.png" alt="Linux调度"></p>
</li>
<li><p>调度算法：</p>
<ul>
<li>一个运行的线程可以一直运行，只要他有剩余的time quantum</li>
<li>当一个线程使用完它的time quantum，它会过期并且不能执行</li>
<li>新的优先级和time quantum会被分配给过期后的线程</li>
</ul>
</li>
</ul>
<h1 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h1><ul>
<li>Race condition：共享数据的值取决于最后完成进程</li>
<li>相互排斥：同时只有一个程序可以处理关键部分</li>
<li>进展：如果没有进程操作关键部分，同时由其他进程想要操作关键部分，这些进程不能被无限期推迟</li>
<li>等待限制：一个进程请求进入关键部分后，其他进程进入关键部分的次数必须有一个限制（等待时间有限）</li>
</ul>
<h2 id="软件解决"><a href="#软件解决" class="headerlink" title="软件解决"></a>软件解决</h2><ul>
<li><p>两个进程算法：</p>
<p><img src="/2021/11/10/day27/day27_45.png" alt="两进程"></p>
</li>
<li><p>Peterson’s solution：解决progress</p>
<p><img src="/2021/11/10/day27/day27_46.png" alt="Peterson"></p>
</li>
<li><p>Bakery 算法（N processes）:</p>
<ul>
<li>在同步之前，每个进程都会有一个标记”#”，并且带有编号，编号小的进程优先级高</li>
<li>如果编号相同，先进入的进程先执行</li>
</ul>
<p><img src="/2021/11/10/day27/day27_47.png" alt="Bakery"></p>
</li>
</ul>
<h2 id="硬件支持"><a href="#硬件支持" class="headerlink" title="硬件支持"></a>硬件支持</h2><ul>
<li><p>原子操作：不会被打断的单元</p>
</li>
<li><p>TestAndSet()：</p>
<p><img src="/2021/11/10/day27/day27_48.png" alt="TestAndSet"></p>
</li>
<li><p>Swap()：</p>
<p><img src="/2021/11/10/day27/day27_49.png" alt="Swap"></p>
</li>
</ul>
<h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><ul>
<li><p>信号量：本质是一个counter，整数型变量。标记了特定可用资源的数量</p>
<ul>
<li>record =1：二值化信号量，互斥锁</li>
<li>record&gt;1：计数信号量</li>
</ul>
</li>
<li><p>两种原子操作获得：wait和signal</p>
</li>
<li><p><strong>自旋锁</strong>实现：busy的实现（需要卡在while）</p>
<p><img src="/2021/11/10/day27/day27_50.png" alt="SpinLock"></p>
</li>
</ul>
<p><img src="/2021/11/10/day27/day27_51.png" alt="例子"></p>
<ul>
<li><p>Non-busy实现：信号量中添加一个队列</p>
<ul>
<li><p>可能会采用不同的排队策略（FIFO,FILO等）</p>
</li>
<li><p>wait和signal：</p>
<ul>
<li><p>使用系统命令：block()和wakeup()</p>
</li>
<li><p>必须是原子操作</p>
<p><img src="/2021/11/10/day27/day27_52.png" alt="Non-busy"></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>Non-busy使用了系统命令，会比较慢。</p>
<p>等待时间久使用Non-busy，等待时间短使用自旋锁</p>
</blockquote>
<h2 id="死锁和饥饿"><a href="#死锁和饥饿" class="headerlink" title="死锁和饥饿"></a>死锁和饥饿</h2><ul>
<li>死锁：两个进程互相等待对方的资源释放</li>
<li>饥饿：进程一直不执行<ul>
<li>原因：LIFO在信号量中，死锁等</li>
</ul>
</li>
</ul>
<h2 id="经典同步化问题"><a href="#经典同步化问题" class="headerlink" title="经典同步化问题"></a>经典同步化问题</h2><h3 id="生产者消费者问题"><a href="#生产者消费者问题" class="headerlink" title="生产者消费者问题"></a>生产者消费者问题</h3><ul>
<li>生产者：在缓存中存数据，缓存满时等待</li>
<li>消费者：使用缓存中数据，缓存空时等待</li>
</ul>
<h3 id="读写问题"><a href="#读写问题" class="headerlink" title="读写问题"></a>读写问题</h3><ul>
<li>一组共享的数据对象，一组读操作和写操作</li>
<li>同时只能有一个写操作有权限操作数据</li>
<li>first RW 问题：读操作不需要等待，除非有写操作在执行</li>
<li>second RW问题：写操作一旦就绪，在共享数据权限开放后，立马执行。写操作优先级大于读操作</li>
</ul>
<h3 id="哲学家吃饭问题"><a href="#哲学家吃饭问题" class="headerlink" title="哲学家吃饭问题"></a>哲学家吃饭问题</h3><ul>
<li>一个人有两种状态：思考或者吃饭<ul>
<li>思考：不会和其他人有交流</li>
<li>吃饭：需要手上有两个筷子</li>
<li>一个人一次只能拿起一个筷子</li>
<li>完成吃饭：放下手中所有的筷子</li>
</ul>
</li>
</ul>
<h2 id="Monitor"><a href="#Monitor" class="headerlink" title="Monitor"></a>Monitor</h2><ul>
<li><p>Monitor模式类似OO的概念</p>
<ul>
<li>一个有Monitor的进程只能获得本地变量和形式参数</li>
<li>本地变量只能被本地程序使用、</li>
</ul>
</li>
<li><p>Monitor保证同时只能有一个进程在Monitor中被激活</p>
</li>
<li><p>解决哲学家吃饭问题：</p>
<p><img src="/2021/11/10/day27/day27_53.png" alt="monitor"></p>
<p><img src="/2021/11/10/day27/day27_54.png" alt="具体实现"></p>
</li>
</ul>
<h2 id="原子事务"><a href="#原子事务" class="headerlink" title="原子事务"></a>原子事务</h2><ul>
<li>事务：完成一个逻辑操作的一系列操作</li>
<li>原子事务：要么完成，要么不执行</li>
<li>回滚原理：<ul>
<li>Log：在稳定存储器中记录所有被事务修改的数据，操作失败之后就可以回滚</li>
<li>checkpoint：当事务失败时，需要从日志中决定哪些事务需要重新进行。在稳定存储器中记录checkpoint就可以直接恢复，不用再进行查找</li>
</ul>
</li>
</ul>
<h1 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h1><ul>
<li>死锁问题：一组进程中的每个进程都持有一些资源，并且等待被其他进程获得的资源</li>
<li>死锁产生的必要条件：<ul>
<li>互斥：一个资源同一时间只能被一个进程使用</li>
<li>持有和等待：持有资源，等待其他资源</li>
<li>没有抢占：资源只能被进程主动放弃</li>
<li>循环等待：一组进程循环等待</li>
</ul>
</li>
</ul>
<h2 id="系统模型"><a href="#系统模型" class="headerlink" title="系统模型"></a>系统模型</h2><p><img src="/2021/11/10/day27/day27_55.png" alt="模型定义"></p>
<ul>
<li><p>资源分配图：</p>
<p><img src="/2021/11/10/day27/day27_56.png" alt="资源分配图"></p>
<ul>
<li>资源分配图中出现cycle，就有可能出现DeadLock，也可能没有</li>
</ul>
</li>
<li><p>DeadLock检测：</p>
<ul>
<li>如果一个资源分配图没有cycle，就不存在DeadLock</li>
<li>如果存在cycle:<ul>
<li>一个资源类型只有一个实例：DeadLock</li>
<li>一个资源类型有多个实例：可能出现DeadLock</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="处理死锁"><a href="#处理死锁" class="headerlink" title="处理死锁"></a>处理死锁</h2><ul>
<li>保证系统不会进入DeadLock<ul>
<li>死锁预防：保证4个条件不同时成立</li>
<li>死锁避免：动态监测资源分配状态</li>
</ul>
</li>
<li>允许进入死锁状态，但会恢复<ul>
<li>死锁检测</li>
<li>死锁恢复</li>
</ul>
</li>
<li>忽略死锁问题：大多数操作系统使用，包括UNIX</li>
</ul>
<h2 id="死锁预防和死锁避免"><a href="#死锁预防和死锁避免" class="headerlink" title="死锁预防和死锁避免"></a>死锁预防和死锁避免</h2><h3 id="死锁预防"><a href="#死锁预防" class="headerlink" title="死锁预防"></a>死锁预防</h3><ul>
<li>破坏<strong>互斥</strong>：在共享资源上不要求互斥（只能由一个进程操控）</li>
<li>破坏<strong>持有并等待</strong>：资源利用率低<ul>
<li>当进程请求其他资源时，释放持有的资源</li>
<li>预先分配所有资源</li>
</ul>
</li>
<li>破坏<strong>非抢占</strong>：<ul>
<li>当进程请求其他资源时，它所持有的资源是可抢占的</li>
<li>适用于状态可以被轻易保存和恢复的资源</li>
</ul>
</li>
<li>破坏<strong>循环等待</strong>：<ul>
<li>对总的资源类型进行总的排序</li>
<li>进程请求资源按照升序<ul>
<li>当请求R<del>k</del>资源时，必须释放所有的排序大于R<del>k</del>的资源</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="死锁避免"><a href="#死锁避免" class="headerlink" title="死锁避免"></a>死锁避免</h3><h4 id="一种资源单个实例"><a href="#一种资源单个实例" class="headerlink" title="一种资源单个实例"></a>一种资源单个实例</h4><ul>
<li><p>基于资源分配图的环形检测：</p>
<p><img src="/2021/11/10/day27/day27_57.png" alt="资源分配图定义"></p>
<ul>
<li><p>Clain edge：考虑潜在情况，避免死锁</p>
</li>
<li><p>只有在不存在环的情况下才会允许分配资源（R<del>2</del>不允许分配给P<del>2</del>）</p>
</li>
</ul>
</li>
</ul>
<h4 id="一种资源多个实例"><a href="#一种资源多个实例" class="headerlink" title="一种资源多个实例"></a>一种资源多个实例</h4><ul>
<li><p>基于安全序列检测的banker算法:</p>
<ul>
<li>安全状态：存在一组分配方案，可以满足所有进程的请求。不存在DeadLock<ul>
<li>这些分配方案叫做安全序列</li>
</ul>
</li>
<li>非安全状态：可能存在DeadLock</li>
<li>保证系统不会进入非安全状态</li>
</ul>
<p><img src="/2021/11/10/day27/day27_59.png" alt="举例"></p>
<p><img src="/2021/11/10/day27/day27_58.png" alt="安全序列"></p>
</li>
<li><p>寻找安全序列：</p>
<ul>
<li>假设进程需要最多的资源</li>
<li>寻找使用空闲资源能够满足的进程（找不到进程，非安全状态）</li>
<li>释放该进程的资源</li>
<li>继续寻找进程</li>
</ul>
</li>
</ul>
<h2 id="死锁检测和死锁恢复"><a href="#死锁检测和死锁恢复" class="headerlink" title="死锁检测和死锁恢复"></a>死锁检测和死锁恢复</h2><ul>
<li>死锁检测：<ul>
<li>一种资源一个实例：使用资源分配图，不管隐藏的状态（claim edge），只检测目前是否有环</li>
<li>一种资源多个实例：使用banker算法，不考虑进程最大资源数，只考虑目前占有的资源。如果没有找到安全序列，<strong>可能</strong>会出现DeadLock</li>
</ul>
</li>
<li>死锁恢复：<ul>
<li>进程结束：<ul>
<li>丢弃所有死锁的进程</li>
<li>一次丢弃一个死锁进程，直到死锁解除<ul>
<li>问题：哪一个进程应该被第一个丢弃？</li>
</ul>
</li>
</ul>
</li>
<li>资源抢占：<ul>
<li>选择一个允许被抢占的资源：哪一个资源被抢占？</li>
<li>回滚：部分回滚或整体回滚？</li>
<li>饥饿：同一个进程一直被抢占？</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="地址绑定"><a href="#地址绑定" class="headerlink" title="地址绑定"></a>地址绑定</h3><ul>
<li>编译期绑定： 程序开始地址固定，如果要改变程序开始地址需要重编译</li>
<li>加载期绑定：编译期固定一个寄存器作为初始地址，加载时改变寄存器的值，改变程序执行地址。如果要改变程序开始的位置，需要重新加载</li>
<li>执行期绑定：程序内的地址为<strong>虚拟地址</strong>，程序运行时，MMU会将虚拟地址映射到真实地址</li>
</ul>
<p><img src="/2021/11/10/day27/day27_60.png" alt="MMU"></p>
<ul>
<li>逻辑地址和物理地址：<ul>
<li>逻辑地址：CPU产生；编程可见的地址</li>
<li>物理地址：内存模块可见的地址</li>
</ul>
</li>
</ul>
<h3 id="动态加载"><a href="#动态加载" class="headerlink" title="动态加载"></a>动态加载</h3><ul>
<li>动态加载：程序在调用时，才分配内存空间</li>
</ul>
<p><img src="/2021/11/10/day27/day27_61.png" alt="动态加载"></p>
<h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><ul>
<li>静态链接：库会被加载器嵌入程序中，放在内存里<ul>
<li>浪费内存：会链接重复代码</li>
<li>执行更快</li>
</ul>
</li>
<li>动态链接：执行时再进行链接<ul>
<li>不会链接重复代码</li>
<li>内存中会存有每个库应用的镜像</li>
<li>引用库在链接时，会判断是否已经存在，存在就不再链接</li>
</ul>
</li>
</ul>
<h2 id="Swapping"><a href="#Swapping" class="headerlink" title="Swapping"></a>Swapping</h2><ul>
<li>一个进程可以从内存交换到备份空间中，之后再交换到内存中进行执行</li>
<li>进程只有在idle状态下才能被交换（I/O也要idle）</li>
<li>交换时间主要消耗再传输时间上<br><img src="/2021/11/10/day27/day27_62.png" alt="Swapping"></li>
</ul>
<h2 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h2><h3 id="连续内存分配"><a href="#连续内存分配" class="headerlink" title="连续内存分配"></a>连续内存分配</h3><ul>
<li>固定切割分配：每个进程分配一段固定大小</li>
<li>变化大小分割：不同大小的连续内存空间<ul>
<li>会有不同大小的Hole分散在内存中，会产生内存浪费</li>
<li>First-Fit：分配第一个合适的Hole给进程</li>
<li>Best-Fit：分配最合适的Hole给进程</li>
<li>Worst-fit：分配最大的Hole给进程</li>
</ul>
</li>
<li>碎片：<ul>
<li>外部碎片：在变化大小分割发生。总的空闲空间可以满足一个请求，但是没有连续的空间可以满足</li>
<li>内部碎片：固定大小分割发生。分配给一个进程的内存，没有用完的部分</li>
<li>解决方案：<strong>压缩</strong>。定期清理内存空间，把空闲的内存压缩在一起</li>
</ul>
</li>
</ul>
<h3 id="不连续内存分配"><a href="#不连续内存分配" class="headerlink" title="不连续内存分配"></a>不连续内存分配</h3><h4 id="固定大小的内存分配——分页"><a href="#固定大小的内存分配——分页" class="headerlink" title="固定大小的内存分配——分页"></a>固定大小的内存分配——分页</h4><ul>
<li><strong>分页</strong>：将物理内存切割为固定大小的内存块，叫做frames。逻辑空间分割成相同大小的块，叫做pages<ul>
<li>n个pages需要n个frames对应</li>
<li>建立page table将逻辑地址映射到物理地址</li>
</ul>
</li>
<li>逻辑地址分为两部分：<ul>
<li>Page number：表示存在于哪个Page中，经过page table映射，得到每个page的基础物理地址</li>
<li>Page offset：表示存在于Page中那个位置，page和frame大小相同</li>
<li><strong>Physical addr = page base addr + page offset</strong></li>
</ul>
</li>
</ul>
<p><img src="/2021/11/10/day27/day27_63.png" alt="地址映射"></p>
<ul>
<li><p>释放frames:空闲的frames会被重新加入page table</p>
<p><img src="/2021/11/10/day27/day27_64.png" alt="free frames"></p>
</li>
<li><p>page/frame大小：</p>
<ul>
<li>通常是2的指数</li>
<li>4kb/8kb比较常见</li>
<li>设置太大：内部碎片会比较多</li>
<li>设置太小：page table很大，程序所需的page会变多，效率低</li>
</ul>
</li>
<li><p>page table存在于memory中：</p>
<ul>
<li>page-table 基础寄存器（PTBR）：page table的物理内存地址，存放在<strong>进程控制块</strong>中，在上下文切换时会改变PTBR的值</li>
<li>在读内存时都需要先读取PTBR，再读取进程的物理地址，会造成时间浪费，可以使用**Translation Look-aside Buffers(TLB)**解决</li>
</ul>
</li>
<li><p>Associative Memory：所有内存entry都可以同时被获得，但是内存entry的数量是有限的，并行查询</p>
<p><img src="/2021/11/10/day27/day27_65.png" alt="TLB实现基础"></p>
</li>
<li><p>TLB：基于Associative Memory实现，类似cache，存在于MMU中，属于硬件资源</p>
<ul>
<li>由于Associative Memory被所有进程共享，在进行上下文切换后，由于不同进程对应不同page table<ul>
<li>需要flush Associative Memory</li>
<li>或者在Associative Memory中增加一列表示PID</li>
</ul>
</li>
</ul>
<p><img src="/2021/11/10/day27/day27_66.png" alt="TLB"></p>
</li>
<li><p>内存保护：</p>
<ul>
<li>每一个page都有一些保护位：例如一个bit定义权限，有效/无效位，长度等</li>
</ul>
<p><img src="/2021/11/10/day27/day27_67.png" alt="valid-invalid bit"></p>
</li>
<li><p>共享Page：分页允许进程共享可重入的代码</p>
<ul>
<li>可重入代码：在运行时不会改变</li>
<li>物理内存中只需要存一份共享代码</li>
<li>两个或多个虚拟地址映射到同一个物理地址</li>
<li>进程保存一份自己私有数据和代码的复制</li>
</ul>
</li>
<li><p>Page table 内存结构：减小page table的size</p>
<ul>
<li><p>分层分页：将逻辑地址空间分割成多个page tables，不需要很大的连续空间</p>
<p><img src="/2021/11/10/day27/day27_68.png" alt="分层"></p>
<ul>
<li>分层越多，读取page table的时间越长</li>
</ul>
</li>
<li><p>哈希page table：和分层分页的结构相同，但outer-page table的大小可以自己控制</p>
<ul>
<li>hash之后，发生碰撞需要遍历寻找到底是哪个page</li>
</ul>
<p><img src="/2021/11/10/day27/day27_69.png" alt="哈希"></p>
<ul>
<li><p>改进：发生碰撞，进行遍历时可以同时遍历多个page进行比对</p>
<p><img src="/2021/11/10/day27/day27_70.png" alt="哈希改进"></p>
</li>
</ul>
</li>
<li><p>Inverted Page Table：使用frame table，将frame映射到page</p>
<ul>
<li>frame table中的entry都包含：PID和Page Number</li>
<li>frame table大小不会改变</li>
<li>缺点：无法做共享；每次都需要遍历frame table，速度慢</li>
</ul>
<p><img src="/2021/11/10/day27/day27_71.png" alt="Inverted"></p>
</li>
</ul>
</li>
</ul>
<h4 id="可变大小的内存分配——分割"><a href="#可变大小的内存分配——分割" class="headerlink" title="可变大小的内存分配——分割"></a>可变大小的内存分配——分割</h4><ul>
<li><p>逻辑地址：（seg#,offset）</p>
<ul>
<li>offset和物理地址长度相同</li>
</ul>
</li>
<li><p>Segmentation table：</p>
<ul>
<li>每个entry有两部分:Base(开始的物理地址)和Limit(segment的长度)</li>
</ul>
<p><img src="/2021/11/10/day27/day27_72.png" alt="Segmentation"></p>
</li>
</ul>
<ul>
<li><p>共享：共享代码分割到相同的内存中</p>
<p><img src="/2021/11/10/day27/day27_73.png" alt="共享"></p>
</li>
<li><p>内存保护：</p>
<ul>
<li>保护位：定义分割段只读、读写等权限</li>
</ul>
</li>
</ul>
<h4 id="分割和分页"><a href="#分割和分页" class="headerlink" title="分割和分页"></a>分割和分页</h4><ul>
<li><p>在逻辑地址空间中使用分割，在物理地址中使用分页</p>
<p><img src="/2021/11/10/day27/day27_74.png" alt="结合"></p>
</li>
<li><p>实例：Intel Pentium</p>
<p><img src="/2021/11/10/day27/day27_75.png" alt="举例（1）"></p>
</li>
</ul>
<p><img src="/2021/11/10/day27/day27_76.png" alt="分割"></p>
<p><img src="/2021/11/10/day27/day27_77.png" alt="分页"></p>
<p><img src="/2021/11/10/day27/day27_78.png" alt="练习"></p>
<h1 id="虚拟内存管理"><a href="#虚拟内存管理" class="headerlink" title="虚拟内存管理"></a>虚拟内存管理</h1><ul>
<li>提高内存的使用率，没有真正使用的东西不放进内存中</li>
<li>虚拟内存：将用户的逻辑内存和物理内存分隔开<ul>
<li>可以运行很大的程序</li>
<li>增加CPU/资源的利用率</li>
<li>简化编程任务</li>
<li>程序运行更快</li>
</ul>
</li>
</ul>
<h2 id="Demand-Paging"><a href="#Demand-Paging" class="headerlink" title="Demand Paging"></a>Demand Paging</h2><ul>
<li><p>只有在需要的时候page才会被加载进内存，而不是整个程序加载进内存</p>
<ul>
<li>I/O操作减少</li>
<li>需要的内存减少</li>
</ul>
</li>
<li><p>当有一个page的引用时，page被需要</p>
<ul>
<li>无效引用则抛弃</li>
<li>没有在内存中，加载进内存</li>
</ul>
</li>
<li><p>swapper是交换整个进程，pager只是交换一个page</p>
</li>
<li><p>硬件支持：</p>
<ul>
<li>Page Table：有效/无效位</li>
<li>二级内存（备份空间）：一般使用高速磁盘</li>
</ul>
<p><img src="/2021/11/10/day27/day27_79.png" alt="程序运行"></p>
</li>
</ul>
<p><img src="/2021/11/10/day27/day27_80.png" alt="Page Fault流程"></p>
<ul>
<li>Page Replacement（页面替换）：内存中不存在空闲的frame<ul>
<li>交换一个frame进入备份空间</li>
<li>从备份空间中交换一个page进入frame</li>
<li>不同的替换算法会选择不同的frames做替换</li>
</ul>
</li>
</ul>
<h3 id="创建进程"><a href="#创建进程" class="headerlink" title="创建进程"></a>创建进程</h3><ul>
<li><p>Copy-on-Write：初始情况下，子进程和父进程共享相同的frames，当page被写入时，才进行frame-copy</p>
<p><img src="/2021/11/10/day27/day27_81.png" alt="copy-on-write"></p>
</li>
<li><p>Memory-Mapped Files：</p>
<ul>
<li>MMF允许将文件的I/O当作正常的内存获取，通过将磁盘块映射到内存frame，不使用文件系统</li>
<li>文件最初使用Demand paging读取</li>
<li>优点：获得文件更快；容易共享</li>
<li>缺点：安全问题，数据丢失，编程困难</li>
</ul>
<p><img src="/2021/11/10/day27/day27_82.png" alt="MMF和文件系统对比"></p>
</li>
</ul>
<h3 id="Page-替换"><a href="#Page-替换" class="headerlink" title="Page 替换"></a>Page 替换</h3><ul>
<li>不存在空闲的frame时，需要进行Page Replacement:<ul>
<li>交换出一个进程，释放它所有的frames</li>
<li>找到不常使用的frames，释放它<ul>
<li>使用一个额外的位标志该frame是否被修改，只有修改的才需要重新被写入disk</li>
</ul>
</li>
</ul>
</li>
<li>frame-allocation 算法：决定一个进程分配多少frame</li>
<li>page-replacement 算法：选择哪一个frame被替换</li>
</ul>
<h4 id="Page-replacement算法"><a href="#Page-replacement算法" class="headerlink" title="Page-replacement算法"></a>Page-replacement算法</h4><ul>
<li><p>目标：减少page-fault的次数</p>
</li>
<li><p>page-fault：page-table中不存在请求的page</p>
</li>
<li><p><strong>FIFO算法</strong>：最老的page被替换，使用队列</p>
<ul>
<li>page table越大，不一定page-fault越低</li>
</ul>
<p><img src="/2021/11/10/day27/day27_83.png" alt="FIFO"></p>
</li>
<li><p><strong>Optimal 算法</strong>：替换最长时间不会被使用的page，需要未来的信息</p>
<p><img src="/2021/11/10/day27/day27_84.png" alt="Optimal"></p>
</li>
<li><p><strong>LRU算法</strong>：替换最近最久没有使用的page，效果很好</p>
<ul>
<li><p>计数器实现：时间戳会被保存在计数器中，但是需要搜索，时间复杂度为O(N)</p>
</li>
<li><p>栈实现：使用双向列表，最新使用的放在栈顶，每次替换栈底的page。会维护一个hashmap，记录每个page的位置</p>
<p><img src="/2021/11/10/day27/day27_85.png" alt="栈"></p>
</li>
</ul>
</li>
<li><p><strong>Counting 算法</strong>：实现成本高</p>
<ul>
<li>LFU算法：替换最少使用的page，经常使用的page计数值更大</li>
<li>MFU算法：替换最常使用的page，刚进来的page计数值比较小</li>
</ul>
</li>
</ul>
<h4 id="Frame-allocation算法"><a href="#Frame-allocation算法" class="headerlink" title="Frame-allocation算法"></a>Frame-allocation算法</h4><ul>
<li><p>每个进程都会有最小frame的限制</p>
</li>
<li><p><strong>Fixed allocation</strong>：</p>
<ul>
<li>均等分配：每个进程都具有相同数量的frame</li>
<li>比例分配：根据进程的大小分配frames</li>
</ul>
</li>
<li><p><strong>Priority allocation</strong>：</p>
<ul>
<li>更具进程的优先级分配frames</li>
</ul>
</li>
<li><p><strong>Local allocation：</strong>每个进程从它自己分配的frames中选择</p>
</li>
<li><p><strong>Glabal allocation：</strong>进程从所有的frames中选择</p>
</li>
</ul>
<h3 id="Thrashing"><a href="#Thrashing" class="headerlink" title="Thrashing"></a>Thrashing</h3><ul>
<li><p>Thrashing：一个进程的运行时间小于paging的时间</p>
<ul>
<li>解决Thrashing需要提供更多的frames给每一个进程</li>
</ul>
</li>
</ul>
<h4 id="Working-set-model"><a href="#Working-set-model" class="headerlink" title="Working-set model"></a>Working-set model</h4><ul>
<li><p>Locality：一组被频繁使用的pages</p>
</li>
<li><p>Locality model：进程在执行时，会从一个locality移动到另一个locality</p>
</li>
<li><p><strong>Working-set model</strong></p>
<ul>
<li><p>working-set window：一个变量Δ</p>
</li>
<li><p>working set：在Δ时间内使用的page的数量</p>
<p><img src="/2021/11/10/day27/day27_86.png" alt="working set"></p>
</li>
</ul>
</li>
</ul>
<p><img src="/2021/11/10/day27/day27_87.png" alt="Working-set model"></p>
<h4 id="Page-fault-Frequency"><a href="#Page-fault-Frequency" class="headerlink" title="Page fault Frequency"></a>Page fault Frequency</h4><ul>
<li>直接控制page-fault rate避免thrashing</li>
<li>指定一个进程page-fault rate 的上限和下限<ul>
<li>如果超过上限：分配额外的一个frame给进程</li>
<li>如果低于下限：移除进程的一个frame</li>
</ul>
</li>
</ul>
<h1 id="文件系统接口"><a href="#文件系统接口" class="headerlink" title="文件系统接口"></a>文件系统接口</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul>
<li><p>文件：OS创建的逻辑存储单元</p>
</li>
<li><p>文件属性：标识符、名字、类别、位置、大小、保护、最新修改时间等</p>
</li>
<li><p>文件操作：创建文件、写文件、读文件、在文件中定位、删除文件、截断文件</p>
<ul>
<li>Process中，会有open-file table</li>
<li>OS中，会有system-wide table</li>
</ul>
</li>
<li><p><strong>open-file table</strong>：一个进程拥有的</p>
<ul>
<li>跟踪所有本进程打开的文件</li>
<li>获得权限和计数权限</li>
</ul>
</li>
<li><p><strong>system-wide table</strong>：所有进程共享</p>
<ul>
<li>open-file table中的每个entry都会指向system-wide table</li>
<li>与进程无关的信息，例如disk位置，获得数据，文件大小</li>
</ul>
<p><img src="/2021/11/10/day27/day27_89.png" alt="table"></p>
</li>
</ul>
<h2 id="操作方法"><a href="#操作方法" class="headerlink" title="操作方法"></a>操作方法</h2><ul>
<li><p>连续获得：</p>
<ul>
<li>读/写下一块</li>
<li>重置：将文件指针指向文件开始位置</li>
<li>跳过/返回n个记录</li>
</ul>
<p><img src="/2021/11/10/day27/day27_88.png" alt="连续"></p>
</li>
<li><p>直接获得：</p>
<ul>
<li><p>在任意位置获得信息</p>
<p><img src="/2021/11/10/day27/day27_90.png" alt="直接获得"></p>
</li>
</ul>
</li>
<li><p>索引访问：包含了文件中一些块的指针</p>
<ul>
<li>首先查找块的指针，再使用指针直接访问信息</li>
<li>文件较大时，索引文件会比较大</li>
</ul>
<p><img src="/2021/11/10/day27/day27_91.png" alt="索引"></p>
</li>
</ul>
<h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><ul>
<li>Partition：原始的分盘，没有进行格式化，没有文件系统<ul>
<li>可以是一个disk的一部分，也可以是一组disk（分布式文件系统）</li>
</ul>
</li>
<li>volume：格式化之后的Partition，有了文件系统</li>
<li>目录：文件系统用来存储文件信息<ul>
<li>一组包含所有文件信息的结点</li>
<li>目录结构和文件都保存在disk上</li>
</ul>
</li>
</ul>
<p><img src="/2021/11/10/day27/day27_92.png" alt="文件系统结构"></p>
<ul>
<li><p>一级目录：所有文件都在一个目录中</p>
<ul>
<li>文件名需要唯一</li>
<li>文件多时，效率低</li>
</ul>
</li>
<li><p>两级目录：每个用户有自己的目录</p>
<ul>
<li>路径=用户名+文件名</li>
<li>对每个用户来说，还是存在一级目录的问题</li>
</ul>
</li>
<li><p>树状目录：</p>
<ul>
<li>绝对路径：从根开始</li>
<li>相对路径：从一个目录开始</li>
</ul>
<p><img src="/2021/11/10/day27/day27_93.png" alt="树状"></p>
</li>
<li><p>Acyclic-Graph Directory：对共享文件或目录使用链接</p>
<ul>
<li>一个文件可以有多个路径</li>
<li>当没有引用指向文件时，删除文件</li>
</ul>
</li>
<li><p>General-Graph Directory：可能会出现环</p>
<ul>
<li>使用环检测</li>
<li>使用垃圾回收，标记回收算法</li>
</ul>
</li>
</ul>
<h2 id="文件系统安装和文件共享"><a href="#文件系统安装和文件共享" class="headerlink" title="文件系统安装和文件共享"></a>文件系统安装和文件共享</h2><ul>
<li><p>安装点：文件系统被安装的根路径</p>
<p><img src="/2021/11/10/day27/day27_94.png" alt="mount"></p>
</li>
<li><p>多个用户的文件共享：</p>
<ul>
<li>每个用户都有userID和groupID</li>
<li>每个文件都有3组属性：owner，group，others<ul>
<li>owner属性描述owner对文件的权限，group和others也一样</li>
<li>group,others属性可以被owner或者root设置</li>
</ul>
</li>
</ul>
<p><img src="/2021/11/10/day27/day27_95.png" alt="文件"></p>
<p><img src="/2021/11/10/day27/day27_96.png" alt="文件权限"></p>
</li>
<li><p>文件保护：</p>
<ul>
<li>文件权限设置</li>
<li>文件不能遗失，可靠性强</li>
<li>使用密码登录</li>
</ul>
</li>
</ul>
<h1 id="文件系统实现"><a href="#文件系统实现" class="headerlink" title="文件系统实现"></a>文件系统实现</h1><ul>
<li>文件系统两个设计问题：用户程序接口；物理存储接口</li>
</ul>
<p><img src="/2021/11/10/day27/day27_97.png" alt="分层"></p>
<h2 id="Disk上的结构"><a href="#Disk上的结构" class="headerlink" title="Disk上的结构"></a>Disk上的结构</h2><ul>
<li>Boot control block(per partition)：从该分区启动系统所需的信息</li>
<li>Partition control block（per partition）：分区细节<ul>
<li>block大小、block 数量等</li>
</ul>
</li>
<li>File control block（per file）：文件的详细信息</li>
<li>Directory structure（per file system）：结构信息</li>
</ul>
<p><img src="/2021/11/10/day27/day27_98.png" alt="Disk上的结构"></p>
<h2 id="内存里的结构"><a href="#内存里的结构" class="headerlink" title="内存里的结构"></a>内存里的结构</h2><ul>
<li>内存中的partition table：每个挂载分区的信息</li>
<li>内存中的drectory structure：最近操作的目录的信息</li>
<li>system-wide open-file table：包含每个打开文件的FCB</li>
<li>per-process open-file table：指针指向system-wide open-file table中的每个一entry</li>
</ul>
<h2 id="文件操作流程"><a href="#文件操作流程" class="headerlink" title="文件操作流程"></a>文件操作流程</h2><ul>
<li><p>打开/阅读文件</p>
<p><img src="/2021/11/10/day27/day27_99.png" alt="打开/阅读文件"></p>
</li>
<li><p>创建文件：</p>
<ul>
<li>OS分配一个新的FCB</li>
<li>更新drectory structure：<ul>
<li>OS将相应的目录结构读进内存</li>
<li>根据新的文件名和FCB更新目录结构</li>
<li>（文件关闭后），OS将目录结构写入disk</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="虚拟文件系统"><a href="#虚拟文件系统" class="headerlink" title="虚拟文件系统"></a>虚拟文件系统</h2><ul>
<li>Virtual File System(VFS)：VFS会根据partition info选择合适的文件系统进行文件的操作</li>
<li>Linux VFS:<ul>
<li>inode：一个独立的文件，FCB</li>
<li>file object：打开的文件</li>
<li>superblock object：整个文件系统</li>
<li>dentry object：一个独立的目录entry</li>
</ul>
</li>
</ul>
<h2 id="目录实现"><a href="#目录实现" class="headerlink" title="目录实现"></a>目录实现</h2><ul>
<li>线性列表：<ul>
<li>列出带有指向数据块的文件名</li>
<li>容易编程，但是效率低</li>
</ul>
</li>
<li>哈希表：线性列表加上哈希<ul>
<li>效率高</li>
</ul>
</li>
</ul>
<h2 id="分配方法"><a href="#分配方法" class="headerlink" title="分配方法"></a>分配方法</h2><ul>
<li>disk blocks如何分配给文件：<ul>
<li>连续分配</li>
<li>链表分配</li>
<li>索引分配</li>
</ul>
</li>
</ul>
<h3 id="连续分配"><a href="#连续分配" class="headerlink" title="连续分配"></a>连续分配</h3><p><img src="/2021/11/10/day27/day27_100.png" alt="连续分配"></p>
<ul>
<li>每个文件占用一段连续的blocks<ul>
<li>寻找文件很快</li>
</ul>
</li>
<li>连续或者随机获得文件都很高效</li>
<li>问题：外部碎片；文件无法增长</li>
<li>Extent-Based File System：解决文件无法增长问题<ul>
<li>为每一个文件开辟一个或多个额外扩展空间，也是连续的空间</li>
<li>（starting block#,length,pointer to next extend）</li>
<li>缺点：随机获得开销更大；内部和外部碎片都可能存在</li>
</ul>
</li>
</ul>
<h3 id="链表分配"><a href="#链表分配" class="headerlink" title="链表分配"></a>链表分配</h3><ul>
<li>每个文件都是一组链表结构的blocks<ul>
<li>每个block都会包含指向下一个block的指针</li>
</ul>
</li>
</ul>
<p><img src="/2021/11/10/day27/day27_101.png" alt="链表"></p>
<ul>
<li>只适合于连续获取文件，不适合随机读取</li>
<li>每次获得列表链接都会进行disk  I/O(<strong>因为存在data block中</strong>)</li>
<li>会浪费空间；不稳定，一个链接断，文件损坏</li>
<li><strong>FAT32</strong>：将所有的链接都存在一个table(存在memory中)中，可以解决缺点</li>
</ul>
<h3 id="索引分配"><a href="#索引分配" class="headerlink" title="索引分配"></a>索引分配</h3><ul>
<li>将文件所有的blocks都存在index block中，直接进行访问，每个file都有</li>
</ul>
<p><img src="/2021/11/10/day27/day27_102.png" alt="索引分配"></p>
<ul>
<li><p>优点：</p>
<ul>
<li>连续或者随机读取都很快</li>
<li>没有外部碎片</li>
<li>容易创建文件（没有分配问题）</li>
</ul>
</li>
<li><p>缺点：</p>
<ul>
<li><p>index blocks需要空间</p>
</li>
<li><p>index block的大小无法确定</p>
<ul>
<li><p>链接索引方案：index blocks链接起来</p>
<p><img src="/2021/11/10/day27/day27_103.png" alt="Linked Indexed"></p>
<ul>
<li><p>多层方案：使用一个block当作其他blocks的索引，适用文件很大的情况</p>
<p><img src="/2021/11/10/day27/day27_104.png" alt="多层"></p>
</li>
<li><p>合并方案：UNIX inode。多种方案一起使用</p>
<p><img src="/2021/11/10/day27/day27_105.png" alt="合并方案"></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="空闲空间管理"><a href="#空闲空间管理" class="headerlink" title="空闲空间管理"></a>空闲空间管理</h2><ul>
<li><p>Free-space list：记录所有空闲的disk blocks</p>
</li>
<li><p>文件系统管理空闲空间的方法和管理文件的方法一样</p>
</li>
<li><p>Linked list：和链式分配一样</p>
</li>
<li><p>Grouping：和链式索引分配相同</p>
</li>
<li><p>Counting：和连续分配相同</p>
</li>
<li><p>Bit vector：一位代表一个block</p>
<ul>
<li>简单，高效</li>
<li>需要读入缓存效果才好</li>
</ul>
<p><img src="/2021/11/10/day27/day27_106.png" alt="bit vector"></p>
</li>
</ul>
<h1 id="大型存储系统"><a href="#大型存储系统" class="headerlink" title="大型存储系统"></a>大型存储系统</h1><h2 id="磁盘结构"><a href="#磁盘结构" class="headerlink" title="磁盘结构"></a>磁盘结构</h2><ul>
<li><p>磁盘驱动使用一维数组的逻辑block进行编址：</p>
<ul>
<li>逻辑block：sector最小的单元</li>
</ul>
</li>
<li><p>逻辑block连续映射到disk上</p>
<ul>
<li>Sector 0：最外层的第一个track的第一个sector</li>
<li>从外向内</li>
</ul>
<p><img src="/2021/11/10/day27/day27_107.png" alt="disk structure"></p>
</li>
<li><p>Constant linear velocity（CLV）：</p>
<ul>
<li>每一个track上的数据密度相等</li>
<li>外圈会有更多的sectors</li>
<li>保持相同的数据速率<ul>
<li>内圈会增加转速</li>
</ul>
</li>
<li>应用：CD-ROM;DVD-ROM</li>
</ul>
</li>
<li><p>Constant angular velocity（CAV）：</p>
<ul>
<li>保持相同的转数</li>
<li>内圈的track数据密度更大</li>
<li>保持相同的数据速率</li>
<li>应用：硬件磁盘</li>
</ul>
</li>
<li><p>磁盘I/O：磁盘驱动通过I/O总线安装到电脑上</p>
<ul>
<li>EIDE ATA SATA USB等</li>
<li>被控制器控制</li>
</ul>
</li>
</ul>
<h2 id="磁盘调度"><a href="#磁盘调度" class="headerlink" title="磁盘调度"></a>磁盘调度</h2><ul>
<li><p>磁盘获取时间：</p>
<ul>
<li>查询时间：移动磁盘臂到需要的cylinder</li>
<li>旋转延迟：旋转磁盘头到需要的sector</li>
<li>读取时间：内容传输时间</li>
</ul>
<p><img src="/2021/11/10/day27/day27_108.png" alt="磁盘调度"></p>
</li>
<li><p>优化查询时间：查询时间可大致等价于查询距离</p>
</li>
</ul>
<h3 id="FCFS"><a href="#FCFS" class="headerlink" title="FCFS"></a>FCFS</h3><ul>
<li><p>First-come，first-served：先处理先到达的</p>
<p><img src="/2021/11/10/day27/day27_109.png" alt="FCFS"></p>
</li>
</ul>
<h3 id="SSTF"><a href="#SSTF" class="headerlink" title="SSTF"></a>SSTF</h3><ul>
<li><p>shortest-seek-time-first：先查询离目前位置最近的</p>
<ul>
<li>可能会导致某些请求的starvation</li>
</ul>
<p><img src="/2021/11/10/day27/day27_110.png" alt="SSTF"></p>
</li>
</ul>
<h3 id="SCAN"><a href="#SCAN" class="headerlink" title="SCAN"></a>SCAN</h3><ul>
<li><p>SCAN：按照一个方向走，直到到头，再转换方向</p>
<p><img src="/2021/11/10/day27/day27_111.png" alt="SCAN"></p>
</li>
</ul>
<h3 id="C-SCAN"><a href="#C-SCAN" class="headerlink" title="C-SCAN"></a>C-SCAN</h3><ul>
<li><p>C-SAN：只按照一个方向走，到头之后，从头再来</p>
<ul>
<li>等待时间更加平均</li>
</ul>
<p><img src="/2021/11/10/day27/day27_112.png" alt="C-SCAN"></p>
</li>
<li><p>SCAN,C-SCAN会移动到总的最边缘位置</p>
</li>
</ul>
<h3 id="LOOK-and-C-LOOK"><a href="#LOOK-and-C-LOOK" class="headerlink" title="LOOK and C-LOOK"></a>LOOK and C-LOOK</h3><ul>
<li><p>LOOK和C-LOOK：总体逻辑和SSTF逻辑相同，但是会固定方向。LOOK会走到头，再换方向，C-LOOK只按照一个方向走</p>
</li>
<li><p>LOOK和C-LOOK都只会走到当前请求的边缘位置，不会移动到总的边缘位置</p>
<p><img src="/2021/11/10/day27/day27_113.png" alt="C-LOOK"></p>
</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>SSTF：常见并且有天然的效果，但是不高效</li>
<li>SCAN：大负载的情况下效果好，不会存在starvation问题</li>
<li>C-SCAN：等待时间更均等</li>
<li>文件分配策略也会影响：<ul>
<li>连续分配：头移动更少</li>
<li>索引，链接：头移动更多</li>
</ul>
</li>
</ul>
<h2 id="磁盘管理"><a href="#磁盘管理" class="headerlink" title="磁盘管理"></a>磁盘管理</h2><ul>
<li><p>磁盘格式化：</p>
<ul>
<li>低级格式化：将磁盘分区<ul>
<li>每个分区=header+data area+trailer<ul>
<li>header和trailer：sector #+ECC（error-correcting code）</li>
<li>ECC根据数据区的计算的</li>
<li>data area大小：512B，1KB,4KB</li>
</ul>
</li>
</ul>
</li>
<li>OS使用disk需要两步：<ul>
<li>将磁盘分为一组或多组cylinders</li>
<li>逻辑格式化（创建文件系统）</li>
</ul>
</li>
</ul>
</li>
<li><p>Boot block：</p>
<ul>
<li>引导程序：<ul>
<li>初始化CPU，寄存器，设备控制器，内存，启动OS</li>
<li>一部分引导程序存在ROM中</li>
<li>另一部分引导程序放在启动磁盘的启动块中</li>
</ul>
</li>
</ul>
<p><img src="/2021/11/10/day27/day27_114.png" alt="从磁盘启动"></p>
</li>
<li><p>Bad blocks：</p>
<ul>
<li>简单的磁盘：IDE磁盘<ul>
<li>手动使用格式程序标记bad blocks中相应的FAT 条目</li>
<li>bad blocks不会被分配</li>
</ul>
</li>
<li>复杂的磁盘：<ul>
<li>磁盘控制器维护bad blocks列表<ul>
<li>Sector sparing：将bad block重新映射到一个空闲的区域<ul>
<li>会影响磁盘调度的效果</li>
<li>在格式化时空闲的空间更少</li>
</ul>
</li>
<li>Sector slipping：将所有的sectors向下搬移一位</li>
</ul>
</li>
<li>列表会在磁盘周期更新</li>
</ul>
</li>
</ul>
</li>
<li><p>Swap-Space管理：虚拟内存使用swap-space当作主内存的扩展</p>
<ul>
<li><p>UNIX：允许多个swap spaces</p>
</li>
<li><p>位置：</p>
<ul>
<li>文件系统的一部分：效率低</li>
<li>单独的磁盘分区：大小固定（不安装文件系统）</li>
<li>两种都采用（Linux）</li>
</ul>
<p><img src="/2021/11/10/day27/day27_116.png" alt="单独分区"></p>
</li>
<li><p>分配：</p>
<ul>
<li><p>在连续的磁盘空间和内存中都复制整个进程</p>
</li>
<li><p>复制pages进入swap space</p>
<p><img src="/2021/11/10/day27/day27_115.png" alt="实例"></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="RAID"><a href="#RAID" class="headerlink" title="RAID"></a>RAID</h2><ul>
<li>Redundant Arrays of Inexpensive Disks(RAID)：使用多个磁盘，构建更大的存储<ul>
<li>通过redundancy提供稳定性</li>
<li>通过并行提高性能</li>
</ul>
</li>
<li>RAID被分成不同的层次：<ul>
<li>striping：将磁盘分区，实现并行</li>
<li>mirror：将内存备份，提高稳定性</li>
<li>Error-correcting code和Parity bit：错误码和校验位</li>
</ul>
</li>
</ul>
<h3 id="RAID0和RAID1"><a href="#RAID0和RAID1" class="headerlink" title="RAID0和RAID1"></a>RAID0和RAID1</h3><ul>
<li><p>RAID0：non-redundant striping</p>
<ul>
<li>通过并行提高性能</li>
<li>其他性能不卡的请况下，读写速度都会提升</li>
</ul>
<p><img src="/2021/11/10/day27/day27_117.png" alt="RAID0"></p>
</li>
<li><p>RAID1：备份磁盘</p>
<ul>
<li>通过冗余提供稳定性</li>
<li>读取速度会增加</li>
<li>写的速度不变</li>
</ul>
</li>
</ul>
<p><img src="/2021/11/10/day27/day27_118.png" alt="RAID1"></p>
<h3 id="RAID2"><a href="#RAID2" class="headerlink" title="RAID2"></a>RAID2</h3><ul>
<li><p>Hamming code：</p>
<ul>
<li>4个数据位（在4个磁盘上）+3个纠错码（在3个磁盘上）</li>
<li>每个纠错码和3个数据码相关</li>
</ul>
<p><img src="/2021/11/10/day27/day27_119.png" alt="Hamming code"></p>
</li>
<li><p>任何一个磁盘出现错误都可以恢复</p>
<ul>
<li>最多可以纠正两个磁盘的错误</li>
<li>只能纠正一位的错误</li>
</ul>
</li>
<li><p>比RAID1空间利用率更高</p>
<p><img src="/2021/11/10/day27/day27_120.png" alt="RAID2"></p>
</li>
</ul>
<h3 id="RAID3和RAID4"><a href="#RAID3和RAID4" class="headerlink" title="RAID3和RAID4"></a>RAID3和RAID4</h3><ul>
<li>磁盘控制器可以检测一个sector是不是正确的，只有一位出错时，只需要一个纠正位就可以恢复</li>
</ul>
<p><img src="/2021/11/10/day27/day27_121.png" alt="RAID3和RAID4"></p>
<ul>
<li>RAID3：bit-level分区</li>
<li>RAID4：Block-level 分区</li>
<li>空间利用率更高；需要计算和保存纠正位</li>
<li>RAID4有更高的I/O吞吐量</li>
</ul>
<h3 id="RAID5"><a href="#RAID5" class="headerlink" title="RAID5"></a>RAID5</h3><ul>
<li><p>分布式纠正位</p>
</li>
<li><p>将数据和纠正位都分布在所有磁盘上</p>
<p><img src="/2021/11/10/day27/day27_122.png" alt="RAID5"></p>
</li>
<li><p>不会过度使用某个磁盘</p>
</li>
</ul>
<h3 id="RAID6"><a href="#RAID6" class="headerlink" title="RAID6"></a>RAID6</h3><ul>
<li><p>使用更多的纠正位，来处理多个磁盘出错的情况</p>
</li>
<li><p>纠正位任然分布在所有磁盘上</p>
<p><img src="/2021/11/10/day27/day27_123.png" alt="RAID6"></p>
</li>
</ul>
<h3 id="Hybrid"><a href="#Hybrid" class="headerlink" title="Hybrid"></a>Hybrid</h3><ul>
<li>RAID 0+1：Strip and replicate</li>
<li>RAID 1+0：replicate and strip</li>
</ul>
<p><img src="/2021/11/10/day27/day27_124.png" alt="Hybrid"></p>
<h1 id="I-O系统"><a href="#I-O系统" class="headerlink" title="I/O系统"></a>I/O系统</h1><ul>
<li>两个冲突：统一标准的接口；多种多样的设备</li>
</ul>
<h2 id="I-O硬件"><a href="#I-O硬件" class="headerlink" title="I/O硬件"></a>I/O硬件</h2><ul>
<li><p>Port：主机和I/O设备的连接点</p>
</li>
<li><p>Bus：一组线和定义好的规范，可以明确消息在线上的传递</p>
</li>
<li><p>Controller：可以操控port,bus或者一个设备的电子设备的集合</p>
<ul>
<li>一个控制器可以有他自己的处理器和内存</li>
</ul>
</li>
<li><p>每一个port都会使用端口地址来标识</p>
</li>
<li><p>每个I/O端口有四个寄存器：</p>
<ul>
<li>数据输入寄存器</li>
<li>数据输出寄存器</li>
<li>状态寄存器</li>
<li>控制寄存器</li>
</ul>
</li>
</ul>
<h2 id="不同的I-O"><a href="#不同的I-O" class="headerlink" title="不同的I/O"></a>不同的I/O</h2><ul>
<li>port-mapped I/O：<ul>
<li>和内存使用不同的地址空间</li>
<li>通过特殊的I/O指令获取</li>
</ul>
</li>
<li>Memory-mapped I/O:<ul>
<li>给设备预留一些内存空间</li>
<li>通过标准的数据传输指令获取</li>
<li>使用大内存I/O</li>
<li>容易被意外修改</li>
</ul>
</li>
</ul>
<h3 id="I-O-subsystem"><a href="#I-O-subsystem" class="headerlink" title="I/O subsystem"></a>I/O subsystem</h3><ul>
<li>Blocking I/O：执行I/O时，进程挂起<ul>
<li>使用简单</li>
<li>效率低</li>
<li>使用在需要同步的I/O</li>
</ul>
</li>
<li>Nonblocking I/O：通过多线程方式实现<ul>
<li>相应很快</li>
<li>使用在异步的I/O</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/10/29/day26/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Kaixuan Wang">
      <meta itemprop="description" content="只争朝夕">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Magic">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/10/29/day26/" class="post-title-link" itemprop="url">并发编程进阶</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-10-29 09:56:44 / 修改时间：10:08:24" itemprop="dateCreated datePublished" datetime="2021-10-29T09:56:44+08:00">2021-10-29</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="volatile和synchronized"><a href="#volatile和synchronized" class="headerlink" title="volatile和synchronized"></a>volatile和synchronized</h1><ul>
<li><strong>volatile</strong>:将数据写入系统内存。采用缓存一致性协议，其他cpu在使用缓存数据时会进行嗅探，如果发现自己的缓存行地址对应的内存地址发生变换，则缓存无效</li>
<li><strong>synchronized</strong>:使用monitorenter,monitorexit。锁信息保存在java对象头中</li>
</ul>
<h1 id="锁的升级"><a href="#锁的升级" class="headerlink" title="锁的升级"></a>锁的升级</h1><ul>
<li><strong>偏向锁</strong>：有竞争才释放锁。某个线程持有当前锁后，当前java对象头会存储锁偏向的线程ID。没有竞争的情况下，相同线程下次再获得相同的锁，不需要使用CAS进行竞争，也不用释放。</li>
<li><strong>偏向锁释放</strong>：如果有其他线程竞争锁，偏向锁的释放需要等到全局安全点（没有正在执行的字节码）。首先暂停持有锁的线程，其次检测该线程是否活着，如果死亡，则将对象头设置为无锁状态；如果活着，遍历偏向对象的锁记录，修改对象头和栈中的锁记录，要么偏向于另一个线程，要么恢复无锁，要么标记对象不适合作为偏向锁</li>
<li><strong>轻量级锁</strong>：将对象头中的Mark Word赋值记录到栈帧的锁记录中，使用CAS修改对象头，获得锁</li>
<li><strong>轻量级锁升级</strong>：如果有其他线程竞争锁，当前线程没有释放锁的情况下，其他线程会通过自旋来获得锁。当前线程释放锁时，会再次使用CAS将保存的对象头信息重新写入对象头。如果失败，表示有竞争，则轻量级锁会升级为重量级锁</li>
</ul>
<blockquote>
<p>锁只能升级，不能降级</p>
<p>偏向锁——&gt;轻量级锁——&gt;重量级锁</p>
</blockquote>
<h1 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h1><ul>
<li><p><strong>指令重排</strong>：为了防止出现错误，JMM设置内存壁障（loadload storestore loadstore storeload）</p>
</li>
<li><p><strong>happens-before</strong>:并不意味着前一个操作一定要在后一个操作之前，而且要求前一个操作对后一个操作可见</p>
</li>
<li><p><strong>顺序一致性模型</strong>：每个操作必须立即对任意线程可见。</p>
</li>
</ul>
<blockquote>
<p>JMM与顺序一致性模型差异：</p>
<ol>
<li>JMM不保证每个操作对所有线程可见</li>
<li>JMM不保证对64位变量的写操作和读操作具有原子性</li>
<li>JMM不保证单线程内的执行顺序和原程序一致</li>
</ol>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/10/18/day25/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Kaixuan Wang">
      <meta itemprop="description" content="只争朝夕">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Magic">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/10/18/day25/" class="post-title-link" itemprop="url">MyBatis</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-10-18 14:55:50" itemprop="dateCreated datePublished" datetime="2021-10-18T14:55:50+08:00">2021-10-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-10-24 12:09:46" itemprop="dateModified" datetime="2021-10-24T12:09:46+08:00">2021-10-24</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><ul>
<li>MyBatis 是支持定制化 SQL、存储过程以及高级映射的优秀的持久层框架</li>
<li>MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集</li>
<li>MyBatis是一个半自动化的持久化层框架</li>
</ul>
<h1 id="HelloWorld工程"><a href="#HelloWorld工程" class="headerlink" title="HelloWorld工程"></a>HelloWorld工程</h1><h2 id="导入jar包"><a href="#导入jar包" class="headerlink" title="导入jar包"></a>导入jar包</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.kaixuan<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>Mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.23<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.17<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="创建数据库表和对应javaBean"><a href="#创建数据库表和对应javaBean" class="headerlink" title="创建数据库表和对应javaBean"></a>创建数据库表和对应javaBean</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kaixuan.bean;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String lastName;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">    <span class="keyword">private</span> String gender;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;com.kaixuan.bean.Employee&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;id=&quot;</span> + id +</span><br><span class="line">                <span class="string">&quot;, lastName=&#x27;&quot;</span> + lastName + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, email=&#x27;&quot;</span> + email + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, gender=&#x27;&quot;</span> + gender + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getLastName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> lastName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLastName</span><span class="params">(String lastName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.lastName = lastName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getEmail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> email;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEmail</span><span class="params">(String email)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.email = email;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getGender</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> gender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setGender</span><span class="params">(String gender)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.gender = gender;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="创建配置文件"><a href="#创建配置文件" class="headerlink" title="创建配置文件"></a>创建配置文件</h2><ul>
<li>log4j配置文件</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">log4j</span>:configuration <span class="meta-keyword">SYSTEM</span> <span class="meta-string">&quot;log4j.dtd&quot;</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">log4j:configuration</span> <span class="attr">xmlns:log4j</span>=<span class="string">&quot;http://jakarta.apache.org/log4j/&quot;</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"> <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;STDOUT&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.apache.log4j.ConsoleAppender&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;Encoding&quot;</span> <span class="attr">value</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">layout</span> <span class="attr">class</span>=<span class="string">&quot;org.apache.log4j.PatternLayout&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;ConversionPattern&quot;</span> <span class="attr">value</span>=<span class="string">&quot;%-5p %d&#123;MM-dd HH:mm:ss,SSS&#125; %m  (%F:%L) \n&quot;</span> /&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">&quot;java.sql&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">level</span> <span class="attr">value</span>=<span class="string">&quot;debug&quot;</span> /&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">logger</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">&quot;org.apache.ibatis&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">level</span> <span class="attr">value</span>=<span class="string">&quot;info&quot;</span> /&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">logger</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">root</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">level</span> <span class="attr">value</span>=<span class="string">&quot;debug&quot;</span> /&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;STDOUT&quot;</span> /&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">log4j:configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>mybatis配置文件</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">configuration</span></span></span><br><span class="line"><span class="meta"> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta"> <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span> /&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span> /&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/mybatis&quot;</span> /&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span> /&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;123456&quot;</span> /&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">&lt;!-- 将我们写好的sql映射文件（EmployeeMapper.xml）一定要注册到全局配置文件（mybatis-config.xml）中 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;EmployeeMapper.xml&quot;</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>sql映射配置文件</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.kaixuan.EmployeeMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        namespace:名称空间;指定为接口的全类名</span></span><br><span class="line"><span class="comment">        id：唯一标识</span></span><br><span class="line"><span class="comment">        resultType：返回值类型</span></span><br><span class="line"><span class="comment">        #&#123;id&#125;：从传递过来的参数中取出id值</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        public Employee getEmpById(Integer id);</span></span><br><span class="line"><span class="comment">     --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmpById&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.kaixuan.bean.Employee&quot;</span>&gt;</span></span><br><span class="line">        /*起别名，防止名称不一致*/</span><br><span class="line">        select id,last_name lastName,email,gender from tbl_employee where id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="测试运行"><a href="#测试运行" class="headerlink" title="测试运行"></a>测试运行</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1.根据xml配置文件创建一个  SqlSessionFactory对象</span></span><br><span class="line"><span class="comment"> * 2.使用SqlSessionFactory获取sqlSession对象。一个SqlSession对象代表和数据库的一次会话。用完关闭</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    String resource = <span class="string">&quot;mybatis-config.xml&quot;</span>;</span><br><span class="line">    InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">    SqlSessionFactory sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(inputStream);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获得sqlSession实例，可以直接执行映射的sql语句</span></span><br><span class="line">    SqlSession sqlSession = sqlSessionFactory.openSession();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Employee employee = sqlSession.selectOne(<span class="string">&quot;com.kaixuan.EmployeeMapper.getEmpById&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        System.out.println(employee);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        sqlSession.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="接口式编程（推荐使用）"><a href="#接口式编程（推荐使用）" class="headerlink" title="接口式编程（推荐使用）"></a>接口式编程（推荐使用）</h2><ul>
<li>创建一个接口，与sql映射配置文件进行绑定</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    String resource = <span class="string">&quot;mybatis-config.xml&quot;</span>;</span><br><span class="line">    InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">    SqlSessionFactory sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(inputStream);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获得sqlSession实例，可以直接执行映射的sql语句</span></span><br><span class="line">    SqlSession sqlSession = sqlSessionFactory.openSession();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//获得接口的实现类对象</span></span><br><span class="line">        <span class="comment">//会为接口创建一个代理对象，代理对象去执行增删改查方法</span></span><br><span class="line">        EmployeeMapper mapper = sqlSession.getMapper(EmployeeMapper.class);</span><br><span class="line">        Employee empById = mapper.getEmpById(<span class="number">1</span>);</span><br><span class="line">        System.out.println(empById);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        sqlSession.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="全局配置文件"><a href="#全局配置文件" class="headerlink" title="全局配置文件"></a>全局配置文件</h1><h2 id="properties"><a href="#properties" class="headerlink" title="properties"></a>properties</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--mybatis可以使用properties标签引入外部properties配置文件的内容</span></span><br><span class="line"><span class="comment">	resource:引入类路径下的资源</span></span><br><span class="line"><span class="comment">	url：引入网络路径或者磁盘路径下的资源</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">&quot;jdbc.properties&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="settings"><a href="#settings" class="headerlink" title="settings"></a>settings</h2><p><img src="/2021/10/18/day25/day25_1.png" alt="属性"></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">	settings包含许多mybatis的重要设置项</span></span><br><span class="line"><span class="comment">		name:设置项名</span></span><br><span class="line"><span class="comment">		value：设置项值</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;mapUnderscoreToCamelCase&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="typeAliases-别名处理器"><a href="#typeAliases-别名处理器" class="headerlink" title="typeAliases(别名处理器)"></a>typeAliases(别名处理器)</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">	typeAliases可以为java类型起别名，别名不区分大小写</span></span><br><span class="line"><span class="comment">		type:需要起别名的类型</span></span><br><span class="line"><span class="comment">		alias：别名,默认为类名小写</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">type</span>=<span class="string">&quot;com.kaixuan.bean.Employee&quot;</span> <span class="attr">alias</span>=<span class="string">&quot;emp&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">&lt;!--批量起别名</span></span><br><span class="line"><span class="comment">		package：为某个包下所有类批量起别名</span></span><br><span class="line"><span class="comment">			name：指定包名（默认为类名小写）</span></span><br><span class="line"><span class="comment">	--&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;com.kaixuan.bean&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">&lt;!--使用@Alias注解为类直接起别名--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>mybatis内部已经为一些内部类起了别名，自定义的别名不能和这些别名冲突</li>
</ul>
<h2 id="typeHandlers-类型处理器"><a href="#typeHandlers-类型处理器" class="headerlink" title="typeHandlers(类型处理器)"></a>typeHandlers(类型处理器)</h2><ul>
<li>数据库类型和java类型进行映射</li>
</ul>
<p><img src="/2021/10/18/day25/day25_2.png" alt="类型处理器"></p>
<h2 id="plugins"><a href="#plugins" class="headerlink" title="plugins"></a>plugins</h2><ul>
<li>插件是MyBatis提供的一个非常强大的机制，我们可以通过插件来修改MyBatis的一些核心行为。插件通过动态代理机制，可以介入四大对象的任何一个方法的执行。</li>
</ul>
<h2 id="environments"><a href="#environments" class="headerlink" title="environments"></a>environments</h2><ul>
<li>transactionManager：事务管理器<ul>
<li>JDBC:使用回滚的方式控制事务</li>
<li>MANAGED：使用jee服务器进行事务管理</li>
<li>自定义事务管理器，实现TransactionFactory接口，type指定全类名</li>
</ul>
</li>
<li>dataSource:数据源<ul>
<li>UNPOOLED:不适用连接池</li>
<li>POOLED:使用连接池</li>
<li>JNDL：在EJB 或应用服务器这类容器中查找指定的数据源</li>
<li>自定义：实现DataSourceFactory接口，定义数据源的获取方式</li>
</ul>
</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">	environments，mybatis可以配置多个环境，可以通过default指定使用哪一个环境</span></span><br><span class="line"><span class="comment">		environmen:配置一个特定的环境,id代表当前环境的唯一标识</span></span><br><span class="line"><span class="comment">			transactionManager:事务管理器</span></span><br><span class="line"><span class="comment">			dateSource：数据源</span></span><br><span class="line"><span class="comment">				type:数据源类型</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.driver&#125;&quot;</span> /&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span> /&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.username&#125;&quot;</span> /&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>数据源和事务管理一般都使用spring</p>
</blockquote>
<h2 id="databasedIdProvider"><a href="#databasedIdProvider" class="headerlink" title="databasedIdProvider"></a>databasedIdProvider</h2><ul>
<li>MyBatis 可以根据不同的数据库厂商执行不同的语句</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">	databaseIdProvider:支持多数据库</span></span><br><span class="line"><span class="comment">		type=&quot;DB_VENDOR&quot;:得到数据库厂商的标识（驱动getDatabaseProductName()）</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">databaseIdProvider</span> <span class="attr">type</span>=<span class="string">&quot;DB_VENDOR&quot;</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!--为不同厂商起别名--&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;MySQL&quot;</span> <span class="attr">value</span>=<span class="string">&quot;mysql&quot;</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;Oracle&quot;</span> <span class="attr">value</span>=<span class="string">&quot;oracle&quot;</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;Sql Server&quot;</span> <span class="attr">value</span>=<span class="string">&quot;sqlserver&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">databaseIdProvider</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>在使用sql语句进行操作时，可以通过databaseId指定数据库</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmpById&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.kaixuan.bean.Employee&quot;</span> <span class="attr">databaseId</span>=<span class="string">&quot;mysql&quot;</span>&gt;</span></span><br><span class="line">    /*起别名，防止名称不一致*/</span><br><span class="line">    select id,last_name lastName,email,gender from tbl_employee where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li>如果没有配置databaseIdProvider标签，那么databaseId=null</li>
<li>如果配置了databaseIdProvider标签，使用标签配置的name去匹配数据库信息，匹配上设置databaseId=配置指定的值，否则依旧为null</li>
<li>如果databaseId不为null，他只会找到配置databaseId的sql语句</li>
<li>MyBatis 会加载不带 databaseId 属性和带有匹配当前数据库databaseId 属性的所有语句。如果同时找到带有 databaseId 和不带databaseId 的相同语句，则后者会被舍弃</li>
</ul>
<h2 id="mappers"><a href="#mappers" class="headerlink" title="mappers"></a>mappers</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">	mappers：将sql映射注册到全局配置中</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">		mapper：注册一个sql映射文件</span></span><br><span class="line"><span class="comment">			resource:引用类路径下的sql映射文件</span></span><br><span class="line"><span class="comment">			url:引用网络路径或者磁盘路径下的sql映射文件</span></span><br><span class="line"><span class="comment">			class：引用接口</span></span><br><span class="line"><span class="comment">	--&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;EmployeeMapper.xml&quot;</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">mapper</span> <span class="attr">class</span>=<span class="string">&quot;com.kaixuan.dao.EmployeeMapper&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>如果引用接口进行注册：<ul>
<li>有sql映射文件，映射文件名必须和接口名相同，并且在相同目录下</li>
<li>没有sql映射文件，所有sql利用注解写在接口方法名上</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Select(&quot;select id,last_name,email,gender from tbl_employee where id = #&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Employee <span class="title">getEmpById</span><span class="params">(Integer id)</span></span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>重要的Dao接口使用sql映射文件，不重要的Dao接口使用注解</p>
</blockquote>
<ul>
<li>批量注册:映射文件名必须和接口名相同，并且在相同目录下</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--批量注册--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;com.kaixuan.dao&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>



<blockquote>
<p>配置文件中，所有标签的配置顺序不能乱:</p>
<p>properties, settings, typeAliases, typeHandlers, objectFactory, objectWrapperFactory, reflectorFactory, plugins, environments, databaseIdProvider, mappers</p>
</blockquote>
<h1 id="映射文件"><a href="#映射文件" class="headerlink" title="映射文件"></a>映射文件</h1><ul>
<li>mybatis允许增删改直接定义以下类型返回值<ul>
<li>Integer、Long、boolean、void</li>
</ul>
</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmpById&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.kaixuan.bean.Employee&quot;</span>&gt;</span></span><br><span class="line">    select id,last_name,email,gender from tbl_employee where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    public void addEmp(Employee employee);</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;addEmp&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;com.kaixuan.bean.Employee&quot;</span>&gt;</span></span><br><span class="line">    insert into tbl_employee(last_name,email,gender)</span><br><span class="line">    values(#&#123;lastName&#125;,#&#123;email&#125;,#&#123;gender&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    public void updateEmp(Employee employee);</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateEmp&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;com.kaixuan.bean.Employee&quot;</span>&gt;</span></span><br><span class="line">    update tbl_employee set last_name=#&#123;lastName&#125;,email=#&#123;email&#125;,gender=#&#123;gender&#125; where id=#&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    public void deleteEmpById(Integer id);</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;deleteEmpById&quot;</span>&gt;</span></span><br><span class="line">    delete from tbl_employee where id=#&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>若数据库<strong>支持自动生成主键</strong>的字段（比如 MySQL 和 SQL Server），则可以设置<strong>useGeneratedKeys=”true”</strong>，然后再把<strong>keyProperty</strong> 设置到目标属性上</li>
<li>而对于不支持自增型主键的数据库（例如Oracle），则可以使用 <strong>selectKey</strong> 子元素：<strong>selectKey 元素将会首先运行</strong>，<strong>id 会被设置</strong>，然后插入语句会被调用</li>
</ul>
<h2 id="参数处理"><a href="#参数处理" class="headerlink" title="参数处理"></a>参数处理</h2><ul>
<li><p>单个参数：可以接受基本类型，对象类型，集合类型的值。这种情况MyBatis可直接使用这个参数，不需要经过任何处理 </p>
</li>
<li><p>多个参数：任意多个参数，都会被MyBatis重新包装成一个Map传入</p>
<ul>
<li>Map的key是param1，param2，0，1…，值就是参数的值 </li>
<li>命名参数：为参数使用@Param起一个名字，MyBatis就会将这些参数封装进map中，key就是我们自己指定的名字</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateEmp</span><span class="params">(<span class="meta">@Param(&quot;employee&quot;)</span>Employee employee)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li><p>POJO：当这些参数属于我们业务POJO时，我们直接传递POJO</p>
</li>
<li><p>Map：我们也可以封装多个参数为map，直接传递</p>
</li>
<li><p>如果参数为Collection(List、Set等)，也是将参数封装进入map，此时的key为<strong>collection</strong>，List也可以为<strong>list</strong></p>
</li>
</ul>
<blockquote>
<p>**#{key}**：获取参数的值，预编译到SQL中</p>
<p>**${key}**：获取参数的值，拼接到SQL中。有SQL注入问题</p>
<p>注：原生jdbc不支持占位符的地方使用${}进行取值，比如：分表、排序等</p>
</blockquote>
<ul>
<li>#{}取值更丰富的规则：<ul>
<li><strong>参数位置支持的属性</strong>：javaType、jdbcType、mode（存储过程）、numericScale、resultMap、typeHandler、jdbcTypeName</li>
<li>jdbcType在某些特定情况下需要被设置：如参数为空时，Oracle会报错</li>
</ul>
</li>
</ul>
<h2 id="select"><a href="#select" class="headerlink" title="select"></a>select</h2><ul>
<li>返回值为集合时：resultType设置为集合内元素的类型</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--public List&lt;Employee&gt; getEmpsByLastNameLike(String lastName);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmpsByLastNameLike&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.kaixuan.bean.Employee&quot;</span>&gt;</span></span><br><span class="line">    select * from tbl_employee where last_name like #&#123;lastName&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>返回值为Map时：<ul>
<li>返回单条记录时，resultType设置为map</li>
<li>返回多条记录时，resultType设置为value的类型，同时在方法上添加注解@MapKey()，设置返回map的key</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//多条记录封装一个map：Map&lt;Integer,Employee&gt;:键是这条记录的主键，值是记录封装后的javaBean</span></span><br><span class="line">	<span class="comment">//@MapKey:告诉mybatis封装这个map的时候使用哪个属性作为map的key</span></span><br><span class="line">	<span class="meta">@MapKey(&quot;lastName&quot;)</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Map&lt;String, Employee&gt; <span class="title">getEmpByLastNameLikeReturnMap</span><span class="params">(String lastName)</span></span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--public Map&lt;Integer, Employee&gt; getEmpByLastNameLikeReturnMap(String lastName);  --&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmpByLastNameLikeReturnMap&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.atguigu.mybatis.bean.Employee&quot;</span>&gt;</span></span><br><span class="line"> 		select * from tbl_employee where last_name like #&#123;lastName&#125;</span><br><span class="line"> 	<span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"> 	<span class="comment">&lt;!--public Map&lt;String, Object&gt; getEmpByIdReturnMap(Integer id);  --&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmpByIdReturnMap&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;map&quot;</span>&gt;</span></span><br><span class="line"> 		select * from tbl_employee where id=#&#123;id&#125;</span><br><span class="line"> 	<span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="/2021/10/18/day25/day25_3.png" alt="select属性"></p>
<h3 id="resultMap"><a href="#resultMap" class="headerlink" title="resultMap"></a>resultMap</h3><ul>
<li>自定义结果集映射</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--public Employee getEmpById(Integer id);--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--resultMap自定义返回规则</span></span><br><span class="line"><span class="comment">    type:自定义规则的Java类型</span></span><br><span class="line"><span class="comment">    id:唯一id方便引用</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;myEmp&quot;</span> <span class="attr">type</span>=<span class="string">&quot;com.kaixuan.bean.Employee&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--指定主键列的封装规则</span></span><br><span class="line"><span class="comment">        id定义会有底层优化</span></span><br><span class="line"><span class="comment">        column：指定哪一列</span></span><br><span class="line"><span class="comment">        property：javaBean属性</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--定义普通列封装--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;last_name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;lastName&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--其他不指定的列也会自动封装（名称需要对应）--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmpById&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;myEmp&quot;</span>&gt;</span></span><br><span class="line">    select * from tbl_employee where id=#&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="association"><a href="#association" class="headerlink" title="association"></a>association</h4><ul>
<li>resultMap可以实现联表查询，例如：在查询员工的时候得到员工所在部门的信息</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">	联合查询：级联属性封装结果集</span></span><br><span class="line"><span class="comment">  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">type</span>=<span class="string">&quot;com.atguigu.mybatis.bean.Employee&quot;</span> <span class="attr">id</span>=<span class="string">&quot;MyDifEmp&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;last_name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;lastName&quot;</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;gender&quot;</span> <span class="attr">property</span>=<span class="string">&quot;gender&quot;</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;did&quot;</span> <span class="attr">property</span>=<span class="string">&quot;dept.id&quot;</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;dept_name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;dept.departmentName&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">	使用association定义关联的单个对象的封装规则；</span></span><br><span class="line"><span class="comment"> --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">type</span>=<span class="string">&quot;com.atguigu.mybatis.bean.Employee&quot;</span> <span class="attr">id</span>=<span class="string">&quot;MyDifEmp2&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;last_name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;lastName&quot;</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;gender&quot;</span> <span class="attr">property</span>=<span class="string">&quot;gender&quot;</span>/&gt;</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">&lt;!--  association可以指定联合的javaBean对象</span></span><br><span class="line"><span class="comment">	property=&quot;dept&quot;：指定哪个属性是联合的对象</span></span><br><span class="line"><span class="comment">	javaType:指定这个属性对象的类型[不能省略]</span></span><br><span class="line"><span class="comment">	--&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;dept&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;com.atguigu.mybatis.bean.Department&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;did&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;dept_name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;departmentName&quot;</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--  public Employee getEmpAndDept(Integer id);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmpAndDept&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;MyDifEmp&quot;</span>&gt;</span></span><br><span class="line">	SELECT e.id id,e.last_name last_name,e.gender gender,e.d_id d_id,</span><br><span class="line">	d.id did,d.dept_name dept_name FROM tbl_employee e,tbl_dept d</span><br><span class="line">	WHERE e.d_id=d.id AND e.id=#&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 使用association进行分步查询：</span></span><br><span class="line"><span class="comment">	1、先按照员工id查询员工信息</span></span><br><span class="line"><span class="comment">	2、根据查询员工信息中的d_id值去部门表查出部门信息</span></span><br><span class="line"><span class="comment">	3、部门设置到员工中；</span></span><br><span class="line"><span class="comment"> --&gt;</span></span><br><span class="line"> </span><br><span class="line"> <span class="comment">&lt;!--  id  last_name  email   gender    d_id   --&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">type</span>=<span class="string">&quot;com.atguigu.mybatis.bean.Employee&quot;</span> <span class="attr">id</span>=<span class="string">&quot;MyEmpByStep&quot;</span>&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;last_name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;lastName&quot;</span>/&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;email&quot;</span> <span class="attr">property</span>=<span class="string">&quot;email&quot;</span>/&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;gender&quot;</span> <span class="attr">property</span>=<span class="string">&quot;gender&quot;</span>/&gt;</span></span><br><span class="line"> 	<span class="comment">&lt;!-- association定义关联对象的封装规则</span></span><br><span class="line"><span class="comment"> 		select:表明当前属性是调用select指定的方法查出的结果</span></span><br><span class="line"><span class="comment"> 		column:指定将哪一列的值传给这个方法</span></span><br><span class="line"><span class="comment"> 		</span></span><br><span class="line"><span class="comment"> 		流程：使用select指定的方法（传入column指定的这列参数的值）查出对象，并封装给property指定的属性</span></span><br><span class="line"><span class="comment"> 	 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;dept&quot;</span> </span></span><br><span class="line"><span class="tag"> 		<span class="attr">select</span>=<span class="string">&quot;com.atguigu.mybatis.dao.DepartmentMapper.getDeptById&quot;</span></span></span><br><span class="line"><span class="tag"> 		<span class="attr">column</span>=<span class="string">&quot;d_id&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">&lt;!--  public Employee getEmpByIdStep(Integer id);--&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmpByIdStep&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;MyEmpByStep&quot;</span>&gt;</span></span><br><span class="line"> 	select * from tbl_employee where id=#&#123;id&#125;</span><br><span class="line"> <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>可以使用延迟加载（懒加载)：部门信息在我们使用的时候再去查询，分段查询的基础之上加上两个配置：</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--全局配置文件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;lazyLoadingEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;aggressiveLazyLoading&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure>



<blockquote>
<p>查询部门的时候，获得该部门的所有员工:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--嵌套结果集的方式，使用collection标签定义关联的集合类型的属性封装规则  --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">type</span>=<span class="string">&quot;com.atguigu.mybatis.bean.Department&quot;</span> <span class="attr">id</span>=<span class="string">&quot;MyDept&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;did&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;dept_name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;departmentName&quot;</span>/&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">			collection定义关联集合类型的属性的封装规则 </span></span><br><span class="line"><span class="comment">			ofType:指定集合里面元素的类型</span></span><br><span class="line"><span class="comment">		--&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;emps&quot;</span> <span class="attr">ofType</span>=<span class="string">&quot;com.atguigu.mybatis.bean.Employee&quot;</span>&gt;</span></span><br><span class="line">			<span class="comment">&lt;!-- 定义这个集合中元素的封装规则 --&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;eid&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;last_name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;lastName&quot;</span>/&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;email&quot;</span> <span class="attr">property</span>=<span class="string">&quot;email&quot;</span>/&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;gender&quot;</span> <span class="attr">property</span>=<span class="string">&quot;gender&quot;</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">&lt;!-- public Department getDeptByIdPlus(Integer id); --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getDeptByIdPlus&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;MyDept&quot;</span>&gt;</span></span><br><span class="line">		SELECT d.id did,d.dept_name dept_name,</span><br><span class="line">				e.id eid,e.last_name last_name,e.email email,e.gender gender</span><br><span class="line">		FROM tbl_dept d</span><br><span class="line">		LEFT JOIN tbl_employee e</span><br><span class="line">		ON d.id=e.d_id</span><br><span class="line">		WHERE d.id=#&#123;id&#125;</span><br><span class="line">	<span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">&lt;!-- collection：分段查询 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">type</span>=<span class="string">&quot;com.atguigu.mybatis.bean.Department&quot;</span> <span class="attr">id</span>=<span class="string">&quot;MyDeptStep&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;dept_name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;departmentName&quot;</span>/&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">&lt;!-- 扩展：多列的值传递过去：</span></span><br><span class="line"><span class="comment">            将多列的值封装map传递；column=&quot;&#123;key1=column1,key2=column2&#125;&quot;</span></span><br><span class="line"><span class="comment">            fetchType=&quot;lazy&quot;：表示使用延迟加载；</span></span><br><span class="line"><span class="comment">             - lazy：延迟</span></span><br><span class="line"><span class="comment">             - eager：立即</span></span><br><span class="line"><span class="comment">    	--&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;emps&quot;</span> </span></span><br><span class="line"><span class="tag">			<span class="attr">select</span>=<span class="string">&quot;com.atguigu.mybatis.dao.EmployeeMapperPlus.getEmpsByDeptId&quot;</span></span></span><br><span class="line"><span class="tag">			<span class="attr">column</span>=<span class="string">&quot;&#123;deptId=id&#125;&quot;</span> <span class="attr">fetchType</span>=<span class="string">&quot;lazy&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">&lt;!-- public Department getDeptByIdStep(Integer id); --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getDeptByIdStep&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;MyDeptStep&quot;</span>&gt;</span></span><br><span class="line">		select id,dept_name from tbl_dept where id=#&#123;id&#125;</span><br><span class="line">	<span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="discriminator"><a href="#discriminator" class="headerlink" title="discriminator"></a>discriminator</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- &lt;discriminator javaType=&quot;&quot;&gt;&lt;/discriminator&gt;</span></span><br><span class="line"><span class="comment">	鉴别器：mybatis可以使用discriminator判断某列的值，然后根据某列的值改变封装行为</span></span><br><span class="line"><span class="comment">	封装Employee：</span></span><br><span class="line"><span class="comment">		如果查出的是女生：就把部门信息查询出来，否则不查询；</span></span><br><span class="line"><span class="comment">		如果是男生，把last_name这一列的值赋值给email;</span></span><br><span class="line"><span class="comment"> --&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">type</span>=<span class="string">&quot;com.atguigu.mybatis.bean.Employee&quot;</span> <span class="attr">id</span>=<span class="string">&quot;MyEmpDis&quot;</span>&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;last_name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;lastName&quot;</span>/&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;email&quot;</span> <span class="attr">property</span>=<span class="string">&quot;email&quot;</span>/&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;gender&quot;</span> <span class="attr">property</span>=<span class="string">&quot;gender&quot;</span>/&gt;</span></span><br><span class="line">        </span><br><span class="line"> 	<span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment"> 		column：指定判定的列名</span></span><br><span class="line"><span class="comment"> 		javaType：列值对应的java类型  </span></span><br><span class="line"><span class="comment">	--&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;<span class="name">discriminator</span> <span class="attr">javaType</span>=<span class="string">&quot;string&quot;</span> <span class="attr">column</span>=<span class="string">&quot;gender&quot;</span>&gt;</span></span><br><span class="line"> 		<span class="comment">&lt;!--女生  resultType:指定封装的结果类型；不能缺少。/resultMap--&gt;</span></span><br><span class="line"> 		<span class="tag">&lt;<span class="name">case</span> <span class="attr">value</span>=<span class="string">&quot;0&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.atguigu.mybatis.bean.Employee&quot;</span>&gt;</span></span><br><span class="line"> 			<span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;dept&quot;</span> </span></span><br><span class="line"><span class="tag">		 		<span class="attr">select</span>=<span class="string">&quot;com.atguigu.mybatis.dao.DepartmentMapper.getDeptById&quot;</span></span></span><br><span class="line"><span class="tag">		 		<span class="attr">column</span>=<span class="string">&quot;d_id&quot;</span>&gt;</span></span><br><span class="line">	 		<span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line"> 		<span class="tag">&lt;/<span class="name">case</span>&gt;</span></span><br><span class="line"> 		<span class="comment">&lt;!--男生 ;如果是男生，把last_name这一列的值赋值给email; --&gt;</span></span><br><span class="line"> 		<span class="tag">&lt;<span class="name">case</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.atguigu.mybatis.bean.Employee&quot;</span>&gt;</span></span><br><span class="line">	 		<span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">		 	<span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;last_name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;lastName&quot;</span>/&gt;</span></span><br><span class="line">		 	<span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;last_name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;email&quot;</span>/&gt;</span></span><br><span class="line">		 	<span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;gender&quot;</span> <span class="attr">property</span>=<span class="string">&quot;gender&quot;</span>/&gt;</span></span><br><span class="line"> 		<span class="tag">&lt;/<span class="name">case</span>&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;/<span class="name">discriminator</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h1 id="动态SQL"><a href="#动态SQL" class="headerlink" title="动态SQL"></a>动态SQL</h1><h2 id="if"><a href="#if" class="headerlink" title="if"></a>if</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    public List&lt;Employee&gt; getEmpsByConditionIf(Employee employee);</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmpsByConditionIf&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.kaixuan.bean.Employee&quot;</span>&gt;</span></span><br><span class="line">    select * from tbl_employee</span><br><span class="line">    where</span><br><span class="line">    /*if test:判断表达式(OGNL)</span><br><span class="line">        从参数中取值进行判断</span><br><span class="line">        遇见特殊符号写转义字符</span><br><span class="line">      */</span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;id!=null&quot;</span>&gt;</span></span><br><span class="line">        id=#&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;lastName != null and lastName != <span class="symbol">&amp;quot;</span><span class="symbol">&amp;quot;</span>&quot;</span>&gt;</span></span><br><span class="line">        and last_name like #&#123;lastName&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;email != null and email.trim() != <span class="symbol">&amp;quot;</span><span class="symbol">&amp;quot;</span>&quot;</span>&gt;</span></span><br><span class="line">        and email=#&#123;email&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;gender ==0 or gender ==1&quot;</span>&gt;</span></span><br><span class="line">        and gender=$&#123;gender&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="where"><a href="#where" class="headerlink" title="where"></a>where</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmpsByConditionIf&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.kaixuan.bean.Employee&quot;</span>&gt;</span></span><br><span class="line">    select * from tbl_employee</span><br><span class="line">    <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">        /*if test:判断表达式(OGNL)</span><br><span class="line">            从参数中取值进行判断</span><br><span class="line">            遇见特殊符号写转义字符</span><br><span class="line">          */</span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;id!=null&quot;</span>&gt;</span></span><br><span class="line">            id=#&#123;id&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;lastName != null and lastName != <span class="symbol">&amp;quot;</span><span class="symbol">&amp;quot;</span>&quot;</span>&gt;</span></span><br><span class="line">            and last_name like #&#123;lastName&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;email != null and email.trim() != <span class="symbol">&amp;quot;</span><span class="symbol">&amp;quot;</span>&quot;</span>&gt;</span></span><br><span class="line">            and email=#&#123;email&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;gender ==0 or gender ==1&quot;</span>&gt;</span></span><br><span class="line">            and gender=$&#123;gender&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>where标签可以自动去除写在前面的and</li>
</ul>
<h2 id="trim"><a href="#trim" class="headerlink" title="trim"></a>trim</h2><ul>
<li>自定义字符串截断规则</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--public List&lt;Employee&gt; getEmpsByConditionTrim(Employee employee);  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmpsByConditionTrim&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.atguigu.mybatis.bean.Employee&quot;</span>&gt;</span></span><br><span class="line">	select * from tbl_employee</span><br><span class="line">	<span class="comment">&lt;!-- 后面多出的and或者or where标签不能解决 </span></span><br><span class="line"><span class="comment">	prefix=&quot;&quot;:前缀：trim标签体中是整个字符串拼串 后的结果。</span></span><br><span class="line"><span class="comment">			prefix给拼串后的整个字符串加一个前缀 </span></span><br><span class="line"><span class="comment">	prefixOverrides=&quot;&quot;:</span></span><br><span class="line"><span class="comment">			前缀覆盖： 去掉整个字符串前面多余的字符</span></span><br><span class="line"><span class="comment">	suffix=&quot;&quot;:后缀</span></span><br><span class="line"><span class="comment">			suffix给拼串后的整个字符串加一个后缀 </span></span><br><span class="line"><span class="comment">	suffixOverrides=&quot;&quot;</span></span><br><span class="line"><span class="comment">			后缀覆盖：去掉整个字符串后面多余的字符</span></span><br><span class="line"><span class="comment">	--&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 自定义字符串的截取规则 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">trim</span> <span class="attr">prefix</span>=<span class="string">&quot;where&quot;</span> <span class="attr">suffixOverrides</span>=<span class="string">&quot;and&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;id!=null&quot;</span>&gt;</span></span><br><span class="line"> 		id=#&#123;id&#125; and</span><br><span class="line"> 	<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;lastName!=null <span class="symbol">&amp;amp;</span><span class="symbol">&amp;amp;</span> lastName!=<span class="symbol">&amp;quot;</span><span class="symbol">&amp;quot;</span>&quot;</span>&gt;</span></span><br><span class="line"> 		last_name like #&#123;lastName&#125; and</span><br><span class="line"> 	<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;email!=null and email.trim()!=<span class="symbol">&amp;quot;</span><span class="symbol">&amp;quot;</span>&quot;</span>&gt;</span></span><br><span class="line"> 		email=#&#123;email&#125; and</span><br><span class="line"> 	<span class="tag">&lt;/<span class="name">if</span>&gt;</span> </span><br><span class="line"> 	<span class="comment">&lt;!-- ognl会进行字符串与数字的转换判断  &quot;0&quot;==0 --&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;gender==0 or gender==1&quot;</span>&gt;</span></span><br><span class="line"> 	 	gender=#&#123;gender&#125;</span><br><span class="line"> 	<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">trim</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="choose"><a href="#choose" class="headerlink" title="choose"></a>choose</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- public List&lt;Employee&gt; getEmpsByConditionChoose(Employee employee); --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmpsByConditionChoose&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.atguigu.mybatis.bean.Employee&quot;</span>&gt;</span></span><br><span class="line">	select * from tbl_employee </span><br><span class="line">	<span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 如果带了id就用id查，如果带了lastName就用lastName查;只会进入其中一个 </span></span><br><span class="line"><span class="comment">		otherwise:不满足之前的就执行</span></span><br><span class="line"><span class="comment">	--&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">choose</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;id!=null&quot;</span>&gt;</span></span><br><span class="line">				id=#&#123;id&#125;</span><br><span class="line">			<span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;lastName!=null&quot;</span>&gt;</span></span><br><span class="line">				last_name like #&#123;lastName&#125;</span><br><span class="line">			<span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;email!=null&quot;</span>&gt;</span></span><br><span class="line">				email = #&#123;email&#125;</span><br><span class="line">			<span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">otherwise</span>&gt;</span></span><br><span class="line">				gender = 0</span><br><span class="line">			<span class="tag">&lt;/<span class="name">otherwise</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">choose</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">	 <span class="comment">&lt;!--public void updateEmp(Employee employee);  --&gt;</span></span><br><span class="line">	 <span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateEmp&quot;</span>&gt;</span></span><br><span class="line">	 	<span class="comment">&lt;!-- Set标签的使用 --&gt;</span></span><br><span class="line">	 	update tbl_employee </span><br><span class="line">		<span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;lastName!=null&quot;</span>&gt;</span></span><br><span class="line">				last_name=#&#123;lastName&#125;,</span><br><span class="line">			<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;email!=null&quot;</span>&gt;</span></span><br><span class="line">				email=#&#123;email&#125;,</span><br><span class="line">			<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;gender!=null&quot;</span>&gt;</span></span><br><span class="line">				gender=#&#123;gender&#125;</span><br><span class="line">			<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">		where id=#&#123;id&#125; </span><br><span class="line"><span class="comment">&lt;!-- 		</span></span><br><span class="line"><span class="comment">		Trim：更新拼串</span></span><br><span class="line"><span class="comment">		update tbl_employee </span></span><br><span class="line"><span class="comment">		&lt;trim prefix=&quot;set&quot; suffixOverrides=&quot;,&quot;&gt;</span></span><br><span class="line"><span class="comment">			&lt;if test=&quot;lastName!=null&quot;&gt;</span></span><br><span class="line"><span class="comment">				last_name=#&#123;lastName&#125;,</span></span><br><span class="line"><span class="comment">			&lt;/if&gt;</span></span><br><span class="line"><span class="comment">			&lt;if test=&quot;email!=null&quot;&gt;</span></span><br><span class="line"><span class="comment">				email=#&#123;email&#125;,</span></span><br><span class="line"><span class="comment">			&lt;/if&gt;</span></span><br><span class="line"><span class="comment">			&lt;if test=&quot;gender!=null&quot;&gt;</span></span><br><span class="line"><span class="comment">				gender=#&#123;gender&#125;</span></span><br><span class="line"><span class="comment">			&lt;/if&gt;</span></span><br><span class="line"><span class="comment">		&lt;/trim&gt;</span></span><br><span class="line"><span class="comment">		where id=#&#123;id&#125;  --&gt;</span></span><br><span class="line">	 <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a>foreach</h2><ul>
<li>多参数查找</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--public List&lt;Employee&gt; getEmpsByConditionForeach(List&lt;Integer&gt; ids);  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmpsByConditionForeach&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.atguigu.mybatis.bean.Employee&quot;</span>&gt;</span></span><br><span class="line">	select * from tbl_employee</span><br><span class="line">	<span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">		collection：指定要遍历的集合：</span></span><br><span class="line"><span class="comment">			list类型的参数会特殊处理封装在map中，map的key就叫list</span></span><br><span class="line"><span class="comment">		item：将当前遍历出的元素赋值给指定的变量</span></span><br><span class="line"><span class="comment">		separator:每个元素之间的分隔符</span></span><br><span class="line"><span class="comment">		open：遍历出所有结果拼接一个开始的字符</span></span><br><span class="line"><span class="comment">		close:遍历出所有结果拼接一个结束的字符</span></span><br><span class="line"><span class="comment">		index:索引。遍历list的时候是index就是索引，item就是当前值</span></span><br><span class="line"><span class="comment">				      遍历map的时候index表示的就是map的key，item就是map的值</span></span><br><span class="line"><span class="comment">		</span></span><br><span class="line"><span class="comment">		#&#123;变量名&#125;就能取出变量的值也就是当前遍历出的元素</span></span><br><span class="line"><span class="comment">	  --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;ids&quot;</span> <span class="attr">item</span>=<span class="string">&quot;item_id&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span></span></span><br><span class="line"><span class="tag">		<span class="attr">open</span>=<span class="string">&quot;where id in(&quot;</span> <span class="attr">close</span>=<span class="string">&quot;)&quot;</span>&gt;</span></span><br><span class="line">		#&#123;item_id&#125;</span><br><span class="line">	<span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>批量保存</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 批量保存 MySql--&gt;</span></span><br><span class="line">	 <span class="comment">&lt;!--public void addEmps(@Param(&quot;emps&quot;)List&lt;Employee&gt; emps);  --&gt;</span></span><br><span class="line">	 <span class="comment">&lt;!--MySQL下批量保存：可以foreach遍历   mysql支持values(),(),()语法--&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;addEmps&quot;</span>&gt;</span></span><br><span class="line">	 	insert into tbl_employee(last_name,email,gender,d_id)</span><br><span class="line">		values</span><br><span class="line">		<span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;emps&quot;</span> <span class="attr">item</span>=<span class="string">&quot;emp&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span>&gt;</span></span><br><span class="line">			(#&#123;emp.lastName&#125;,#&#123;emp.email&#125;,#&#123;emp.gender&#125;,#&#123;emp.dept.id&#125;)</span><br><span class="line">		<span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line">	 <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="comment">&lt;!-- 这种方式需要数据库连接属性allowMultiQueries=true；</span></span><br><span class="line"><span class="comment">	 	这种分号分隔多个sql可以用于其他的批量操作（删除，修改） --&gt;</span></span><br><span class="line">	 <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;addEmps&quot;</span>&gt;</span></span><br><span class="line">	 	<span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;emps&quot;</span> <span class="attr">item</span>=<span class="string">&quot;emp&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;;&quot;</span>&gt;</span></span><br><span class="line">	 		insert into tbl_employee(last_name,email,gender,d_id)</span><br><span class="line">	 		values(#&#123;emp.lastName&#125;,#&#123;emp.email&#125;,#&#123;emp.gender&#125;,#&#123;emp.dept.id&#125;)</span><br><span class="line">	 	<span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line">	 <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Oracle数据库批量保存： </span></span><br><span class="line"><span class="comment">	Oracle不支持values(),(),()</span></span><br><span class="line"><span class="comment">	Oracle支持的批量方式</span></span><br><span class="line"><span class="comment">	1、多个insert放在begin - end里面</span></span><br><span class="line"><span class="comment">		begin</span></span><br><span class="line"><span class="comment">	    insert into employees(employee_id,last_name,email) </span></span><br><span class="line"><span class="comment">	    values(employees_seq.nextval,&#x27;test_001&#x27;,&#x27;test_001@atguigu.com&#x27;);</span></span><br><span class="line"><span class="comment">	    insert into employees(employee_id,last_name,email) </span></span><br><span class="line"><span class="comment">	    values(employees_seq.nextval,&#x27;test_002&#x27;,&#x27;test_002@atguigu.com&#x27;);</span></span><br><span class="line"><span class="comment">	end;</span></span><br><span class="line"><span class="comment">2、利用中间表：</span></span><br><span class="line"><span class="comment">	insert into employees(employee_id,last_name,email)</span></span><br><span class="line"><span class="comment">       select employees_seq.nextval,lastName,email from(</span></span><br><span class="line"><span class="comment">              select &#x27;test_a_01&#x27; lastName,&#x27;test_a_e01&#x27; email from dual</span></span><br><span class="line"><span class="comment">              union</span></span><br><span class="line"><span class="comment">              select &#x27;test_a_02&#x27; lastName,&#x27;test_a_e02&#x27; email from dual</span></span><br><span class="line"><span class="comment">              union</span></span><br><span class="line"><span class="comment">              select &#x27;test_a_03&#x27; lastName,&#x27;test_a_e03&#x27; email from dual</span></span><br><span class="line"><span class="comment">       )	</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;addEmps&quot;</span> <span class="attr">databaseId</span>=<span class="string">&quot;oracle&quot;</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- oracle第一种批量方式 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;emps&quot;</span> <span class="attr">item</span>=<span class="string">&quot;emp&quot;</span> <span class="attr">open</span>=<span class="string">&quot;begin&quot;</span> <span class="attr">close</span>=<span class="string">&quot;end;&quot;</span>&gt;</span></span><br><span class="line">		insert into employees(employee_id,last_name,email) </span><br><span class="line">	    values(employees_seq.nextval,#&#123;emp.lastName&#125;,#&#123;emp.email&#125;);</span><br><span class="line">	<span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">&lt;!-- oracle第二种批量方式  --&gt;</span></span><br><span class="line">	insert into employees(</span><br><span class="line">		<span class="comment">&lt;!-- 引用外部定义的sql --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;insertColumn&quot;</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;testColomn&quot;</span> <span class="attr">value</span>=<span class="string">&quot;abc&quot;</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">	)</span><br><span class="line">       <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;emps&quot;</span> <span class="attr">item</span>=<span class="string">&quot;emp&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;union&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">open</span>=<span class="string">&quot;select employees_seq.nextval,lastName,email from(&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">close</span>=<span class="string">&quot;)&quot;</span>&gt;</span></span><br><span class="line">           select #&#123;emp.lastName&#125; lastName,#&#123;emp.email&#125; email from dual</span><br><span class="line">       <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="内置参数"><a href="#内置参数" class="headerlink" title="内置参数"></a>内置参数</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- mybatis默认还有两个内置参数：</span></span><br><span class="line"><span class="comment">	_parameter:代表整个参数</span></span><br><span class="line"><span class="comment">		单个参数：_parameter就是这个参数</span></span><br><span class="line"><span class="comment">		多个参数：参数会被封装为一个map；_parameter就是代表这个map</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	_databaseId:如果配置了databaseIdProvider标签。</span></span><br><span class="line"><span class="comment">		_databaseId就是代表当前数据库的别名oracle</span></span><br><span class="line"><span class="comment"> --&gt;</span></span><br><span class="line"> </span><br><span class="line"> <span class="comment">&lt;!--public List&lt;Employee&gt; getEmpsTestInnerParameter(Employee employee);  --&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmpsTestInnerParameter&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.atguigu.mybatis.bean.Employee&quot;</span>&gt;</span></span><br><span class="line"> 		<span class="comment">&lt;!-- bind：可以将OGNL表达式的值绑定到一个变量中，方便后来引用这个变量的值 --&gt;</span></span><br><span class="line"> 		<span class="tag">&lt;<span class="name">bind</span> <span class="attr">name</span>=<span class="string">&quot;_lastName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&#x27;%&#x27;+lastName+&#x27;%&#x27;&quot;</span>/&gt;</span></span><br><span class="line"> 		<span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;_databaseId==&#x27;mysql&#x27;&quot;</span>&gt;</span></span><br><span class="line"> 			select * from tbl_employee</span><br><span class="line"> 			<span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;_parameter!=null&quot;</span>&gt;</span></span><br><span class="line"> 				where last_name like #&#123;_lastName&#125;</span><br><span class="line"> 			<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"> 		<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"> 		<span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;_databaseId==&#x27;oracle&#x27;&quot;</span>&gt;</span></span><br><span class="line"> 			select * from employees</span><br><span class="line"> 			<span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;_parameter!=null&quot;</span>&gt;</span></span><br><span class="line"> 				where last_name like #&#123;_parameter.lastName&#125;</span><br><span class="line"> 			<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"> 		<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="sql"><a href="#sql" class="headerlink" title="sql"></a>sql</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">	  <span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">	  	抽取可重用的sql片段。方便后面引用 </span></span><br><span class="line"><span class="comment">	  	1、sql抽取：经常将要查询的列名，或者插入用的列名抽取出来方便引用</span></span><br><span class="line"><span class="comment">	  	2、include来引用已经抽取的sql：</span></span><br><span class="line"><span class="comment">	  	3、include还可以自定义一些property，sql标签内部就能使用自定义的属性</span></span><br><span class="line"><span class="comment">	  			include-property：取值的正确方式$&#123;prop&#125;,</span></span><br><span class="line"><span class="comment">	  			#&#123;不能使用这种方式&#125;</span></span><br><span class="line"><span class="comment">	  --&gt;</span></span><br><span class="line">	  <span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">&quot;insertColumn&quot;</span>&gt;</span></span><br><span class="line">	  		<span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;_databaseId==&#x27;oracle&#x27;&quot;</span>&gt;</span></span><br><span class="line">	  			employee_id,last_name,email</span><br><span class="line">	  		<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">	  		<span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;_databaseId==&#x27;mysql&#x27;&quot;</span>&gt;</span></span><br><span class="line">	  			last_name,email,gender,d_id</span><br><span class="line">	  		<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">	  <span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;insertColumn&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h1 id="缓存机制"><a href="#缓存机制" class="headerlink" title="缓存机制"></a>缓存机制</h1><ul>
<li>MyBatis系统中默认定义了两级缓存：一级缓存和二级缓存</li>
</ul>
<h2 id="一级缓存（本地缓存）"><a href="#一级缓存（本地缓存）" class="headerlink" title="一级缓存（本地缓存）"></a>一级缓存（本地缓存）</h2><ul>
<li>一级缓存：sqlSession级别的缓存。一级缓存是一直开启的；SqlSession级别的一个Map与数据库同一次会话期间查询到的数据会放在本地缓存中。以后如果需要获取相同的数据，直接从缓存中拿，没必要再去查询数据库</li>
<li>一级缓存失效情况（没有使用到当前一级缓存的情况，还需要再向数据库发出查询）<ul>
<li>sqlSession不同</li>
<li>sqlSession相同，查询条件不同.(当前一级缓存中还没有这个数据)</li>
<li>sqlSession相同，两次查询之间执行了增删改操作(这次增删改可能对当前数据有影响)</li>
<li>sqlSession相同，手动清除了一级缓存（缓存清空：sqlSession.clearCache())</li>
</ul>
</li>
</ul>
<h2 id="二级缓存（全局缓存）"><a href="#二级缓存（全局缓存）" class="headerlink" title="二级缓存（全局缓存）"></a>二级缓存（全局缓存）</h2><ul>
<li><p>二级缓存：基于namespace级别的缓存：一个namespace对应一个二级缓存</p>
</li>
<li><p>工作机制：</p>
<ol>
<li><p>一个会话，查询一条数据，这个数据就会被放在当前会话的一级缓存中</p>
</li>
<li><p>如果会话关闭，一级缓存中的数据会被保存到二级缓存中。新的会话查询信息，就可以参照二级缓存中的内</p>
</li>
<li><p>sqlSession===EmployeeMapper==&gt;Employee                  DepartmentMapper===&gt;Department</p>
<pre><code>                 不同namespace查出的数据会放在自己对应的缓存中（map）
</code></pre>
</li>
<li><p>最终效果：数据会从二级缓存中获取。</p>
<blockquote>
<p>查出的数据都会被默认先放在一级缓存中。只有会话提交或者关闭以后，一级缓存中的数据才会转移到二级缓存中</p>
</blockquote>
</li>
</ol>
</li>
<li><p>使用：</p>
<ul>
<li>开启全局二级缓存配置：&lt;setting name=”cacheEnabled” value=”true”/&gt;</li>
<li>mapper.xml中配置使用二级缓存：&lt;cache&gt;&lt;/cache&gt;</li>
<li>POJO需要实现序列化接口</li>
</ul>
</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cache</span> <span class="attr">type</span>=<span class="string">&quot;org.mybatis.caches.ehcache.EhcacheCache&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">cache</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- &lt;cache eviction=&quot;FIFO&quot; flushInterval=&quot;60000&quot; readOnly=&quot;false&quot; size=&quot;1024&quot;&gt;&lt;/cache&gt; --&gt;</span></span><br><span class="line"><span class="comment">&lt;!--  </span></span><br><span class="line"><span class="comment">eviction:缓存的回收策略：</span></span><br><span class="line"><span class="comment">	• LRU – 最近最少使用的：移除最长时间不被使用的对象。</span></span><br><span class="line"><span class="comment">	• FIFO – 先进先出：按对象进入缓存的顺序来移除它们。</span></span><br><span class="line"><span class="comment">	• SOFT – 软引用：移除基于垃圾回收器状态和软引用规则的对象。</span></span><br><span class="line"><span class="comment">	• WEAK – 弱引用：更积极地移除基于垃圾收集器状态和弱引用规则的对象。</span></span><br><span class="line"><span class="comment">	• 默认的是 LRU。</span></span><br><span class="line"><span class="comment">flushInterval：缓存刷新间隔</span></span><br><span class="line"><span class="comment">	缓存多长时间清空一次，默认不清空，设置一个毫秒值</span></span><br><span class="line"><span class="comment">readOnly:是否只读：</span></span><br><span class="line"><span class="comment">	true：只读；mybatis认为所有从缓存中获取数据的操作都是只读操作，不会修改数据。</span></span><br><span class="line"><span class="comment">			 mybatis为了加快获取速度，直接就会将数据在缓存中的引用交给用户。不安全，速度快</span></span><br><span class="line"><span class="comment">	false：非只读：mybatis觉得获取的数据可能会被修改。</span></span><br><span class="line"><span class="comment">			mybatis会利用序列化&amp;反序列的技术克隆一份新的数据给你。安全，速度慢</span></span><br><span class="line"><span class="comment">size：缓存存放多少元素；</span></span><br><span class="line"><span class="comment">type=&quot;&quot;：指定自定义缓存的全类名；</span></span><br><span class="line"><span class="comment">		实现Cache接口即可；</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>和缓存有关的设置/属性：<ul>
<li>cacheEnabled=true：false：关闭缓存（二级缓存关闭）(一级缓存一直可用)</li>
<li>每个select标签都有useCache=”true”(默认为true)，false：不使用缓存（一级缓存依然使用，二级缓存不使用）</li>
<li>每个增删改标签的：flushCache=”true”：（一级二级都会清除），增删改执行完成后就会清除缓存</li>
<li>查询标签：flushCache=”false”。如果flushCache=true;每次查询之后都会清空缓存，缓存是没有被使用</li>
<li>sqlSession.clearCache()，只是清除当前session的一级缓存</li>
<li>localCacheScope：本地缓存作用域<ul>
<li>SESSION：当前会话的所有数据保存在会话缓存中</li>
<li>STATEMENT：可以禁用一级缓存</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="缓存原理"><a href="#缓存原理" class="headerlink" title="缓存原理"></a>缓存原理</h2><p><img src="/2021/10/18/day25/day25_4.png" alt="缓存原理"></p>
<h2 id="整合第三方缓存"><a href="#整合第三方缓存" class="headerlink" title="整合第三方缓存"></a>整合第三方缓存</h2><ul>
<li>第三方缓存整合：<ul>
<li>导入第三方缓存包即可</li>
<li>导入与第三方缓存整合的适配包</li>
<li>mapper.xml中使用自定义缓存&lt;cache type=”org.mybatis.caches.ehcache.EhcacheCache”&gt;&lt;/cache&gt;</li>
</ul>
</li>
</ul>
<h1 id="Mybatis-Spring整合"><a href="#Mybatis-Spring整合" class="headerlink" title="Mybatis-Spring整合"></a>Mybatis-Spring整合</h1><ul>
<li>导入spring相关包，mybatis相关包，spring-mybatis适配包</li>
<li>整合配置文件</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Spring希望管理所有的业务逻辑组件，等。。。 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.atguigu.mybatis&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">context:exclude-filter</span> <span class="attr">type</span>=<span class="string">&quot;annotation&quot;</span></span></span><br><span class="line"><span class="tag">		<span class="attr">expression</span>=<span class="string">&quot;org.springframework.stereotype.Controller&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 引入数据库的配置文件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath:dbconfig.properties&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Spring用来控制业务逻辑。数据源、事务控制、aop --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;jdbcUrl&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClass&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.driver&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.username&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- spring事务管理 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSourceTransactionManager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 开启基于注解的事务 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:annotation-driven</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;dataSourceTransactionManager&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">整合mybatis </span></span><br><span class="line"><span class="comment">	目的：1、spring管理所有组件。mapper的实现类。</span></span><br><span class="line"><span class="comment">			service==&gt;Dao   @Autowired:自动注入mapper；</span></span><br><span class="line"><span class="comment">		2、spring用来管理事务，spring声明式事务</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--创建出SqlSessionFactory对象  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;sqlSessionFactoryBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- configLocation指定全局配置文件的位置 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;configLocation&quot;</span> <span class="attr">value</span>=<span class="string">&quot;classpath:mybatis-config.xml&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!--mapperLocations: 指定mapper文件的位置--&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;mapperLocations&quot;</span> <span class="attr">value</span>=<span class="string">&quot;classpath:mybatis/mapper/*.xml&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--配置一个可以进行批量执行的sqlSession  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;sqlSession&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.SqlSessionTemplate&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;sqlSessionFactory&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;sqlSessionFactoryBean&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;executorType&quot;</span> <span class="attr">value</span>=<span class="string">&quot;BATCH&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 扫描所有的mapper接口的实现，让这些mapper能够自动注入；</span></span><br><span class="line"><span class="comment">base-package：指定mapper接口的包名</span></span><br><span class="line"><span class="comment"> --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mybatis-spring:scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.atguigu.mybatis.dao&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- &lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;</span></span><br><span class="line"><span class="comment">	&lt;property name=&quot;basePackage&quot; value=&quot;com.atguigu.mybatis.dao&quot;&gt;&lt;/property&gt;</span></span><br><span class="line"><span class="comment">&lt;/bean&gt; --&gt;</span></span><br></pre></td></tr></table></figure>



<h1 id="逆向工程"><a href="#逆向工程" class="headerlink" title="逆向工程"></a>逆向工程</h1><ul>
<li>简称MBG，是一个专门为MyBatis框架使用者定制的代码生成器，可以快速的根据表生成对应的映射文件，接口，以及bean类。支持基本的增删改查，以及QBC风格的条件查询。</li>
</ul>
<h2 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h2><ul>
<li>导入mybatis-generator-core.jar包</li>
<li>编写配置文件</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">generatorConfiguration</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">generatorConfiguration</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        targetRuntime=&quot;MyBatis3Simple&quot;:生成简单版的CRUD</span></span><br><span class="line"><span class="comment">        MyBatis3:豪华版</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context</span> <span class="attr">id</span>=<span class="string">&quot;DB2Tables&quot;</span> <span class="attr">targetRuntime</span>=<span class="string">&quot;MyBatis3&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- jdbcConnection：指定如何连接到目标数据库 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">jdbcConnection</span> <span class="attr">driverClass</span>=<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">connectionURL</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/Mybatis?allowMultiQueries=true&quot;</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">userId</span>=<span class="string">&quot;root&quot;</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">password</span>=<span class="string">&quot;111111&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">jdbcConnection</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--  --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">javaTypeResolver</span> &gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;forceBigDecimals&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">javaTypeResolver</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- javaModelGenerator：指定javaBean的生成策略</span></span><br><span class="line"><span class="comment">        targetPackage=&quot;MybatisTsest.model&quot;：目标包名</span></span><br><span class="line"><span class="comment">        targetProject=&quot;\MBGTestProject\src&quot;：目标工程</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">javaModelGenerator</span> <span class="attr">targetPackage</span>=<span class="string">&quot;com.kaixuan.bean&quot;</span></span></span><br><span class="line"><span class="tag">                            <span class="attr">targetProject</span>=<span class="string">&quot;src/main/java&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;enableSubPackages&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;trimStrings&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">javaModelGenerator</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- sqlMapGenerator：sql映射生成策略： --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">sqlMapGenerator</span> <span class="attr">targetPackage</span>=<span class="string">&quot;com.kaixuan.dao&quot;</span> <span class="attr">targetProject</span>=<span class="string">&quot;src/main/resources&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;enableSubPackages&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">sqlMapGenerator</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- javaClientGenerator:指定mapper接口所在的位置 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">javaClientGenerator</span> <span class="attr">type</span>=<span class="string">&quot;XMLMAPPER&quot;</span> <span class="attr">targetPackage</span>=<span class="string">&quot;com.kaixuan.dao&quot;</span></span></span><br><span class="line"><span class="tag">                             <span class="attr">targetProject</span>=<span class="string">&quot;src/main/java&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;enableSubPackages&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">javaClientGenerator</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 指定要逆向分析哪些表：根据表要创建javaBean --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">table</span> <span class="attr">tableName</span>=<span class="string">&quot;tbl_employee&quot;</span> <span class="attr">domainObjectName</span>=<span class="string">&quot;Employee&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">generatorConfiguration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>运行生成器</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMbg</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    List&lt;String&gt; warnings = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    <span class="keyword">boolean</span> overwrite = <span class="keyword">true</span>;</span><br><span class="line">    File configFile = <span class="keyword">new</span> File(<span class="string">&quot;src/main/resources/mbg.xml&quot;</span>);</span><br><span class="line"></span><br><span class="line">    ConfigurationParser cp = <span class="keyword">new</span> ConfigurationParser(warnings);</span><br><span class="line">    Configuration config = cp.parseConfiguration(configFile);</span><br><span class="line">    DefaultShellCallback callback = <span class="keyword">new</span> DefaultShellCallback(overwrite);</span><br><span class="line">    MyBatisGenerator myBatisGenerator = <span class="keyword">new</span> MyBatisGenerator(config,callback, warnings);</span><br><span class="line">    myBatisGenerator.generate(<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>测试代码</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMyBatis3</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">	SqlSessionFactory sqlSessionFactory = getSqlSessionFactory();</span><br><span class="line">	SqlSession openSession = sqlSessionFactory.openSession();</span><br><span class="line">	<span class="keyword">try</span>&#123;</span><br><span class="line">		EmployeeMapper mapper = openSession.getMapper(EmployeeMapper.class);</span><br><span class="line">		<span class="comment">//xxxExample就是封装查询条件的</span></span><br><span class="line">		<span class="comment">//1、查询所有</span></span><br><span class="line">		<span class="comment">//List&lt;Employee&gt; emps = mapper.selectByExample(null);</span></span><br><span class="line">		<span class="comment">//2、查询员工名字中有e字母的，和员工性别是1的</span></span><br><span class="line">		<span class="comment">//封装员工查询条件的example</span></span><br><span class="line">		EmployeeExample example = <span class="keyword">new</span> EmployeeExample();</span><br><span class="line">		<span class="comment">//创建一个Criteria，这个Criteria就是拼装查询条件</span></span><br><span class="line">		<span class="comment">//select id, last_name, email, gender, d_id from tbl_employee </span></span><br><span class="line">		<span class="comment">//WHERE ( last_name like ? and gender = ? ) or email like &quot;%e%&quot;</span></span><br><span class="line">		Criteria criteria = example.createCriteria();</span><br><span class="line">		criteria.andLastNameLike(<span class="string">&quot;%e%&quot;</span>);</span><br><span class="line">		criteria.andGenderEqualTo(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">		</span><br><span class="line">		Criteria criteria2 = example.createCriteria();</span><br><span class="line">		criteria2.andEmailLike(<span class="string">&quot;%e%&quot;</span>);</span><br><span class="line">		example.or(criteria2);</span><br><span class="line">		</span><br><span class="line">		List&lt;Employee&gt; list = mapper.selectByExample(example);</span><br><span class="line">		<span class="keyword">for</span> (Employee employee : list) &#123;</span><br><span class="line">			System.out.println(employee.getId());</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">		openSession.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="Mybatis工作原理"><a href="#Mybatis工作原理" class="headerlink" title="Mybatis工作原理"></a>Mybatis工作原理</h1><p><img src="/2021/10/18/day25/day25_5.png" alt="工作原理"></p>
<h2 id="运行流程"><a href="#运行流程" class="headerlink" title="运行流程"></a>运行流程</h2><ul>
<li><p>获得sqlSessionFactory对象</p>
<p><img src="/2021/10/18/day25/day25_6.png" alt="获得factory"></p>
</li>
<li><p>获得sqlSession对象</p>
<p><img src="/2021/10/18/day25/day25_7.png" alt="sqlSession"></p>
</li>
<li><p>获得接口的实现类对象</p>
<p><img src="/2021/10/18/day25/day25_8.png" alt="接口的实现类"></p>
</li>
</ul>
<h2 id="查询原理"><a href="#查询原理" class="headerlink" title="查询原理"></a>查询原理</h2><p><img src="/2021/10/18/day25/day25_9.png" alt="查询流程"></p>
<p><img src="/2021/10/18/day25/day25_10.png" alt="总结"></p>
<h1 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h1><ul>
<li><p> 插件原理：在四大对象创建的过程：</p>
</li>
<li><p>创建出来的对象不是直接返回的，而是使用interceptorChain.pluginAll(parameterHandler)，获取到所有的Interceptor（拦截器）（插件需要实现的接口）</p>
</li>
<li><p>调用interceptor.plugin(target)，返回target包装后的对象</p>
</li>
</ul>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">pluginAll</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Interceptor interceptor : interceptors) &#123;</span><br><span class="line">        target = interceptor.plugin(target);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>插件机制，我们可以使用插件为目标对象创建一个代理对象，AOP（面向切面）。我们的插件可以为四大对象创建出代理对象，代理对象就可以拦截到四大对象的每一个执行</li>
</ul>
<h2 id="插件编写"><a href="#插件编写" class="headerlink" title="插件编写"></a>插件编写</h2><ul>
<li>插件编写：<ul>
<li>编写Interceptor的实现类</li>
<li>使用@Intercepts注解完成插件签名</li>
<li>将写好的插件注册到全局配置文件中</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 完成插件签名：</span></span><br><span class="line"><span class="comment"> *		告诉MyBatis当前插件用来拦截哪个对象的哪个方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Intercepts(</span></span><br><span class="line"><span class="meta">		&#123;</span></span><br><span class="line"><span class="meta">			@Signature(type=StatementHandler.class,method=&quot;parameterize&quot;,args=java.sql.Statement.class)</span></span><br><span class="line"><span class="meta">		&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyFirstPlugin</span> <span class="keyword">implements</span> <span class="title">Interceptor</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * intercept：拦截：</span></span><br><span class="line"><span class="comment">	 * 		拦截目标对象的目标方法的执行；</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		System.out.println(<span class="string">&quot;MyFirstPlugin...intercept:&quot;</span>+invocation.getMethod());</span><br><span class="line">		<span class="comment">//动态的改变一下sql运行的参数：以前1号员工，实际从数据库查询3号员工</span></span><br><span class="line">		Object target = invocation.getTarget();</span><br><span class="line">		System.out.println(<span class="string">&quot;当前拦截到的对象：&quot;</span>+target);</span><br><span class="line">		<span class="comment">//拿到：StatementHandler==&gt;ParameterHandler===&gt;parameterObject</span></span><br><span class="line">		<span class="comment">//拿到target的元数据</span></span><br><span class="line">		MetaObject metaObject = SystemMetaObject.forObject(target);</span><br><span class="line">		Object value = metaObject.getValue(<span class="string">&quot;parameterHandler.parameterObject&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;sql语句用的参数是：&quot;</span>+value);</span><br><span class="line">		<span class="comment">//修改完sql语句要用的参数</span></span><br><span class="line">		metaObject.setValue(<span class="string">&quot;parameterHandler.parameterObject&quot;</span>, <span class="number">11</span>);</span><br><span class="line">		<span class="comment">//执行目标方法</span></span><br><span class="line">		Object proceed = invocation.proceed();</span><br><span class="line">		<span class="comment">//返回执行后的返回值</span></span><br><span class="line">		<span class="keyword">return</span> proceed;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * plugin：</span></span><br><span class="line"><span class="comment">	 * 		包装目标对象的：包装：为目标对象创建一个代理对象</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">plugin</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="comment">//我们可以借助Plugin的wrap方法来使用当前Interceptor包装我们目标对象</span></span><br><span class="line">		System.out.println(<span class="string">&quot;MyFirstPlugin...plugin:mybatis将要包装的对象&quot;</span>+target);</span><br><span class="line">		Object wrap = Plugin.wrap(target, <span class="keyword">this</span>);</span><br><span class="line">		<span class="comment">//返回为当前target创建的动态代理</span></span><br><span class="line">		<span class="keyword">return</span> wrap;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * setProperties：</span></span><br><span class="line"><span class="comment">	 * 		将插件注册时 的property属性设置进来</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setProperties</span><span class="params">(Properties properties)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		System.out.println(<span class="string">&quot;插件配置的信息：&quot;</span>+properties);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--plugins：注册插件  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">plugin</span> <span class="attr">interceptor</span>=<span class="string">&quot;com.atguigu.mybatis.dao.MyFirstPlugin&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;123456&quot;</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">plugin</span> <span class="attr">interceptor</span>=<span class="string">&quot;com.atguigu.mybatis.dao.MySecondPlugin&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>多个插件拦截同一个对象，会产生多层代理对象，先配置的插件先包装</li>
</ul>
<p><img src="/2021/10/18/day25/day25_11.png" alt="多个插件"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/10/08/day24/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Kaixuan Wang">
      <meta itemprop="description" content="只争朝夕">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Magic">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/10/08/day24/" class="post-title-link" itemprop="url">SpringMVC</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-10-08 10:35:44" itemprop="dateCreated datePublished" datetime="2021-10-08T10:35:44+08:00">2021-10-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-10-18 12:18:23" itemprop="dateModified" datetime="2021-10-18T12:18:23+08:00">2021-10-18</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><ul>
<li>MVC是一种软件架构的思想，将软件按照模型、视图、控制器来划分<ul>
<li>M：Model，模型层，指工程中的JavaBean，作用是处理数据<ul>
<li>一类称为实体类Bean：专门存储业务数据的，如 Student、User 等</li>
<li>一类称为业务处理 Bean：指 Service 或 Dao 对象，专门用于处理业务逻辑和数据访问</li>
</ul>
</li>
<li>V：View，视图层，指工程中的html或jsp等页面，作用是与用户进行交互，展示数据</li>
<li>C：Controller，控制层，指工程中的servlet，作用是接收请求和响应浏览器</li>
</ul>
</li>
<li>SpringMVC 是 Spring 为表述层开发提供的一整套完备的解决方案<ul>
<li>三层架构分为表述层（或表示层）、业务逻辑层、数据访问层，表述层表示前台页面和后台servlet</li>
</ul>
</li>
<li>SpringMVC特点：<ul>
<li>基于原生的Servlet，通过了功能强大的前端控制器<strong>DispatcherServlet</strong>，对请求和响应进行统一处理</li>
</ul>
</li>
</ul>
<h1 id="创建SpringMVC工程"><a href="#创建SpringMVC工程" class="headerlink" title="创建SpringMVC工程"></a>创建SpringMVC工程</h1><ul>
<li>添加web模块</li>
<li>打包方式：war</li>
<li>引入依赖</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- SpringMVC --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 日志 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ch.qos.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logback-classic<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- ServletAPI --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- Spring5和Thymeleaf整合包 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.thymeleaf<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>thymeleaf-spring5<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.12.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="配置web-xml"><a href="#配置web-xml" class="headerlink" title="配置web.xml"></a>配置web.xml</h2><ul>
<li>注册SpringMVC的前端控制器DispatcherServlet</li>
</ul>
<h3 id="默认配置方式"><a href="#默认配置方式" class="headerlink" title="默认配置方式"></a>默认配置方式</h3><ul>
<li>此配置作用下，SpringMVC的配置文件默认位于WEB-INF下，默认名称为&lt;servlet-name&gt;-servlet.xml，例如，以下配置所对应SpringMVC的配置文件位于WEB-INF下，文件名为springMVC-servlet.xml</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">version</span>=<span class="string">&quot;4.0&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--配置SpringMVC的前端控制器，对浏览器发送的请求进行统一处理--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springMVC<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springMVC<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">            设置springMVC的核心控制器所能处理的请求的请求路径</span></span><br><span class="line"><span class="comment">            /所匹配的请求可以是/login或.html或.js或.css方式的请求路径</span></span><br><span class="line"><span class="comment">            但是/不能匹配.jsp请求路径的请求</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="扩展配置方式"><a href="#扩展配置方式" class="headerlink" title="扩展配置方式"></a>扩展配置方式</h3><ul>
<li>可通过init-param标签设置SpringMVC配置文件的位置和名称，通过load-on-startup标签设置SpringMVC前端控制器DispatcherServlet的初始化时间</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">version</span>=<span class="string">&quot;4.0&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 配置SpringMVC的前端控制器，对浏览器发送的请求统一进行处理 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springMVC<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 通过初始化参数指定SpringMVC配置文件的位置和名称 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- contextConfigLocation为固定值 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 使用classpath:表示从类路径查找配置文件，例如maven工程中的src/main/resources --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:springMVC.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">            作为框架的核心组件，在启动过程中有大量的初始化操作要做</span></span><br><span class="line"><span class="comment">            而这些操作放在第一次请求时才执行会严重影响访问速度</span></span><br><span class="line"><span class="comment">            因此需要通过此标签将启动控制DispatcherServlet的初始化时间提前到服务器启动时</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springMVC<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">            设置springMVC的核心控制器所能处理的请求的请求路径</span></span><br><span class="line"><span class="comment">            /所匹配的请求可以是/login或.html或.js或.css方式的请求路径</span></span><br><span class="line"><span class="comment">            但是/不能匹配.jsp请求路径的请求</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注：</p>
<p>&lt;url-pattern&gt;标签中使用/和/*的区别：</p>
<p>/所匹配的请求可以是/login或.html或.js或.css方式的请求路径，但是/不能匹配.jsp请求路径的请求</p>
<p>因此就可以避免在访问jsp页面时，该请求被DispatcherServlet处理，从而找不到相应的页面</p>
<p>/*则能够匹配所有请求，例如在使用过滤器时，若需要对所有请求进行过滤，就需要使用/*的写法</p>
</blockquote>
<h2 id="创建请求控制器"><a href="#创建请求控制器" class="headerlink" title="创建请求控制器"></a>创建请求控制器</h2><ul>
<li>由于前端控制器对浏览器发送的请求进行了统一的处理，但是具体的请求有不同的处理过程，因此需要创建处理具体请求的类，即请求控制器。请求控制器中每一个处理请求的方法称为控制器方法</li>
<li>因为SpringMVC的控制器由一个POJO（普通的Java类）担任，因此需要通过@Controller注解将其标识为一个控制层组件，交给Spring的IOC容器管理，此时SpringMVC才能够识别控制器的存在</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kaixuan.demo;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloServlet</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="创建springMVC的配置文件"><a href="#创建springMVC的配置文件" class="headerlink" title="创建springMVC的配置文件"></a>创建springMVC的配置文件</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:mvc</span>=<span class="string">&quot;http://www.springframework.org/schema/p&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">                            http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 自动扫描包 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.kaixuan.demo&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 配置Thymeleaf视图解析器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;viewResolver&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.thymeleaf.spring5.view.ThymeleafViewResolver&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;order&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;characterEncoding&quot;</span> <span class="attr">value</span>=<span class="string">&quot;UTF-8&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;templateEngine&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.thymeleaf.spring5.SpringTemplateEngine&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;templateResolver&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.thymeleaf.spring5.templateresolver.SpringResourceTemplateResolver&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                        <span class="comment">&lt;!-- 视图前缀 --&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;prefix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/WEB-INF/templates/&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">                        <span class="comment">&lt;!-- 视图后缀 --&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suffix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;.html&quot;</span>/&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;templateMode&quot;</span> <span class="attr">value</span>=<span class="string">&quot;HTML5&quot;</span>/&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;characterEncoding&quot;</span> <span class="attr">value</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>浏览器发送请求，若请求地址符合前端控制器的url-pattern，该请求就会被前端控制器DispatcherServlet处理。</li>
<li>前端控制器会读取SpringMVC的核心配置文件，通过扫描组件找到控制器，将请求地址和控制器中@RequestMapping注解的value属性值进行匹配，若匹配成功，该注解所标识的控制器方法就是处理请求的方法。处理请求的方法需要返回一个字符串类型的视图名称，该视图名称会被视图解析器解析，加上前缀和后缀组成视图的路径，通过Thymeleaf对视图进行渲染，最终<strong>转发</strong>到视图所对应页面</li>
</ul>
<h1 id="RequestMapping注解"><a href="#RequestMapping注解" class="headerlink" title="@RequestMapping注解"></a>@RequestMapping注解</h1><ul>
<li>@RequestMapping注解的作用：将请求和处理请求的控制器方法关联起来，建立映射关系。SpringMVC 接收到指定的请求，就会找到在映射关系中对应的控制器方法来处理这个请求</li>
</ul>
<h2 id="RequestMapping注解的位置"><a href="#RequestMapping注解的位置" class="headerlink" title="RequestMapping注解的位置"></a>RequestMapping注解的位置</h2><ul>
<li>@RequestMapping标识一个类：设置映射请求的请求路径的初始信息</li>
<li>@RequestMapping标识一个方法：设置映射请求请求路径的具体信息</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/test&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestMappingController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//此时请求映射所映射的请求的请求路径为：/test/testRequestMapping</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/testRequestMapping&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testRequestMapping</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Value属性"><a href="#Value属性" class="headerlink" title="Value属性"></a>Value属性</h2><ul>
<li>@RequestMapping注解的value属性通过请求的请求地址匹配请求映射</li>
<li>@RequestMapping注解的value属性是一个字符串类型的数组，表示该请求映射能够匹配多个请求地址</li>
<li>@RequestMapping注解的value属性<strong>必须设置</strong>，至少通过请求地址匹配请求映射</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(</span></span><br><span class="line"><span class="meta">        value = &#123;&quot;/testRequestMapping&quot;, &quot;/test&quot;&#125;</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testRequestMapping</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>请求地址为testRequestMapping和test时，都会调用testRequestMapping（）方法处理请求</p>
</blockquote>
<h2 id="Method属性"><a href="#Method属性" class="headerlink" title="Method属性"></a>Method属性</h2><ul>
<li><p>@RequestMapping注解的method属性通过请求的请求方式（get或post）匹配请求映射</p>
</li>
<li><p>@RequestMapping注解的method属性是一个RequestMethod类型的数组，表示该请求映射能够匹配多种请求方式的请求</p>
<blockquote>
<p>若当前请求的请求地址满足请求映射的value属性，但是请求方式不满足method属性，则浏览器报错405：Request method ‘POST’ not supported</p>
</blockquote>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/test&#125;&quot;</span>&gt;</span>测试@RequestMapping的value属性--&gt;/test<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">th:action</span>=<span class="string">&quot;@&#123;/test&#125;&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(</span></span><br><span class="line"><span class="meta">        value = &#123;&quot;/testRequestMapping&quot;, &quot;/test&quot;&#125;,</span></span><br><span class="line"><span class="meta">        method = &#123;RequestMethod.GET, RequestMethod.POST&#125;</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testRequestMapping</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注：</p>
<p>1、对于处理指定请求方式的控制器方法，SpringMVC中提供了@RequestMapping的派生注解</p>
<p>处理get请求的映射–&gt;@GetMapping</p>
<p>处理post请求的映射–&gt;@PostMapping</p>
<p>处理put请求的映射–&gt;@PutMapping</p>
<p>处理delete请求的映射–&gt;@DeleteMapping</p>
<p>2、常用的请求方式有get，post，put，delete</p>
<p>但是目前浏览器只支持get和post。若在form表单提交时，为method设置了其他请求方式的字符串（put或delete），则按照默认的请求方式get处理</p>
<p>若要发送put和delete请求，则需要通过spring提供的过滤器HiddenHttpMethodFilter，在RESTful部分会讲到</p>
</blockquote>
<h2 id="Params属性"><a href="#Params属性" class="headerlink" title="Params属性"></a>Params属性</h2><ul>
<li>@RequestMapping注解的params属性通过请求的请求参数匹配请求映射</li>
<li>@RequestMapping注解的params属性是一个字符串类型的数组，可以通过四种表达式设置请求参数和请求映射的匹配关系<ul>
<li>“param”：要求请求映射所匹配的请求必须携带param请求参数</li>
<li>“!param”：要求请求映射所匹配的请求必须不能携带param请求参数</li>
<li>“param=value”：要求请求映射所匹配的请求必须携带param请求参数且param=value</li>
<li>“param!=value”：要求请求映射所匹配的请求必须携带param请求参数但是param!=value</li>
</ul>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/test(username=&#x27;admin&#x27;,password=123456)&quot;</span>&gt;</span>测试@RequestMapping的params属性--&gt;/test<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(</span></span><br><span class="line"><span class="meta">        value = &#123;&quot;/testRequestMapping&quot;, &quot;/test&quot;&#125;,</span></span><br><span class="line"><span class="meta">    	method = &#123;RequestMethod.GET, RequestMethod.POST&#125;,</span></span><br><span class="line"><span class="meta">        params = &#123;&quot;username&quot;,&quot;password!=123456&quot;&#125;</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testRequestMapping</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注：</p>
<p>若当前请求满足@RequestMapping注解的value和method属性，但是不满足params属性，此时页面回报错400</p>
</blockquote>
<h2 id="Headers属性"><a href="#Headers属性" class="headerlink" title="Headers属性"></a>Headers属性</h2><ul>
<li><p>@RequestMapping注解的headers属性通过请求的<strong>请求头信息</strong>匹配请求映射</p>
</li>
<li><p>@RequestMapping注解的headers属性是一个字符串类型的数组，可以通过四种表达式设置请求头信息和请求映射的匹配关系</p>
<ul>
<li>“header”：要求请求映射所匹配的请求必须携带header请求头信息</li>
<li>“!header”：要求请求映射所匹配的请求必须不能携带header请求头信息</li>
<li>“header=value”：要求请求映射所匹配的请求必须携带header请求头信息且header=value</li>
<li>“header!=value”：要求请求映射所匹配的请求必须携带header请求头信息且header!=value</li>
</ul>
</li>
</ul>
<blockquote>
<p>若当前请求满足@RequestMapping注解的value和method属性，但是不满足headers属性，此时页面显示404错误，即资源未找到</p>
</blockquote>
<h2 id="SpringMVC支持ant风格的路径"><a href="#SpringMVC支持ant风格的路径" class="headerlink" title="SpringMVC支持ant风格的路径"></a>SpringMVC支持ant风格的路径</h2><ul>
<li><p>？：表示任意的单个字符</p>
</li>
<li><p>*：表示任意的0个或多个字符</p>
</li>
<li><p>**：表示任意的一层或多层目录</p>
</li>
</ul>
<blockquote>
<p>注意：在使用**时，只能使用/**/xxx的方式</p>
</blockquote>
<h2 id="SpringMVC支持路径中的占位符"><a href="#SpringMVC支持路径中的占位符" class="headerlink" title="SpringMVC支持路径中的占位符"></a>SpringMVC支持路径中的占位符</h2><blockquote>
<p> 原始方式：/deleteUser?id=1</p>
<p>rest方式：/deleteUser/1</p>
</blockquote>
<ul>
<li>SpringMVC路径中的占位符常用于RESTful风格中，当请求路径中将某些数据通过路径的方式传输到服务器中，就可以在相应的@RequestMapping注解的value属性中通过占位符{xxx}表示传输的数据</li>
<li>通过@PathVariable注解，将占位符所表示的数据赋值给控制器方法的形参</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/testRest/1/admin&#125;&quot;</span>&gt;</span>测试路径中的占位符--&gt;/testRest<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testRest/&#123;id&#125;/&#123;username&#125;&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testRest</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> String id, <span class="meta">@PathVariable(&quot;username&quot;)</span> String username)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;id:&quot;</span>+id+<span class="string">&quot;,username:&quot;</span>+username);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//最终输出的内容为--&gt;id:1,username:admin</span></span><br></pre></td></tr></table></figure>



<h1 id="SpringMVC获得请求参数"><a href="#SpringMVC获得请求参数" class="headerlink" title="SpringMVC获得请求参数"></a>SpringMVC获得请求参数</h1><h2 id="通过ServletAPI获取"><a href="#通过ServletAPI获取" class="headerlink" title="通过ServletAPI获取"></a>通过ServletAPI获取</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testParam&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testParam</span><span class="params">(HttpServletRequest request)</span></span>&#123;</span><br><span class="line">    String username = request.getParameter(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">    String password = request.getParameter(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;username:&quot;</span>+username+<span class="string">&quot;,password:&quot;</span>+password);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="通过控制器方法的形参获取请求参数"><a href="#通过控制器方法的形参获取请求参数" class="headerlink" title="通过控制器方法的形参获取请求参数"></a>通过控制器方法的形参获取请求参数</h2><ul>
<li>在控制器方法的形参位置，设置和请求参数同名的形参，当浏览器发送请求，匹配到请求映射时，在DispatcherServlet中就会将请求参数赋值给相应的形参</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/testParam(username=&#x27;admin&#x27;,password=123456)&#125;&quot;</span>&gt;</span>测试获取请求参数--&gt;/testParam<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testParam&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testParam</span><span class="params">(String username, String password)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;username:&quot;</span>+username+<span class="string">&quot;,password:&quot;</span>+password);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注：</p>
<p>若请求所传输的请求参数中有多个同名的请求参数，此时可以在控制器方法的形参中设置字符串数组或者字符串类型的形参接收此请求参数</p>
<p>若使用字符串数组类型的形参，此参数的数组中包含了每一个数据</p>
<p>若使用字符串类型的形参，此参数的值为每个数据中间使用逗号拼接的结果</p>
</blockquote>
<h2 id="RequestParam"><a href="#RequestParam" class="headerlink" title="@RequestParam"></a>@RequestParam</h2><ul>
<li><p>@RequestParam是将请求参数和控制器方法的形参创建映射关系</p>
</li>
<li><p>@RequestParam注解一共有三个属性：</p>
<ul>
<li>value：指定为形参赋值的请求参数的参数名</li>
<li>required：设置是否必须传输此请求参数，默认值为true</li>
<li>defaultValue：不管required属性值为true或false，当value所指定的请求参数没有传输或传输的值为””时，则使用默认值为形参赋值</li>
</ul>
<blockquote>
<p>required设置为true时，则当前请求必须传输value所指定的请求参数，若没有传输该请求参数，且没有设置defaultValue属性，则页面报错400；若设置为false，则当前请求不是必须传输value所指定的请求参数，若没有传输，则注解所标识的形参的值为null</p>
</blockquote>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testParam&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testParam</span><span class="params">(<span class="meta">@RequestParam(&quot;user_name&quot;,required=true,defaultValue=&quot;magic&quot;)</span>String username, </span></span></span><br><span class="line"><span class="params"><span class="function">                        <span class="meta">@RequestParam(&quot;password&quot;)</span>String password)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="RequestHeader"><a href="#RequestHeader" class="headerlink" title="@RequestHeader"></a>@RequestHeader</h2><ul>
<li>@RequestHeader是将请求头信息和控制器方法的形参创建映射关系</li>
<li>@RequestHeader注解一共有三个属性：value、required、defaultValue，用法同@RequestParam</li>
</ul>
<h2 id="CookieValue"><a href="#CookieValue" class="headerlink" title="@CookieValue"></a>@CookieValue</h2><ul>
<li>@CookieValue是将cookie数据和控制器方法的形参创建映射关系</li>
<li>@CookieValue注解一共有三个属性：value、required、defaultValue，用法同@RequestParam</li>
</ul>
<h2 id="通过POJO获取请求参数"><a href="#通过POJO获取请求参数" class="headerlink" title="通过POJO获取请求参数"></a>通过POJO获取请求参数</h2><ul>
<li>可以在控制器方法的形参位置设置一个实体类类型的形参，此时若浏览器传输的请求参数的参数名和实体类中的属性名一致，那么请求参数就会为此属性赋值</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">th:action</span>=<span class="string">&quot;@&#123;/testpojo&#125;&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    用户名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    密码：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    性别：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">value</span>=<span class="string">&quot;男&quot;</span>&gt;</span>男<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">value</span>=<span class="string">&quot;女&quot;</span>&gt;</span>女<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    年龄：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    邮箱：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;email&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testpojo&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testPOJO</span><span class="params">(User user)</span></span>&#123;</span><br><span class="line">    System.out.println(user);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//最终结果--&gt;User&#123;id=null, username=&#x27;张三&#x27;, password=&#x27;123&#x27;, age=23, sex=&#x27;男&#x27;, email=&#x27;123@qq.com&#x27;&#125;</span></span><br></pre></td></tr></table></figure>



<h2 id="解决获取请求参数的乱码问题"><a href="#解决获取请求参数的乱码问题" class="headerlink" title="解决获取请求参数的乱码问题"></a>解决获取请求参数的乱码问题</h2><ul>
<li>使用SpringMVC提供的编码过滤器CharacterEncodingFilter，但是必须在web.xml中进行注册</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置springMVC的编码过滤器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>forceResponseEncoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注：</p>
<p>SpringMVC中处理编码的过滤器一定要配置到其他过滤器之前，否则无效</p>
</blockquote>
<h1 id="域对象共享数据"><a href="#域对象共享数据" class="headerlink" title="域对象共享数据"></a>域对象共享数据</h1><ul>
<li>使用时选择能实现功能的最小范围的域对象</li>
</ul>
<h2 id="request域对象共享数据"><a href="#request域对象共享数据" class="headerlink" title="request域对象共享数据"></a>request域对象共享数据</h2><h3 id="ServletAPI"><a href="#ServletAPI" class="headerlink" title="ServletAPI"></a>ServletAPI</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testServletAPI&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testServletAPI</span><span class="params">(HttpServletRequest request)</span></span>&#123;</span><br><span class="line">    request.setAttribute(<span class="string">&quot;testScope&quot;</span>, <span class="string">&quot;hello,servletAPI&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="ModelAndView"><a href="#ModelAndView" class="headerlink" title="ModelAndView"></a>ModelAndView</h3><ul>
<li>必须返回ModelAndView对象，前端控制器才可以进行解析</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testModelAndView&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">testModelAndView</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ModelAndView有Model和View的功能</span></span><br><span class="line"><span class="comment">     * Model主要用于向请求域共享数据</span></span><br><span class="line"><span class="comment">     * View主要用于设置视图，实现页面跳转</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ModelAndView mav = <span class="keyword">new</span> ModelAndView();</span><br><span class="line">    <span class="comment">//向请求域共享数据</span></span><br><span class="line">    mav.addObject(<span class="string">&quot;testScope&quot;</span>, <span class="string">&quot;hello,ModelAndView&quot;</span>);</span><br><span class="line">    <span class="comment">//设置视图，实现页面跳转</span></span><br><span class="line">    mav.setViewName(<span class="string">&quot;success&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> mav;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Model"><a href="#Model" class="headerlink" title="Model"></a>Model</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testModel&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testModel</span><span class="params">(Model model)</span></span>&#123;</span><br><span class="line">    model.addAttribute(<span class="string">&quot;testScope&quot;</span>, <span class="string">&quot;hello,Model&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testMap&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testMap</span><span class="params">(Map&lt;String, Object&gt; map)</span></span>&#123;</span><br><span class="line">    map.put(<span class="string">&quot;testScope&quot;</span>, <span class="string">&quot;hello,Map&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="ModelMap"><a href="#ModelMap" class="headerlink" title="ModelMap"></a>ModelMap</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testModelMap&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testModelMap</span><span class="params">(ModelMap modelMap)</span></span>&#123;</span><br><span class="line">    modelMap.addAttribute(<span class="string">&quot;testScope&quot;</span>, <span class="string">&quot;hello,ModelMap&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Model、ModelMap、Map的关系"><a href="#Model、ModelMap、Map的关系" class="headerlink" title="Model、ModelMap、Map的关系"></a>Model、ModelMap、Map的关系</h3><ul>
<li>Model、ModelMap、Map类型的参数其实本质上都是 <strong>BindingAwareModelMap</strong> 类型</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Model</span></span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ModelMap</span> <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>&lt;<span class="title">String</span>, <span class="title">Object</span>&gt; </span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExtendedModelMap</span> <span class="keyword">extends</span> <span class="title">ModelMap</span> <span class="keyword">implements</span> <span class="title">Model</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BindingAwareModelMap</span> <span class="keyword">extends</span> <span class="title">ExtendedModelMap</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>这五种向域对象存储数据的方式，都会创建ModelAndView对象，封装数据</p>
</blockquote>
<h2 id="session域共享数据"><a href="#session域共享数据" class="headerlink" title="session域共享数据"></a>session域共享数据</h2><ul>
<li>建议使用原生ServletAPI</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testSession&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testSession</span><span class="params">(HttpSession session)</span></span>&#123;</span><br><span class="line">    session.setAttribute(<span class="string">&quot;testSessionScope&quot;</span>, <span class="string">&quot;hello,session&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="application域共享数据"><a href="#application域共享数据" class="headerlink" title="application域共享数据"></a>application域共享数据</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testApplication&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testApplication</span><span class="params">(HttpSession session)</span></span>&#123;</span><br><span class="line">	ServletContext application = session.getServletContext();</span><br><span class="line">    application.setAttribute(<span class="string">&quot;testApplicationScope&quot;</span>, <span class="string">&quot;hello,application&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="SpringMVC视图"><a href="#SpringMVC视图" class="headerlink" title="SpringMVC视图"></a>SpringMVC视图</h1><ul>
<li>SpringMVC中的视图是View接口，视图的作用渲染数据，将模型Model中的数据展示给用户</li>
<li>SpringMVC视图的种类很多，默认有转发视图和重定向视图<ul>
<li>当工程引入jstl的依赖，转发视图会自动转换为JstlView</li>
<li>若使用的视图技术为Thymeleaf，在SpringMVC的配置文件中配置了Thymeleaf的视图解析器，由此视图解析器解析之后所得到的是ThymeleafView</li>
</ul>
</li>
</ul>
<h2 id="ThymeleafView"><a href="#ThymeleafView" class="headerlink" title="ThymeleafView"></a>ThymeleafView</h2><ul>
<li>当控制器方法中所设置的视图名称没有任何前缀时，此时的视图名称会被SpringMVC配置文件中所配置的视图解析器解析，视图名称拼接视图前缀和视图后缀所得到的最终路径，会通过转发的方式实现跳转</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testHello&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testHello</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="转发视图"><a href="#转发视图" class="headerlink" title="转发视图"></a>转发视图</h2><ul>
<li><p>SpringMVC中默认的转发视图是InternalResourceView</p>
</li>
<li><p>SpringMVC中创建转发视图的情况：当控制器方法中所设置的视图名称以”forward:”为前缀时，创建InternalResourceView视图。此时的视图名称<strong>不会被SpringMVC配置文件中所配置的视图解析器解析</strong>，而是会将前缀”forward:”去掉，剩余部分作为最终路径通过转发的方式实现跳转</p>
<ul>
<li>例如”forward:/“，”forward:/employee”</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testForward&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testForward</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;forward:/testHello&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="重定向视图"><a href="#重定向视图" class="headerlink" title="重定向视图"></a>重定向视图</h2><ul>
<li><p>SpringMVC中默认的重定向视图是RedirectView</p>
</li>
<li><p>当控制器方法中所设置的视图名称以”redirect:”为前缀时，创建RedirectView视图，此时的视图名称<strong>不会被SpringMVC配置文件中所配置的视图解析器解析</strong>，而是会将前缀”redirect:”去掉，剩余部分作为最终路径通过重定向的方式实现跳转</p>
<ul>
<li>例如”redirect:/“，”redirect:/employee”</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testRedirect&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testRedirect</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;redirect:/testHello&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注：</p>
<p>重定向视图在解析时，会先将redirect:前缀去掉，然后会判断剩余部分是否以/开头，若是则会自动拼接上下文路径</p>
</blockquote>
<h2 id="视图控制器view-controller"><a href="#视图控制器view-controller" class="headerlink" title="视图控制器view-controller"></a>视图控制器view-controller</h2><ul>
<li>当控制器方法中，仅仅用来实现页面跳转，即只需要设置视图名称时，可以将处理器方法使用view-controller标签进行表示</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">	path：设置处理的请求地址</span></span><br><span class="line"><span class="comment">	view-name：设置请求地址所对应的视图名称</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:view-controller</span> <span class="attr">path</span>=<span class="string">&quot;/testView&quot;</span> <span class="attr">view-name</span>=<span class="string">&quot;success&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">mvc:view-controller</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--开启MVC注解驱动--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注：</p>
<p>当SpringMVC中设置任何一个view-controller时，其他控制器中的请求映射将全部失效，此时需要在SpringMVC的核心配置文件中设置开启mvc注解驱动的标签：&lt;mvc:annotation-driven /&gt;</p>
</blockquote>
<h1 id="RESTFul"><a href="#RESTFul" class="headerlink" title="RESTFul"></a>RESTFul</h1><ul>
<li>REST：<strong>Re</strong>presentational <strong>S</strong>tate <strong>T</strong>ransfer，表现层资源状态转移</li>
</ul>
<h2 id="RESTful的实现"><a href="#RESTful的实现" class="headerlink" title="RESTful的实现"></a>RESTful的实现</h2><ul>
<li>具体说，就是 HTTP 协议里面，四个表示操作方式的动词：GET、POST、PUT、DELETE<ul>
<li>GET 用来获取资源</li>
<li>POST 用来新建资源</li>
<li>PUT 用来更新资源</li>
<li>DELETE 用来删除资源</li>
</ul>
</li>
<li>REST 风格提倡 URL 地址使用统一的风格设计，从前到后各个单词使用斜杠分开，不使用问号键值对方式携带请求参数，而是将要发送给服务器的数据作为 URL 地址的一部分，以保证整体风格的一致性</li>
</ul>
<table>
<thead>
<tr>
<th>操作</th>
<th>传统方式</th>
<th>REST风格</th>
</tr>
</thead>
<tbody><tr>
<td>查询操作</td>
<td>getUserById?id=1</td>
<td>user/1–&gt;get请求方式</td>
</tr>
<tr>
<td>保存操作</td>
<td>saveUser</td>
<td>user–&gt;post请求方式</td>
</tr>
<tr>
<td>删除操作</td>
<td>deleteUser?id=1</td>
<td>user/1–&gt;delete请求方式</td>
</tr>
<tr>
<td>更新操作</td>
<td>updateUser</td>
<td>user–&gt;put请求方式</td>
</tr>
</tbody></table>
<h2 id="HiddenHttpMethodFilter"><a href="#HiddenHttpMethodFilter" class="headerlink" title="HiddenHttpMethodFilter"></a>HiddenHttpMethodFilter</h2><ul>
<li><p>由于浏览器只支持发送get和post方式的请求,SpringMVC 提供了 <strong>HiddenHttpMethodFilter</strong> 帮助我们<strong>将 POST 请求转换为 DELETE 或 PUT 请求</strong></p>
</li>
<li><p><strong>HiddenHttpMethodFilter</strong> 处理put和delete请求的条件：</p>
<ul>
<li><p>当前请求的请求方式必须为post</p>
</li>
<li><p>当前请求必须传输请求参数_method，可以设置hidden类型的input数据</p>
</li>
<li><p>满足以上条件，<strong>HiddenHttpMethodFilter</strong> 过滤器就会将当前请求的请求方式转换为请求参数_method的值，因此请求参数_method的值才是最终的请求方式</p>
</li>
</ul>
</li>
<li><p>在web.xml中注册<strong>HiddenHttpMethodFilter</strong> </p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>HiddenHttpMethodFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.HiddenHttpMethodFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>HiddenHttpMethodFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="HttpMessageConverter"><a href="#HttpMessageConverter" class="headerlink" title="HttpMessageConverter"></a>HttpMessageConverter</h1><ul>
<li>HttpMessageConverter，报文信息转换器。将请求报文转换为Java对象，或将Java对象转换为响应报文</li>
</ul>
<h2 id="RequestBody"><a href="#RequestBody" class="headerlink" title="@RequestBody"></a>@RequestBody</h2><ul>
<li>@RequestBody可以获取请求体，需要在控制器方法设置一个形参，使用@RequestBody进行标识，当前请求的请求体就会为当前注解所标识的形参赋值</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">th:action</span>=<span class="string">&quot;@&#123;/testRequestBody&#125;&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    用户名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    密码：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testRequestBody&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testRequestBody</span><span class="params">(<span class="meta">@RequestBody</span> String requestBody)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;requestBody:&quot;</span>+requestBody);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="RequestEntity"><a href="#RequestEntity" class="headerlink" title="RequestEntity"></a>RequestEntity</h2><ul>
<li>RequestEntity封装请求报文的一种类型，需要在控制器方法的形参中设置该类型的形参，当前请求的请求报文就会赋值给该形参，可以通过getHeaders()获取请求头信息，通过getBody()获取请求体信息</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testRequestEntity&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testRequestEntity</span><span class="params">(RequestEntity&lt;String&gt; requestEntity)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;requestHeader:&quot;</span>+requestEntity.getHeaders());</span><br><span class="line">    System.out.println(<span class="string">&quot;requestBody:&quot;</span>+requestEntity.getBody());</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="ResponseBody"><a href="#ResponseBody" class="headerlink" title="@ResponseBody"></a>@ResponseBody</h2><ul>
<li>@ResponseBody用于标识一个控制器方法，可以将该方法的返回值直接作为响应报文的响应体响应到浏览器</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testResponseBody&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testResponseBody</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>结果：浏览器页面显示success，而不是跳转到success.html界面</li>
</ul>
<h2 id="SpringMVC处理json"><a href="#SpringMVC处理json" class="headerlink" title="SpringMVC处理json"></a>SpringMVC处理json</h2><ul>
<li><p>@ResponseBody处理json的步骤:</p>
<ul>
<li>导入jackson的依赖</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.12.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>在SpringMVC的核心配置文件中开启mvc的注解驱动，此时在HandlerAdaptor中会自动装配一个消息转换器：MappingJackson2HttpMessageConverter，可以将响应到浏览器的Java对象转换为Json格式的字符串</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>在处理器方法上使用@ResponseBody注解进行标识</li>
<li>将Java对象直接作为控制器方法的返回值返回，就会自动转换为Json格式的字符串</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testResponseUser&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">testResponseUser</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> User(<span class="number">1001</span>,<span class="string">&quot;admin&quot;</span>,<span class="string">&quot;123456&quot;</span>,<span class="number">23</span>,<span class="string">&quot;男&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="SpringMVC处理ajax"><a href="#SpringMVC处理ajax" class="headerlink" title="SpringMVC处理ajax"></a>SpringMVC处理ajax</h2><ul>
<li><p>@ResponseBody处理ajax的步骤:</p>
<ul>
<li><p>请求超链接</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/testAjax&#125;&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;testAjax&quot;</span>&gt;</span>testAjax<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>通过vue和axios处理点击事件</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">th:src</span>=<span class="string">&quot;@&#123;/static/js/vue.js&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">th:src</span>=<span class="string">&quot;@&#123;/static/js/axios.min.js&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> vue = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">        <span class="attr">el</span>:<span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line"><span class="javascript">        <span class="attr">methods</span>:&#123;</span></span><br><span class="line"><span class="javascript">            <span class="attr">testAjax</span>:<span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                axios(&#123;</span></span><br><span class="line"><span class="javascript">                    <span class="attr">method</span>:<span class="string">&quot;post&quot;</span>,</span></span><br><span class="line"><span class="javascript">                    <span class="attr">url</span>:event.target.href,</span></span><br><span class="line"><span class="javascript">                    <span class="attr">params</span>:&#123;</span></span><br><span class="line"><span class="javascript">                        <span class="attr">username</span>:<span class="string">&quot;admin&quot;</span>,</span></span><br><span class="line"><span class="javascript">                        <span class="attr">password</span>:<span class="string">&quot;123456&quot;</span></span></span><br><span class="line"><span class="javascript">                    &#125;</span></span><br><span class="line"><span class="javascript">                &#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                    alert(response.data);</span></span><br><span class="line"><span class="javascript">                &#125;);</span></span><br><span class="line"><span class="javascript">                event.preventDefault();</span></span><br><span class="line"><span class="javascript">            &#125;</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">    &#125;);</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>控制器方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testAjax&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testAjax</span><span class="params">(String username, String password)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;username:&quot;</span>+username+<span class="string">&quot;,password:&quot;</span>+password);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hello,ajax&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="RestController注解"><a href="#RestController注解" class="headerlink" title="@RestController注解"></a>@RestController注解</h2><ul>
<li>@RestController注解是springMVC提供的一个复合注解，标识在控制器的类上，就相当于为类添加了@Controller注解，并且为其中的每个方法添加了@ResponseBody注解</li>
</ul>
<h2 id="ResponseEntity"><a href="#ResponseEntity" class="headerlink" title="ResponseEntity"></a>ResponseEntity</h2><ul>
<li>ResponseEntity用于控制器方法的返回值类型，该控制器方法的返回值就是响应到浏览器的响应报文</li>
</ul>
<h1 id="文件上传和下载"><a href="#文件上传和下载" class="headerlink" title="文件上传和下载"></a>文件上传和下载</h1><h2 id="文件下载"><a href="#文件下载" class="headerlink" title="文件下载"></a>文件下载</h2><ul>
<li>使用ResponseEntity实现下载文件的功能</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testDown&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ResponseEntity&lt;<span class="keyword">byte</span>[]&gt; testResponseEntity(HttpSession session) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">//获取ServletContext对象</span></span><br><span class="line">    ServletContext servletContext = session.getServletContext();</span><br><span class="line">    <span class="comment">//获取服务器中文件的真实路径</span></span><br><span class="line">    String realPath = servletContext.getRealPath(<span class="string">&quot;/static/img/1.jpg&quot;</span>);</span><br><span class="line">    <span class="comment">//创建输入流</span></span><br><span class="line">    InputStream is = <span class="keyword">new</span> FileInputStream(realPath);</span><br><span class="line">    <span class="comment">//创建字节数组</span></span><br><span class="line">    <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[is.available()];</span><br><span class="line">    <span class="comment">//将流读到字节数组中</span></span><br><span class="line">    is.read(bytes);</span><br><span class="line">    <span class="comment">//创建HttpHeaders对象设置响应头信息</span></span><br><span class="line">    MultiValueMap&lt;String, String&gt; headers = <span class="keyword">new</span> HttpHeaders();</span><br><span class="line">    <span class="comment">//设置要下载方式以及下载文件的名字</span></span><br><span class="line">    headers.add(<span class="string">&quot;Content-Disposition&quot;</span>, <span class="string">&quot;attachment;filename=1.jpg&quot;</span>);</span><br><span class="line">    <span class="comment">//设置响应状态码</span></span><br><span class="line">    HttpStatus statusCode = HttpStatus.OK;</span><br><span class="line">    <span class="comment">//创建ResponseEntity对象</span></span><br><span class="line">    ResponseEntity&lt;<span class="keyword">byte</span>[]&gt; responseEntity = <span class="keyword">new</span> ResponseEntity&lt;&gt;(bytes, headers, statusCode);</span><br><span class="line">    <span class="comment">//关闭输入流</span></span><br><span class="line">    is.close();</span><br><span class="line">    <span class="keyword">return</span> responseEntity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h2><ul>
<li><p>文件上传要求form表单的请求方式必须为post，并且添加属性enctype=”multipart/form-data”</p>
</li>
<li><p>springMVC中将上传的文件封装到MultipartFile对象中，通过此对象可以获取文件相关信息</p>
</li>
<li><p>上传步骤:</p>
<ul>
<li><p>添加依赖</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/commons-fileupload/commons-fileupload --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-fileupload<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-fileupload<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>在SpringMVC的配置文件中添加配置</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--必须通过文件解析器的解析才能将文件转换为MultipartFile对象--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;multipartResolver&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>控制器方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testUp&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testUp</span><span class="params">(MultipartFile photo, HttpSession session)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//获取上传的文件的文件名</span></span><br><span class="line">    String fileName = photo.getOriginalFilename();</span><br><span class="line">    <span class="comment">//处理文件重名问题</span></span><br><span class="line">    String hzName = fileName.substring(fileName.lastIndexOf(<span class="string">&quot;.&quot;</span>));</span><br><span class="line">    fileName = UUID.randomUUID().toString() + hzName;</span><br><span class="line">    <span class="comment">//获取服务器中photo目录的路径</span></span><br><span class="line">    ServletContext servletContext = session.getServletContext();</span><br><span class="line">    String photoPath = servletContext.getRealPath(<span class="string">&quot;photo&quot;</span>);</span><br><span class="line">    File file = <span class="keyword">new</span> File(photoPath);</span><br><span class="line">    <span class="keyword">if</span>(!file.exists())&#123;</span><br><span class="line">        file.mkdir();</span><br><span class="line">    &#125;</span><br><span class="line">    String finalPath = photoPath + File.separator + fileName;</span><br><span class="line">    <span class="comment">//实现上传功能</span></span><br><span class="line">    photo.transferTo(<span class="keyword">new</span> File(finalPath));</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h1 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h1><ul>
<li>拦截器作用在servlet和控制器方法之间</li>
</ul>
<blockquote>
<p>过滤器作用在客户端请求和servlet之间</p>
</blockquote>
<h2 id="拦截器配置"><a href="#拦截器配置" class="headerlink" title="拦截器配置"></a>拦截器配置</h2><ul>
<li><p>SpringMVC中的拦截器用于拦截控制器方法的执行，SpringMVC中的拦截器需要实现HandlerInterceptor</p>
</li>
<li><p>SpringMVC的拦截器必须在SpringMVC的配置文件中进行配置</p>
</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.interceptor.FirstInterceptor&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;firstInterceptor&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">ref</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 以上两种配置方式都是对DispatcherServlet所处理的所有的请求进行拦截 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 匹配所有请求 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">&quot;/**&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:exclude-mapping</span> <span class="attr">path</span>=<span class="string">&quot;/testRequestEntity&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;firstInterceptor&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">ref</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">	以上配置方式可以通过ref或bean标签设置拦截器，通过mvc:mapping设置需要拦截的请求，通过mvc:exclude-mapping设置需要排除的请求，即不需要拦截的请求</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="拦截器的三个抽象方法"><a href="#拦截器的三个抽象方法" class="headerlink" title="拦截器的三个抽象方法"></a>拦截器的三个抽象方法</h2><ul>
<li>SpringMVC中的拦截器有三个抽象方法：<ul>
<li>preHandle：控制器方法执行之前执行preHandle()，其boolean类型的返回值表示是否拦截或放行，返回true为放行，即调用控制器方法；返回false表示拦截，即不调用控制器方法</li>
<li>postHandle：控制器方法执行之后执行postHandle()</li>
<li>afterComplation：处理完视图和模型数据，渲染视图完毕之后执行afterComplation()</li>
</ul>
</li>
</ul>
<h2 id="多个拦截器的执行顺序"><a href="#多个拦截器的执行顺序" class="headerlink" title="多个拦截器的执行顺序"></a>多个拦截器的执行顺序</h2><ul>
<li><p>若每个拦截器的preHandle()都返回true，此时多个拦截器的执行顺序和拦截器在SpringMVC的配置文件的配置顺序有关</p>
<ul>
<li>preHandle()会按照配置的顺序执行，而postHandle()和afterComplation()会按照配置的反序执行</li>
</ul>
</li>
<li><p>若某个拦截器的preHandle()返回了false：</p>
<ul>
<li>preHandle()返回false和它之前的拦截器的preHandle()都会执行，postHandle()都不执行，返回false的拦截器之前的拦截器的afterComplation()会执行</li>
</ul>
</li>
</ul>
<h1 id="异常处理器"><a href="#异常处理器" class="headerlink" title="异常处理器"></a>异常处理器</h1><h2 id="基于配置的异常处理"><a href="#基于配置的异常处理" class="headerlink" title="基于配置的异常处理"></a>基于配置的异常处理</h2><ul>
<li>SpringMVC提供了一个处理控制器方法执行过程中所出现的异常的接口：HandlerExceptionResolver</li>
<li>HandlerExceptionResolver接口的实现类有：DefaultHandlerExceptionResolver和SimpleMappingExceptionResolver</li>
<li>SpringMVC提供了自定义的异常处理器SimpleMappingExceptionResolver，使用方式：</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.handler.SimpleMappingExceptionResolver&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;exceptionMappings&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">        	<span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        		properties的键表示处理器方法执行过程中出现的异常</span></span><br><span class="line"><span class="comment">        		properties的值表示若出现指定异常时，设置一个新的视图名称，跳转到指定页面</span></span><br><span class="line"><span class="comment">        	--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;java.lang.ArithmeticException&quot;</span>&gt;</span>error<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    	exceptionAttribute属性设置一个属性名，将出现的异常信息在请求域中进行共享</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;exceptionAttribute&quot;</span> <span class="attr">value</span>=<span class="string">&quot;ex&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="基于注解的异常处理"><a href="#基于注解的异常处理" class="headerlink" title="基于注解的异常处理"></a>基于注解的异常处理</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//@ControllerAdvice将当前类标识为异常处理的组件</span></span><br><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//@ExceptionHandler用于设置所标识方法处理的异常</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(ArithmeticException.class)</span></span><br><span class="line">    <span class="comment">//ex表示当前请求处理中出现的异常对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">handleArithmeticException</span><span class="params">(Exception ex, Model model)</span></span>&#123;</span><br><span class="line">        model.addAttribute(<span class="string">&quot;ex&quot;</span>, ex);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;error&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="注解配置SpringMVC"><a href="#注解配置SpringMVC" class="headerlink" title="注解配置SpringMVC"></a>注解配置SpringMVC</h1><ul>
<li>使用配置类和注解代替web.xml和SpringMVC配置文件的功能</li>
</ul>
<h2 id="初始化配置类，代替web-xml"><a href="#初始化配置类，代替web-xml" class="headerlink" title="初始化配置类，代替web.xml"></a>初始化配置类，代替web.xml</h2><ul>
<li>在Servlet3.0环境中，容器会在类路径中查找实现javax.servlet.ServletContainerInitializer接口的类，如果找到的话就用它来配置Servlet容器</li>
<li>Spring提供了这个接口的实现，名为SpringServletContainerInitializer，这个类反过来又会查找实现WebApplicationInitializer的类并将配置的任务交给它们来完成</li>
<li>Spring3.2引入了一个便利的WebApplicationInitializer基础实现，名为AbstractAnnotationConfigDispatcherServletInitializer，当我们的类扩展了AbstractAnnotationConfigDispatcherServletInitializer并将其部署到Servlet3.0容器的时候，容器会自动发现它，并用它来配置Servlet上下文</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//web工程的配置类，用来代替web.xml</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebInit</span> <span class="keyword">extends</span> <span class="title">AbstractAnnotationConfigDispatcherServletInitializer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指定spring的配置类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt;[] getRootConfigClasses() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Class[]&#123;SpringConfig.class&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指定SpringMVC的配置类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt;[] getServletConfigClasses() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Class[]&#123;WebConfig.class&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指定DispatcherServlet的映射规则，即url-pattern</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> String[] getServletMappings() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String[]&#123;<span class="string">&quot;/&quot;</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加过滤器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Filter[] getServletFilters() &#123;</span><br><span class="line">        CharacterEncodingFilter encodingFilter = <span class="keyword">new</span> CharacterEncodingFilter();</span><br><span class="line">        encodingFilter.setEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        encodingFilter.setForceRequestEncoding(<span class="keyword">true</span>);</span><br><span class="line">        HiddenHttpMethodFilter hiddenHttpMethodFilter = <span class="keyword">new</span> HiddenHttpMethodFilter();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Filter[]&#123;encodingFilter, hiddenHttpMethodFilter&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="创建SpringConfig配置类，代替spring的配置文件"><a href="#创建SpringConfig配置类，代替spring的配置文件" class="headerlink" title="创建SpringConfig配置类，代替spring的配置文件"></a>创建SpringConfig配置类，代替spring的配置文件</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringConfig</span> </span>&#123;</span><br><span class="line">	<span class="comment">//ssm整合之后，spring的配置信息写在此类中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="创建WebConfig配置类，代替SpringMVC的配置文件"><a href="#创建WebConfig配置类，代替SpringMVC的配置文件" class="headerlink" title="创建WebConfig配置类，代替SpringMVC的配置文件"></a>创建WebConfig配置类，代替SpringMVC的配置文件</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="comment">//扫描组件</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.atguigu.mvc.controller&quot;)</span></span><br><span class="line"><span class="comment">//开启MVC注解驱动</span></span><br><span class="line"><span class="meta">@EnableWebMvc</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用默认的servlet处理静态资源</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configureDefaultServletHandling</span><span class="params">(DefaultServletHandlerConfigurer configurer)</span> </span>&#123;</span><br><span class="line">        configurer.enable();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//配置文件上传解析器</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommonsMultipartResolver <span class="title">multipartResolver</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CommonsMultipartResolver();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//配置拦截器</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> </span>&#123;</span><br><span class="line">        FirstInterceptor firstInterceptor = <span class="keyword">new</span> FirstInterceptor();</span><br><span class="line">        registry.addInterceptor(firstInterceptor).addPathPatterns(<span class="string">&quot;/**&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//配置视图控制</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*@Override</span></span><br><span class="line"><span class="comment">    public void addViewControllers(ViewControllerRegistry registry) &#123;</span></span><br><span class="line"><span class="comment">        registry.addViewController(&quot;/&quot;).setViewName(&quot;index&quot;);</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//配置异常映射</span></span><br><span class="line">    <span class="comment">/*@Override</span></span><br><span class="line"><span class="comment">    public void configureHandlerExceptionResolvers(List&lt;HandlerExceptionResolver&gt; resolvers) &#123;</span></span><br><span class="line"><span class="comment">        SimpleMappingExceptionResolver exceptionResolver = new SimpleMappingExceptionResolver();</span></span><br><span class="line"><span class="comment">        Properties prop = new Properties();</span></span><br><span class="line"><span class="comment">        prop.setProperty(&quot;java.lang.ArithmeticException&quot;, &quot;error&quot;);</span></span><br><span class="line"><span class="comment">        //设置异常映射</span></span><br><span class="line"><span class="comment">        exceptionResolver.setExceptionMappings(prop);</span></span><br><span class="line"><span class="comment">        //设置共享异常信息的键</span></span><br><span class="line"><span class="comment">        exceptionResolver.setExceptionAttribute(&quot;ex&quot;);</span></span><br><span class="line"><span class="comment">        resolvers.add(exceptionResolver);</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//配置生成模板解析器</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ITemplateResolver <span class="title">templateResolver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        WebApplicationContext webApplicationContext = ContextLoader.getCurrentWebApplicationContext();</span><br><span class="line">        <span class="comment">// ServletContextTemplateResolver需要一个ServletContext作为构造参数，可通过WebApplicationContext 的方法获得</span></span><br><span class="line">        ServletContextTemplateResolver templateResolver = <span class="keyword">new</span> ServletContextTemplateResolver(</span><br><span class="line">                webApplicationContext.getServletContext());</span><br><span class="line">        templateResolver.setPrefix(<span class="string">&quot;/WEB-INF/templates/&quot;</span>);</span><br><span class="line">        templateResolver.setSuffix(<span class="string">&quot;.html&quot;</span>);</span><br><span class="line">        templateResolver.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        templateResolver.setTemplateMode(TemplateMode.HTML);</span><br><span class="line">        <span class="keyword">return</span> templateResolver;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//生成模板引擎并为模板引擎注入模板解析器</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SpringTemplateEngine <span class="title">templateEngine</span><span class="params">(ITemplateResolver templateResolver)</span> </span>&#123;</span><br><span class="line">        SpringTemplateEngine templateEngine = <span class="keyword">new</span> SpringTemplateEngine();</span><br><span class="line">        templateEngine.setTemplateResolver(templateResolver);</span><br><span class="line">        <span class="keyword">return</span> templateEngine;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//生成视图解析器并未解析器注入模板引擎</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ViewResolver <span class="title">viewResolver</span><span class="params">(SpringTemplateEngine templateEngine)</span> </span>&#123;</span><br><span class="line">        ThymeleafViewResolver viewResolver = <span class="keyword">new</span> ThymeleafViewResolver();</span><br><span class="line">        viewResolver.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        viewResolver.setTemplateEngine(templateEngine);</span><br><span class="line">        <span class="keyword">return</span> viewResolver;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="SpringMVC执行流程"><a href="#SpringMVC执行流程" class="headerlink" title="SpringMVC执行流程"></a>SpringMVC执行流程</h1><h2 id="SpringMVC常用组件"><a href="#SpringMVC常用组件" class="headerlink" title="SpringMVC常用组件"></a>SpringMVC常用组件</h2><ul>
<li><p>DispatcherServlet：<strong>前端控制器</strong>，不需要工程师开发，由框架提供</p>
<ul>
<li>作用：统一处理请求和响应，整个流程控制的中心，由它调用其它组件处理用户的请求</li>
</ul>
</li>
<li><p>HandlerMapping：<strong>处理器映射器</strong>，不需要工程师开发，由框架提供</p>
<ul>
<li>作用：根据请求的url、method等信息查找Handler，即控制器方法</li>
</ul>
</li>
<li><p>Handler：<strong>处理器</strong>，需要工程师开发</p>
<ul>
<li>作用：在DispatcherServlet的控制下Handler对具体的用户请求进行处理</li>
</ul>
</li>
<li><p>HandlerAdapter：<strong>处理器适配器</strong>，不需要工程师开发，由框架提供</p>
<ul>
<li>作用：通过HandlerAdapter对处理器（控制器方法）进行执行</li>
</ul>
</li>
<li><p>ViewResolver：<strong>视图解析器</strong>，不需要工程师开发，由框架提供</p>
<ul>
<li>作用：进行视图解析，得到相应的视图，例如：ThymeleafView、InternalResourceView、RedirectView</li>
</ul>
</li>
<li><p>View：<strong>视图</strong></p>
<ul>
<li>作用：将模型数据通过页面展示给用户</li>
</ul>
</li>
</ul>
<h2 id="DispatcherServlet初始化过程"><a href="#DispatcherServlet初始化过程" class="headerlink" title="DispatcherServlet初始化过程"></a>DispatcherServlet初始化过程</h2><ul>
<li>DispatcherServlet 本质上是一个 Servlet，所以天然的遵循 Servlet 的生命周期。所以宏观上是 Servlet 生命周期来进行调度</li>
</ul>
<h2 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h2><ul>
<li><p>用户向服务器发送请求，请求被SpringMVC 前端控制器 DispatcherServlet捕获。</p>
</li>
<li><p>DispatcherServlet对请求URL进行解析，得到请求资源标识符（URI），判断请求URI对应的映射：</p>
<ul>
<li>不存在：<ul>
<li>再判断是否配置了mvc:default-servlet-handler</li>
<li>如果没配置，则控制台报映射查找不到，客户端展示404错误</li>
<li> 如果有配置，则访问目标资源（一般为静态资源，如：JS,CSS,HTML），找不到客户端也会展示404错误</li>
</ul>
</li>
<li>存在则执行下面的流程</li>
</ul>
</li>
<li><p>根据该URL，调用HandlerMapping获得该Handler配置的所有相关的对象（包括Handler对象以及Handler对象对应的拦截器），最后以HandlerExecutionChain执行链对象的形式返回。</p>
</li>
<li><p>DispatcherServlet 根据获得的Handler，选择一个合适的HandlerAdapter。</p>
</li>
<li><p>如果成功获得HandlerAdapter，此时将开始执行拦截器的preHandler(…)方法【正向】</p>
</li>
<li><p>提取Request中的模型数据，填充Handler入参，开始执行Handler（Controller)方法，处理请求。在填充Handler的入参过程中，根据你的配置，Spring将帮你做一些额外的工作：</p>
<ul>
<li><p>HttpMessageConveter： 将请求消息（如Json、xml等数据）转换成一个对象，将对象转换为指定的响应信息</p>
</li>
<li><p>数据转换：对请求消息进行数据转换。如String转换成Integer、Double等</p>
</li>
<li><p>数据格式化：对请求消息进行数据格式化。 如将字符串转换成格式化数字或格式化日期等</p>
</li>
<li><p> 数据验证： 验证数据的有效性（长度、格式等），验证结果存储到BindingResult或Error中</p>
</li>
</ul>
</li>
<li><p>Handler执行完成后，向DispatcherServlet 返回一个ModelAndView对象</p>
</li>
<li><p>此时将开始执行拦截器的postHandle(…)方法【逆向】</p>
</li>
<li><p>根据返回的ModelAndView（此时会判断是否存在异常：如果存在异常，则执行HandlerExceptionResolver进行异常处理）选择一个适合的ViewResolver进行视图解析，根据Model和View，来渲染视图</p>
</li>
<li><p> 渲染视图完毕执行拦截器的afterCompletion(…)方法【逆向】</p>
</li>
<li><p>将渲染结果返回给客户端。</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/09/27/day23/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Kaixuan Wang">
      <meta itemprop="description" content="只争朝夕">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Magic">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/09/27/day23/" class="post-title-link" itemprop="url">Spring5</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-09-27 10:20:19" itemprop="dateCreated datePublished" datetime="2021-09-27T10:20:19+08:00">2021-09-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-10-08 10:34:47" itemprop="dateModified" datetime="2021-10-08T10:34:47+08:00">2021-10-08</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="框架概述"><a href="#框架概述" class="headerlink" title="框架概述"></a>框架概述</h1><ul>
<li><p>Spring是轻量级的开源的javaEE开发框架</p>
</li>
<li><p>Spring有两个核心部分：</p>
<ul>
<li>IOC：控制反转，把创建对象过程交给Spring进行管理</li>
<li>AOP：面向切面，不修改源代码进行功能增强</li>
</ul>
</li>
<li><p>Spring 特点：</p>
<ul>
<li><p>方便解耦，简化开发</p>
</li>
<li><p>Aop 编程支持</p>
</li>
<li><p>方便程序测试</p>
</li>
<li><p>方便和其他框架进行整合</p>
</li>
<li><p>方便进行事务操作</p>
</li>
<li><p>降低 API 开发难度</p>
</li>
</ul>
</li>
</ul>
<h1 id="IOC容器"><a href="#IOC容器" class="headerlink" title="IOC容器"></a>IOC容器</h1><h2 id="IOC概念"><a href="#IOC概念" class="headerlink" title="IOC概念"></a>IOC概念</h2><ul>
<li>IOC：控制反转，把对象创建和对象之间的调用过程，交给 Spring 进行管理</li>
<li>目的：降低耦合度</li>
</ul>
<h2 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h2><ul>
<li>xml解析，工厂模式和反射</li>
</ul>
<p><img src="/2021/09/27/day23/day23_1.png" alt="工厂模式"></p>
<p><img src="/2021/09/27/day23/day23_2.png" alt="IOC"></p>
<h2 id="IOC-BeanFactory工厂"><a href="#IOC-BeanFactory工厂" class="headerlink" title="IOC(BeanFactory工厂)"></a>IOC(BeanFactory工厂)</h2><ul>
<li><p>IOC 思想基于 IOC 容器完成，IOC 容器底层就是对象工厂</p>
</li>
<li><p>Spring 提供 IOC 容器实现两种方式：（两个接口）</p>
<ul>
<li><p>BeanFactory：IOC 容器基本实现，是 Spring 内部的使用接口，不提供开发人员进行使用</p>
<p> <strong>加载配置文件时候不会创建对象，在获取对象（使用）才去创建对象</strong></p>
</li>
<li><p>ApplicationContext：BeanFactory 接口的子接口，提供更多更强大的功能，一般由开发人</p>
</li>
</ul>
<p>员进行使用</p>
<p>​        <strong>加载配置文件时候就会把在配置文件对象进行创建</strong></p>
</li>
<li><p>ApplicationContext 接口的实现类：FileSystemXmlApplicationContext和ClassPathXmlApplicationContext</p>
</li>
</ul>
<h2 id="IOC操作（Bean管理）"><a href="#IOC操作（Bean管理）" class="headerlink" title="IOC操作（Bean管理）"></a>IOC操作（Bean管理）</h2><ul>
<li>Bean管理：spring创建对象和spring注入属性</li>
<li>两种实现方式：基于xml配置文件方式和基于注解的方式</li>
</ul>
<h3 id="基于xml方式创建对象"><a href="#基于xml方式创建对象" class="headerlink" title="基于xml方式创建对象"></a>基于xml方式创建对象</h3><ul>
<li><p>在 spring 配置文件中，使用 bean 标签，标签里面添加对应属性，就可以实现对象创建</p>
</li>
<li><p>在 bean 标签有很多属性，介绍常用的属性：</p>
<ul>
<li>id 属性：唯一标识</li>
<li>class 属性：类全路径（包类路径）</li>
</ul>
</li>
<li><p>创建对象时候，默认执行无参数构造方法完成对象创建</p>
</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kaixuan.demo.User&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="基于xml方式注入属性"><a href="#基于xml方式注入属性" class="headerlink" title="基于xml方式注入属性"></a>基于xml方式注入属性</h3><ul>
<li><strong>DI</strong>：依赖注入，就是注入属性</li>
</ul>
<blockquote>
<p>使用set方法进行注入</p>
</blockquote>
<ol>
<li>创建类，定义属性和对应的 set 方法</li>
<li>在 spring 配置文件配置对象创建，配置属性注入</li>
</ol>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kaixuan.demo.User&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--使用 property 完成属性注入</span></span><br><span class="line"><span class="comment">        name：类里面属性名称</span></span><br><span class="line"><span class="comment">        value：向属性注入的值</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;userName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;test&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>



<blockquote>
<p>使用有参构造进行注入</p>
</blockquote>
<ol>
<li>创建类，定义属性，创建属性对应有参数构造方法</li>
<li>在 spring 配置文件中进行配置</li>
</ol>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kaixuan.demo.User&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;userName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;test&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>



<blockquote>
<p>p名称空间注入（了解）:本质是使用set方法注入</p>
</blockquote>
<ul>
<li>可以简化基于xml方式注入</li>
</ul>
<ol>
<li>添加 p 名称空间在配置文件中</li>
<li>进行属性注入，在 bean 标签里面进行操作</li>
</ol>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:p</span>=<span class="string">&quot;http://www.springframework.org/schema/p&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--配置User对象创建--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kaixuan.demo.User&quot;</span> <span class="attr">p:userName</span>=<span class="string">&quot;test&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="xml方法注入其他类型属性"><a href="#xml方法注入其他类型属性" class="headerlink" title="xml方法注入其他类型属性"></a>xml方法注入其他类型属性</h3><h4 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h4><ul>
<li><p>null值：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;address&quot;</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">null</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>属性值包含特殊字符</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--属性值包含特殊符号</span></span><br><span class="line"><span class="comment"> 1 把&lt;&gt;进行转义 &amp;lt; &amp;gt;</span></span><br><span class="line"><span class="comment"> 2 把带特殊符号内容写到 CDATA</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;address&quot;</span>&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;<span class="name">value</span>&gt;</span>&lt;![CDATA[&lt;&lt;南京&gt;&gt;]]&gt;<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="注入属性-外部Bean"><a href="#注入属性-外部Bean" class="headerlink" title="注入属性 外部Bean"></a>注入属性 外部Bean</h4><ul>
<li>外部Bean：比如service层的类需要调用dao层的类</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--1 service 和 dao 对象创建--&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kaixuan.service.UserService&quot;</span>&gt;</span></span><br><span class="line">     <span class="comment">&lt;!--注入 userDao 对象</span></span><br><span class="line"><span class="comment">        name 属性：类里面属性名称</span></span><br><span class="line"><span class="comment">        ref 属性：创建 userDao 对象 bean 标签 id 值</span></span><br><span class="line"><span class="comment">     --&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userDaoImpl&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDaoImpl&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kaixuan.dao.UserDaoImpl&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>userService需要有一个UserDao对象属性，并生成get、set方法</li>
</ul>
<h4 id="注入属性-内部Bean和级联赋值"><a href="#注入属性-内部Bean和级联赋值" class="headerlink" title="注入属性 内部Bean和级联赋值"></a>注入属性 内部Bean和级联赋值</h4><ul>
<li>内部Bean</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--内部 bean--&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;emp&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.spring5.bean.Emp&quot;</span>&gt;</span></span><br><span class="line"> 	<span class="comment">&lt;!--设置两个普通属性--&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;ename&quot;</span> <span class="attr">value</span>=<span class="string">&quot;lucy&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;gender&quot;</span> <span class="attr">value</span>=<span class="string">&quot;女&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"> 	<span class="comment">&lt;!--设置对象类型属性--&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dept&quot;</span>&gt;</span></span><br><span class="line"> 		<span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dept&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.spring5.bean.Dept&quot;</span>&gt;</span></span><br><span class="line"> 			<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dname&quot;</span> <span class="attr">value</span>=<span class="string">&quot;安保部&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>级联赋值</p>
<ul>
<li><p>第一种：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--级联赋值--&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;emp&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.spring5.bean.Emp&quot;</span>&gt;</span></span><br><span class="line"> 	<span class="comment">&lt;!--设置两个普通属性--&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;ename&quot;</span> <span class="attr">value</span>=<span class="string">&quot;lucy&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;gender&quot;</span> <span class="attr">value</span>=<span class="string">&quot;女&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"> 	<span class="comment">&lt;!--级联赋值--&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dept&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dept&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span> </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dept&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.spring5.bean.Dept&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dname&quot;</span> <span class="attr">value</span>=<span class="string">&quot;财务部&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>第二种：要有对象的get,set方法</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;emp&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.spring5.bean.Emp&quot;</span>&gt;</span></span><br><span class="line"> 	<span class="comment">&lt;!--设置两个普通属性--&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;ename&quot;</span> <span class="attr">value</span>=<span class="string">&quot;lucy&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;gender&quot;</span> <span class="attr">value</span>=<span class="string">&quot;女&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"> 	<span class="comment">&lt;!--级联赋值--&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dept&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dept&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dept.dname&quot;</span> <span class="attr">value</span>=<span class="string">&quot;技术部&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span> </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dept&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.spring5.bean.Dept&quot;</span>&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dname&quot;</span> <span class="attr">value</span>=<span class="string">&quot;财务部&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h4 id="注入集合属性"><a href="#注入集合属性" class="headerlink" title="注入集合属性"></a>注入集合属性</h4><ul>
<li>集合属性都要生成set方法</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--1 集合类型属性注入--&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;stu&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.spring5.collectiontype.Stu&quot;</span>&gt;</span></span><br><span class="line"> 	<span class="comment">&lt;!--数组类型属性注入--&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;courses&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>java 课程<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>数据库课程<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">&lt;!--list 类型属性注入--&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;list&quot;</span>&gt;</span></span><br><span class="line"> 		<span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">     		<span class="tag">&lt;<span class="name">value</span>&gt;</span>张三<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"> 			<span class="tag">&lt;<span class="name">value</span>&gt;</span>小三<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"> 		<span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"> 	<span class="comment">&lt;!--map 类型属性注入--&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maps&quot;</span>&gt;</span></span><br><span class="line"> 		<span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line"> 			<span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;JAVA&quot;</span> <span class="attr">value</span>=<span class="string">&quot;java&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line"> 			<span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;PHP&quot;</span> <span class="attr">value</span>=<span class="string">&quot;php&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line"> 		<span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"> 	<span class="comment">&lt;!--set 类型属性注入--&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;sets&quot;</span>&gt;</span></span><br><span class="line"> 		<span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line"> 			<span class="tag">&lt;<span class="name">value</span>&gt;</span>MySQL<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"> 			<span class="tag">&lt;<span class="name">value</span>&gt;</span>Redis<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"> 		<span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>



<blockquote>
<p>集合中设置对象属性值</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--创建多个 course 对象--&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;course1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.spring5.collectiontype.Course&quot;</span>&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;cname&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Spring5 框架&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span> </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;course2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.spring5.collectiontype.Course&quot;</span>&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;cname&quot;</span> <span class="attr">value</span>=<span class="string">&quot;MyBatis 框架&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--注入 list 集合类型，值是对象--&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;courseList&quot;</span>&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line"> 		<span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;course1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">ref</span>&gt;</span></span><br><span class="line"> 		<span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;course2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">ref</span>&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>



<blockquote>
<p>抽取集合注入</p>
</blockquote>
<ol>
<li>在 spring 配置文件中引入名称空间 util</li>
<li>使用 util 标签完成 list 集合注入提取</li>
</ol>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:p</span>=<span class="string">&quot;http://www.springframework.org/schema/p&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:util</span>=<span class="string">&quot;http://www.springframework.org/schema/util&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--1 提取 list 集合类型属性注入--&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">util:list</span> <span class="attr">id</span>=<span class="string">&quot;bookList&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>易筋经<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>九阴真经<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>九阳神功<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">util:list</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--2 提取 list 集合类型属性注入使用--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;book&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.spring5.collectiontype.Book&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;list&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;bookList&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="Factory-Bean"><a href="#Factory-Bean" class="headerlink" title="Factory Bean"></a>Factory Bean</h3><ul>
<li><strong>Spring</strong> 有两种类型 bean，一种普通bean，另外一种工厂bean(<strong>FactoryBean</strong>)<ul>
<li>普通Bean：在配置文件中定义bean类型就是返回类型</li>
<li>工厂bean：在配置文件定义bean类型可以和返回类型不同</li>
</ul>
</li>
<li>步骤：<ul>
<li>创建类，让这个类作为工厂 bean，实现接口 FactoryBean</li>
<li>实现接口里面的方法，在实现的方法中定义返回的 bean 类型</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> <span class="keyword">implements</span> <span class="title">FactoryBean</span>&lt;<span class="title">User</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> User(<span class="string">&quot;myBean&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//加载配置文件</span></span><br><span class="line">        ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;bean1.xml&quot;</span>);</span><br><span class="line">        <span class="comment">//获取User对象</span></span><br><span class="line">        User myBean = context.getBean(<span class="string">&quot;myBean&quot;</span>, User.class);</span><br><span class="line">        System.out.println(myBean);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>FactoryBean取出来的对象类型不是原来的类型</li>
</ul>
<h3 id="Bean的作用域"><a href="#Bean的作用域" class="headerlink" title="Bean的作用域"></a>Bean的作用域</h3><ul>
<li>Bean的作用域：设置创建bean实例是单实例还是多实例（默认情况下是单实例）</li>
</ul>
<p><img src="/2021/09/27/day23/day23_3.png" alt="默认单实例"></p>
<ul>
<li>在 spring 配置文件 bean 标签里面有属性（scope）用于设置单实例还是多实例<ul>
<li>singleton，表示是单实例对象</li>
<li>prototype，表示是多实例对象</li>
</ul>
</li>
</ul>
<blockquote>
<p>singleton 和 prototype 区别:</p>
<ol>
<li><p>singleton 单实例，prototype 多实例</p>
</li>
<li><p>设置 scope 值是 singleton 时候，加载 spring 配置文件时候就会创建单实例对象</p>
<p>设置 scope 值是 prototype 时候，不是在加载 spring 配置文件时候创建对象，在调用getBean 方法时候创建多实例对象</p>
</li>
</ol>
</blockquote>
<h3 id="Bean的生命周期"><a href="#Bean的生命周期" class="headerlink" title="Bean的生命周期"></a>Bean的生命周期</h3><ul>
<li>生命周期：从对象创建到对象销毁的过程<ul>
<li>通过构造器创建bean实例（无参构造）</li>
<li>对bean的属性设置值和引用其他对象（调用set方法）</li>
<li>调用bean的初始化方法（需要进行配置）</li>
<li>bean创建完成</li>
<li>容器关闭时，调用bean的销毁方法（需要进行配置，还需要手动调用context.close()方法）</li>
</ul>
</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;！-- 所有配置--&gt;</span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;orders&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.spring5.bean.Orders&quot;</span> <span class="attr">init</span><span class="attr">method</span>=<span class="string">&quot;initMethod&quot;</span> <span class="attr">destroy-method</span>=<span class="string">&quot;destroyMethod&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>



<ul>
<li>bean的后置处理器，生命周期有七步：<ul>
<li>通过构造器创建 bean 实例（无参数构造）</li>
<li>为 bean 的属性设置值和对其他 bean 引用（调用 set 方法）</li>
<li>把 bean 实例传递 bean 后置处理器的方法 postProcessBeforeInitialization </li>
<li>调用 bean 的初始化的方法（需要进行配置初始化的方法）</li>
<li>把 bean实例传递bean后置处理器的方法 postProcessAfterInitialization</li>
<li>bean 可以使用了（对象获取到了）</li>
<li>当容器关闭时候，调用 bean 的销毁的方法（需要进行配置销毁的方法）</li>
</ul>
</li>
<li>后置处理器(<strong>对所有对象都起作用</strong>)创建：<ul>
<li>创建类，实现接口 BeanPostProcessor，创建后置处理器</li>
<li>实现postProcessBeforeInitialization 和postProcessAfterInitialization</li>
</ul>
</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置后置处理器--&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;myBeanPost&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.spring5.bean.MyBeanPost&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="xml的自动装配"><a href="#xml的自动装配" class="headerlink" title="xml的自动装配"></a>xml的自动装配</h3><ul>
<li>自动装配：根据指定装配规则（属性名称或者属性类型），Spring 自动将匹配的属性值进行注入</li>
<li>一般有两种规则：根据名称自动注入和根据属性类型自动注入</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">（1）根据属性名称自动注入</span><br><span class="line"><span class="comment">&lt;!--实现自动装配</span></span><br><span class="line"><span class="comment"> 	bean 标签属性 autowire，配置自动装配</span></span><br><span class="line"><span class="comment"> 	autowire 属性常用两个值：</span></span><br><span class="line"><span class="comment"> 		byName 根据属性名称注入 ，注入值 bean 的 id 值和类属性名称一样</span></span><br><span class="line"><span class="comment"> 		byType 根据属性类型注入</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;emp&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.spring5.autowire.Emp&quot;</span> <span class="attr">autowire</span>=<span class="string">&quot;byName&quot;</span>&gt;</span></span><br><span class="line"> 	<span class="comment">&lt;!--&lt;property name=&quot;dept&quot; ref=&quot;dept&quot;&gt;&lt;/property&gt;--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dept&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.spring5.autowire.Dept&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">（2）根据属性类型自动注入</span><br><span class="line"><span class="comment">&lt;!--实现自动装配</span></span><br><span class="line"><span class="comment"> 	bean 标签属性 autowire，配置自动装配</span></span><br><span class="line"><span class="comment"> 	autowire 属性常用两个值：</span></span><br><span class="line"><span class="comment"> 		byName 根据属性名称注入 ，注入值 bean 的 id 值和类属性名称一样</span></span><br><span class="line"><span class="comment"> 		byType 根据属性类型注入</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;emp&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.spring5.autowire.Emp&quot;</span> <span class="attr">autowire</span>=<span class="string">&quot;byType&quot;</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!--&lt;property name=&quot;dept&quot; ref=&quot;dept&quot;&gt;&lt;/property&gt;--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dept&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.spring5.autowire.Dept&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="基于注解方式创建对象"><a href="#基于注解方式创建对象" class="headerlink" title="基于注解方式创建对象"></a>基于注解方式创建对象</h3><ul>
<li>注解：<ul>
<li>注解是代码特殊标记，格式：@注解名称(属性名称=属性值, 属性名称=属性值..)</li>
<li>使用注解，注解作用在类上面，方法上面，属性上面</li>
<li>使用注解目的：简化 xml 配置</li>
</ul>
</li>
<li>Spring 针对Bean管理中创建对象提供注解<ul>
<li>@Component</li>
<li>@Service</li>
<li>@Controller</li>
<li>@Repository</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component(value = &quot;user&quot;)</span> <span class="comment">// 相当于id值</span></span><br></pre></td></tr></table></figure>



<h3 id="开启组件扫描"><a href="#开启组件扫描" class="headerlink" title="开启组件扫描"></a>开启组件扫描</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:p</span>=<span class="string">&quot;http://www.springframework.org/schema/p&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:util</span>=<span class="string">&quot;http://www.springframework.org/schema/util&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">                           http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--开启组件扫描</span></span><br><span class="line"><span class="comment">        1 如果扫描多个包，多个包使用逗号隔开</span></span><br><span class="line"><span class="comment">        2 扫描包上层目录</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.kaixuan&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>组件扫描细节：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--示例 1</span></span><br><span class="line"><span class="comment"> use-default-filters=&quot;false&quot; 表示现在不使用默认 filter，自己配置 filter</span></span><br><span class="line"><span class="comment"> context:include-filter ，设置扫描哪些内容</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.atguigu&quot;</span> <span class="attr">use-default-filters</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">context:include-filter</span> <span class="attr">type</span>=<span class="string">&quot;annotation&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;org.springframework.stereotype.Controller&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--示例 2</span></span><br><span class="line"><span class="comment"> 下面配置扫描包所有内容</span></span><br><span class="line"><span class="comment"> context:exclude-filter： 设置哪些内容不进行扫描</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.atguigu&quot;</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">context:exclude-filter</span> <span class="attr">type</span>=<span class="string">&quot;annotation&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;org.springframework.stereotype.Controller&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="基于注解方式进行属性注入"><a href="#基于注解方式进行属性注入" class="headerlink" title="基于注解方式进行属性注入"></a>基于注解方式进行属性注入</h3><ul>
<li><p>@Autowired：根据属性类型进行自动装配</p>
<ul>
<li>创建service 和 dao 对象，在 service 和 dao 类添加创建对象注解</li>
<li>service 注入 dao 对象，在 service 类添加 dao 类型属性，在属性上面使用注解</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">     <span class="comment">//定义 dao 类型属性</span></span><br><span class="line">     <span class="comment">//不需要添加 set 方法</span></span><br><span class="line">     <span class="comment">//添加注入属性注解</span></span><br><span class="line">     <span class="meta">@Autowired</span> </span><br><span class="line">     <span class="keyword">private</span> UserDao userDao;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         System.out.println(<span class="string">&quot;service add.......&quot;</span>);</span><br><span class="line">         userDao.add();</span><br><span class="line">     &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>@Qualifier：根据名称进行注入</p>
<ul>
<li>和@Autowired 一起使用</li>
<li>一个接口可能有多个实现类，这种情况无法通过属性注入</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">     <span class="comment">//定义 dao 类型属性</span></span><br><span class="line">     <span class="comment">//不需要添加 set 方法</span></span><br><span class="line">     <span class="comment">//添加注入属性注解</span></span><br><span class="line">     <span class="meta">@Autowired</span> </span><br><span class="line">     <span class="meta">@Qualifier(value=&quot;userDaoImpl1&quot;)</span></span><br><span class="line">     <span class="keyword">private</span> UserDao userDao;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         System.out.println(<span class="string">&quot;service add.......&quot;</span>);</span><br><span class="line">         userDao.add();</span><br><span class="line">     &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>@Resource：可以根据类型注入，可以根据名称注入</p>
<ul>
<li>不是spring提供的，是javax提供的，不建议使用</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">     <span class="comment">//定义 dao 类型属性</span></span><br><span class="line">     <span class="comment">//不需要添加 set 方法</span></span><br><span class="line">     <span class="comment">//添加注入属性注解</span></span><br><span class="line">    </span><br><span class="line">     <span class="comment">//@Resource //根据类型进行注入</span></span><br><span class="line">	 <span class="meta">@Resource(name = &quot;userDaoImpl1&quot;)</span> <span class="comment">//根据名称进行注入</span></span><br><span class="line">     <span class="keyword">private</span> UserDao userDao;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         System.out.println(<span class="string">&quot;service add.......&quot;</span>);</span><br><span class="line">         userDao.add();</span><br><span class="line">     &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>@Value：注入普通类型属性</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Value(value = &quot;abc&quot;)</span></span><br><span class="line"><span class="comment">//不需要添加 set 方法</span></span><br><span class="line"><span class="keyword">private</span> String name;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="完全注解开发"><a href="#完全注解开发" class="headerlink" title="完全注解开发"></a>完全注解开发</h3><ul>
<li>创建配置类，替代 xml 配置文件</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span> <span class="comment">//作为配置类，替代 xml 配置文件</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &#123;&quot;com.atguigu&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringConfig</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>测试类有变化</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testService2</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> 	 <span class="comment">//加载配置类</span></span><br><span class="line">     ApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext(SpringConfig.class);</span><br><span class="line">     UserService userService = context.getBean(<span class="string">&quot;userService&quot;</span>, UserService.class);</span><br><span class="line">     System.out.println(userService);</span><br><span class="line">     userService.add();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h1><h2 id="AOP基本概念"><a href="#AOP基本概念" class="headerlink" title="AOP基本概念"></a>AOP基本概念</h2><ul>
<li>AOP：面向切面编程</li>
<li>作用：可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。即不通过修改源代码的形式，增强功能</li>
</ul>
<h2 id="AOP底层原理"><a href="#AOP底层原理" class="headerlink" title="AOP底层原理"></a>AOP底层原理</h2><ul>
<li><p>动态代理增强功能</p>
</li>
<li><p>两种情况的动态代理：</p>
<ul>
<li><p>有接口情况，使用JDK动态代理</p>
<ul>
<li>创建接口实现类代理对象，增强类的方法</li>
</ul>
<p><img src="/2021/09/27/day23/day23_4.png" alt="接口动态代理"></p>
</li>
<li><p>没有接口情况，使用CGLIB动态代理</p>
<ul>
<li>创建子类的代理对象，增强类的方法</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="/2021/09/27/day23/day23_5.png" alt="动态代理"></p>
<h2 id="jdk动态代理"><a href="#jdk动态代理" class="headerlink" title="jdk动态代理"></a>jdk动态代理</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>;</span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> String <span class="title">update</span><span class="params">(String id)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">     	<span class="keyword">return</span> a+b;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> String <span class="title">update</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">     	<span class="keyword">return</span> id;</span><br><span class="line"> 	 &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建代理对象</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserDaoProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"> 	<span class="comment">//1 把创建的是谁的代理对象，把谁传递过来</span></span><br><span class="line"> 	<span class="comment">//有参数构造传递</span></span><br><span class="line"> 	<span class="keyword">private</span> Object obj;</span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> <span class="title">UserDaoProxy</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line"> 		<span class="keyword">this</span>.obj = obj;</span><br><span class="line"> 	&#125;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">//增强的逻辑</span></span><br><span class="line"> 	<span class="meta">@Override</span></span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">//方法之前</span></span><br><span class="line">        System.out.println(<span class="string">&quot;方法之前执行....&quot;</span>+method.getName()+<span class="string">&quot; :传递的参数...&quot;</span>+ Arrays.toString(args));</span><br><span class="line">        <span class="comment">//被增强的方法执行</span></span><br><span class="line">        Object res = method.invoke(obj, args);</span><br><span class="line">        <span class="comment">//方法之后</span></span><br><span class="line">        System.out.println(<span class="string">&quot;方法之后执行....&quot;</span>+obj);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"> 	&#125; </span><br><span class="line">&#125;</span><br><span class="line">                    </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDKProxy</span> </span>&#123;</span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> 		<span class="comment">//创建接口实现类代理对象</span></span><br><span class="line"> 		Class[] interfaces = &#123;UserDao.class&#125;;</span><br><span class="line">           </span><br><span class="line"> 		UserDaoImpl userDao = <span class="keyword">new</span> UserDaoImpl();</span><br><span class="line"> 		UserDao dao = (UserDao)Proxy.newProxyInstance(JDKProxy.class.getClassLoader(), interfaces, </span><br><span class="line">														<span class="keyword">new</span> UserDaoProxy(userDao));</span><br><span class="line">     	<span class="keyword">int</span> result = dao.add(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"> 		System.out.println(<span class="string">&quot;result:&quot;</span>+result);</span><br><span class="line"> 	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><ul>
<li>连接点：可以被增强的方法称为连接点</li>
<li>切入点：实际被增强的方法称为切入点</li>
<li>通知（增强）：实际增强的逻辑称为通知<ul>
<li>前置通知：在原方法之前执行</li>
<li>后置通知：在原方法之后执行</li>
<li>环绕通知：在原方法前后都执行</li>
<li>异常通知：原方法出现异常才执行</li>
<li>最终通知：任何情况下都会执行，类似finally</li>
</ul>
</li>
<li>切面：把通知应用到切入点的过程</li>
</ul>
<h2 id="AspectJ实现AOP"><a href="#AspectJ实现AOP" class="headerlink" title="AspectJ实现AOP"></a>AspectJ实现AOP</h2><ul>
<li><p>AspectJ 不是 Spring 组成部分，独立 AOP 框架，一般把 AspectJ 和 Spirng 框架一起使用，进行 AOP 操作</p>
</li>
<li><p>AspectJ可以通过xml和注解方式（常用）实现AOP</p>
</li>
<li><p>切入点表达式：</p>
<ul>
<li>作用：知道对哪个类里面的哪个方法进行增强</li>
<li>语法结构： execution([权限修饰符] [返回类型] [类全路径] [方法名称] ([参数列表]) )</li>
</ul>
<blockquote>
<p>举例 1：对 com.atguigu.dao.BookDao 类里面的 add 进行增强</p>
<p>​              execution(* com.atguigu.dao.BookDao.add(..))</p>
<p>举例 2：对 com.atguigu.dao.BookDao 类里面的所有的方法进行增强</p>
<p>​              execution(* com.atguigu.dao.BookDao.* (..))</p>
<p>举例 3：对 com.atguigu.dao 包里面所有类，类里面所有方法进行增强</p>
<p>​             execution(* com.atguigu.dao. * . * (..))</p>
</blockquote>
</li>
</ul>
<h2 id="AspectJ注解"><a href="#AspectJ注解" class="headerlink" title="AspectJ注解"></a>AspectJ注解</h2><ul>
<li><p>创建类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> 		System.out.println(<span class="string">&quot;add.......&quot;</span>);</span><br><span class="line"> 	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>创建增强类（增强逻辑）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserProxy</span> </span>&#123;</span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//前置通知</span></span><br><span class="line"> 		System.out.println(<span class="string">&quot;before......&quot;</span>);</span><br><span class="line"> 	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>通知配置</p>
<ul>
<li>开启注解扫描（配置类或者配置文件）</li>
<li>使用注解创建类和增强类</li>
<li>在增强类上面添加注解 @Aspect</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span> <span class="comment">//生成代理对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserProxy</span> </span>&#123;</span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//前置通知</span></span><br><span class="line"> 		System.out.println(<span class="string">&quot;before......&quot;</span>);</span><br><span class="line"> 	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在spring配置文件中开启生成代理对象</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 开启 Aspect 生成代理对象--&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:aspectj-autoproxy</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>配置不同类型的通知</p>
<ul>
<li><p>在增强类的里面，在作为通知方法上面添加通知类型注解，使用切入点表达式配置</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//增强的类</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span> <span class="comment">//生成代理对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserProxy</span> </span>&#123;</span><br><span class="line">     <span class="comment">//前置通知</span></span><br><span class="line">     <span class="comment">//@Before 注解表示作为前置通知</span></span><br><span class="line">     <span class="meta">@Before(value = &quot;execution(* com.atguigu.spring5.aopanno.User.add(..))&quot;)</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     	System.out.println(<span class="string">&quot;before.........&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="comment">//后置通知（返回通知）</span></span><br><span class="line">     <span class="meta">@AfterReturning(value = &quot;execution(* com.atguigu.spring5.aopanno.User.add(..))&quot;)</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterReturning</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     	System.out.println(<span class="string">&quot;afterReturning.........&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="comment">//最终通知</span></span><br><span class="line">     <span class="meta">@After(value = &quot;execution(* com.atguigu.spring5.aopanno.User.add(..))&quot;)</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     	System.out.println(<span class="string">&quot;after.........&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="comment">//异常通知</span></span><br><span class="line">     <span class="meta">@AfterThrowing(value = &quot;execution(* com.atguigu.spring5.aopanno.User.add(..))&quot;)</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterThrowing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     	System.out.println(<span class="string">&quot;afterThrowing.........&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="comment">//环绕通知</span></span><br><span class="line">     <span class="meta">@Around(value = &quot;execution(* com.atguigu.spring5.aopanno.User.add(..))&quot;)</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">around</span><span class="params">(ProceedingJoinPoint proceedingJoinPoint)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">         System.out.println(<span class="string">&quot;环绕之前.........&quot;</span>);</span><br><span class="line">         </span><br><span class="line">         <span class="comment">//被增强的方法执行</span></span><br><span class="line">         proceedingJoinPoint.proceed();</span><br><span class="line">         </span><br><span class="line">         System.out.println(<span class="string">&quot;环绕之后.........&quot;</span>);</span><br><span class="line">     &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>相同切入点的提取</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//相同切入点抽取</span></span><br><span class="line"><span class="meta">@Pointcut(value = &quot;execution(* com.atguigu.spring5.aopanno.User.add(..))&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pointdemo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">   <span class="comment">//前置通知</span></span><br><span class="line">   <span class="comment">//@Before 注解表示作为前置通知</span></span><br><span class="line">   <span class="meta">@Before(value = &quot;pointdemo()&quot;)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    	System.out.println(<span class="string">&quot;before.........&quot;</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>有多个增强类多同一个方法进行增强，设置增强类优先级</p>
<ul>
<li>在增强类上面添加注解 @Order(数字类型值)，数字类型值越小优先级越高</li>
</ul>
</li>
<li><p>完全使用注解开发：使用配置类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &#123;&quot;com.atguigu&quot;&#125;)</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy(proxyTargetClass = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigAop</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="AspectJ配置文件"><a href="#AspectJ配置文件" class="headerlink" title="AspectJ配置文件"></a>AspectJ配置文件</h2><ul>
<li>创建两个类，增强类和被增强类，创建方法</li>
<li>在spring配置文件中创建两个类对象</li>
<li>在spring配置文件中配置切入点</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置 aop 增强--&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line"> 	<span class="comment">&lt;!--切入点--&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;p&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(*com.atguigu.spring5.aopxml.Book.buy(..))&quot;</span>/&gt;</span></span><br><span class="line"> 	<span class="comment">&lt;!--配置切面--&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">&quot;bookProxy&quot;</span>&gt;</span></span><br><span class="line"> 		<span class="comment">&lt;!--增强作用在具体的方法上--&gt;</span></span><br><span class="line"> 		<span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">&quot;before&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;p&quot;</span>/&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h1 id="JdbcTemplate"><a href="#JdbcTemplate" class="headerlink" title="JdbcTemplate"></a>JdbcTemplate</h1><ul>
<li>Spring 框架对 JDBC 进行封装，使用 JdbcTemplate 方便实现对数据库操作</li>
</ul>
<h2 id="配置数据库连接"><a href="#配置数据库连接" class="headerlink" title="配置数据库连接"></a>配置数据库连接</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:p</span>=<span class="string">&quot;http://www.springframework.org/schema/p&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:util</span>=<span class="string">&quot;http://www.springframework.org/schema/util&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">                           http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath:jdbc.properties&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:property-placeholder</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 数据库连接池 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span> <span class="attr">destroy-method</span>=<span class="string">&quot;close&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>= <span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.username&#125;&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.driverClassName&#125;&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- JdbcTemplate 对象 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;jdbcTemplate&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.core.JdbcTemplate&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--注入 dataSource--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 组件扫描 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.kaixuan&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookServiceImpl</span> <span class="keyword">implements</span> <span class="title">BookService</span> </span>&#123;</span><br><span class="line">    <span class="comment">//注入BookDao</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BookDao bookDao;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title">BookDao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注入JdbcTemplate</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JdbcTemplate jdbcTemplate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="JdbcTemplate操作数据库"><a href="#JdbcTemplate操作数据库" class="headerlink" title="JdbcTemplate操作数据库"></a>JdbcTemplate操作数据库</h2><ul>
<li>update()方法完成添加、修改、删除<ul>
<li>第一个参数：sql 语句</li>
<li>第二个参数：可变参数，设置 sql 语句值</li>
<li>返回值：成功则返回受影响行数，失败返回-1</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//添加</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Book book)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//1 创建 sql 语句</span></span><br><span class="line">		String sql = <span class="string">&quot;insert into t_book values(?,?,?)&quot;</span>;</span><br><span class="line">		<span class="comment">//2 调用方法实现</span></span><br><span class="line">		Object[] args = &#123;book.getUserId(), book.getUsername(), book.getUstatus()&#125;;</span><br><span class="line">		<span class="keyword">int</span> update = jdbcTemplate.update(sql,args);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//修改</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateBook</span><span class="params">(Book book)</span> </span>&#123;</span><br><span class="line">    	String sql = <span class="string">&quot;update t_book set username=?,ustatus=? where user_id=?&quot;</span>;</span><br><span class="line">    	Object[] args = &#123;book.getUsername(), book.getUstatus(),book.getUserId()&#125;;</span><br><span class="line">    	<span class="keyword">int</span> update = jdbcTemplate.update(sql, args);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">    	String sql = <span class="string">&quot;delete from t_book where user_id=?&quot;</span>;</span><br><span class="line">    	<span class="keyword">int</span> update = jdbcTemplate.update(sql, id);</span><br><span class="line">    	System.out.println(update);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>queryForObject()查询返回某个值：查询表里面有多少条记录，返回是某个值</p>
<ul>
<li><p>第一个参数：sql 语句</p>
</li>
<li><p>第二个参数：返回类型 Class</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查询表记录数</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">selectCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> 	String sql = <span class="string">&quot;select count(*) from t_book&quot;</span>;</span><br><span class="line"> 	Integer count = jdbcTemplate.queryForObject(sql, Integer.class);</span><br><span class="line"> 	<span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>queryForObject()查询返回对象：<ul>
<li>第一个参数：sql 语句</li>
<li>第二个参数：RowMapper 是接口，针对返回不同类型数据，使用这个接口里面实现类完成数据封装</li>
<li>第三个参数：sql 语句值</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查询返回对象</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Book <span class="title">findBookInfo</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line"> 	String sql = <span class="string">&quot;select * from t_book where user_id=?&quot;</span>;</span><br><span class="line"> 	<span class="comment">//调用方法</span></span><br><span class="line"> 	Book book = jdbcTemplate.queryForObject(sql, <span class="keyword">new</span> BeanPropertyRowMapper&lt;Book&gt;(Book.class), id);</span><br><span class="line"> 	<span class="keyword">return</span> book;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>query()查询返回集合:<ul>
<li>第一个参数：sql 语句</li>
<li> 第二个参数：RowMapper 是接口，针对返回不同类型数据，使用这个接口里面实现类完成数据封装</li>
<li> 第三个参数：sql 语句值</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查询返回集合</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Book&gt; <span class="title">findAllBook</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> 	String sql = <span class="string">&quot;select * from t_book&quot;</span>;</span><br><span class="line"> 	<span class="comment">//调用方法</span></span><br><span class="line"> 	List&lt;Book&gt; bookList = jdbcTemplate.query(sql, <span class="keyword">new</span> BeanPropertyRowMapper&lt;Book&gt;(Book.class));</span><br><span class="line"> 	<span class="keyword">return</span> bookList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>batchUpdate()进行批量操作：<ul>
<li>第一个参数：sql 语句</li>
<li>第二个参数：List 集合，添加多条记录数据</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//批量添加</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">batchAddBook</span><span class="params">(List&lt;Object[]&gt; batchArgs)</span> </span>&#123;</span><br><span class="line"> 	String sql = <span class="string">&quot;insert into t_book values(?,?,?)&quot;</span>;</span><br><span class="line"> 	<span class="keyword">int</span>[] ints = jdbcTemplate.batchUpdate(sql, batchArgs);</span><br><span class="line"> 	System.out.println(Arrays.toString(ints));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//批量添加测试</span></span><br><span class="line">List&lt;Object[]&gt; batchArgs = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">Object[] o1 = &#123;<span class="string">&quot;3&quot;</span>,<span class="string">&quot;java&quot;</span>,<span class="string">&quot;a&quot;</span>&#125;;</span><br><span class="line">Object[] o2 = &#123;<span class="string">&quot;4&quot;</span>,<span class="string">&quot;c++&quot;</span>,<span class="string">&quot;b&quot;</span>&#125;;</span><br><span class="line">Object[] o3 = &#123;<span class="string">&quot;5&quot;</span>,<span class="string">&quot;MySQL&quot;</span>,<span class="string">&quot;c&quot;</span>&#125;;</span><br><span class="line">batchArgs.add(o1);</span><br><span class="line">batchArgs.add(o2);</span><br><span class="line">batchArgs.add(o3);</span><br><span class="line"><span class="comment">//调用批量添加</span></span><br><span class="line">bookService.batchAdd(batchArgs);</span><br><span class="line"></span><br><span class="line"><span class="comment">//批量修改</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">batchUpdateBook</span><span class="params">(List&lt;Object[]&gt; batchArgs)</span> </span>&#123;</span><br><span class="line"> 	String sql = <span class="string">&quot;update t_book set username=?,ustatus=? where user_id=?&quot;</span>;</span><br><span class="line"> 	<span class="keyword">int</span>[] ints = jdbcTemplate.batchUpdate(sql, batchArgs);</span><br><span class="line"> 	System.out.println(Arrays.toString(ints));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//批量修改</span></span><br><span class="line">List&lt;Object[]&gt; batchArgs = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">Object[] o1 = &#123;<span class="string">&quot;java0909&quot;</span>,<span class="string">&quot;a3&quot;</span>,<span class="string">&quot;3&quot;</span>&#125;;</span><br><span class="line">Object[] o2 = &#123;<span class="string">&quot;c++1010&quot;</span>,<span class="string">&quot;b4&quot;</span>,<span class="string">&quot;4&quot;</span>&#125;;</span><br><span class="line">Object[] o3 = &#123;<span class="string">&quot;MySQL1111&quot;</span>,<span class="string">&quot;c5&quot;</span>,<span class="string">&quot;5&quot;</span>&#125;;</span><br><span class="line">batchArgs.add(o1);</span><br><span class="line">batchArgs.add(o2);</span><br><span class="line">batchArgs.add(o3);</span><br><span class="line"><span class="comment">//调用方法实现批量修改</span></span><br><span class="line">bookService.batchUpdate(batchArgs);</span><br><span class="line"></span><br><span class="line"><span class="comment">//批量删除</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">batchDeleteBook</span><span class="params">(List&lt;Object[]&gt; batchArgs)</span> </span>&#123;</span><br><span class="line"> 	String sql = <span class="string">&quot;delete from t_book where user_id=?&quot;</span>;</span><br><span class="line"> 	<span class="keyword">int</span>[] ints = jdbcTemplate.batchUpdate(sql, batchArgs);</span><br><span class="line"> 	System.out.println(Arrays.toString(ints));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//批量删除</span></span><br><span class="line">List&lt;Object[]&gt; batchArgs = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">Object[] o1 = &#123;<span class="string">&quot;3&quot;</span>&#125;;</span><br><span class="line">Object[] o2 = &#123;<span class="string">&quot;4&quot;</span>&#125;;</span><br><span class="line">batchArgs.add(o1);</span><br><span class="line">batchArgs.add(o2);</span><br><span class="line"><span class="comment">//调用方法实现批量删除</span></span><br><span class="line">bookService.batchDelete(batchArgs);</span><br></pre></td></tr></table></figure>



<h1 id="事务操作"><a href="#事务操作" class="headerlink" title="事务操作"></a>事务操作</h1><h2 id="Spring事务管理介绍"><a href="#Spring事务管理介绍" class="headerlink" title="Spring事务管理介绍"></a>Spring事务管理介绍</h2><ul>
<li>事务添加到JavaEE三层结构里面Service层（业务逻辑层）</li>
<li>有两种方式：编程式事务管理和声明式事务管理（使用）<ul>
<li>声明式事务管理：基于注解方式（使用）和基于 xml 配置文件方式</li>
</ul>
</li>
<li>声明式事务管理，底层使用<strong>AOP</strong> 原理</li>
<li>Spring事务管理API：提供一个接口，代表事务管理器，这个接口针对不同的框架提供不同的实现类</li>
</ul>
<h2 id="注解声明式事务管理"><a href="#注解声明式事务管理" class="headerlink" title="注解声明式事务管理"></a>注解声明式事务管理</h2><ul>
<li>在spring配置文件配置事务管理器</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--创建事务管理器</span></span><br><span class="line"><span class="comment">	不同操作数据库的接口对应不同的而实现类</span></span><br><span class="line"><span class="comment">--&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transactionManager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line"> 	<span class="comment">&lt;!--注入数据源--&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>在spring 配置文件，开启事务注解</p>
<ul>
<li>在 spring 配置文件引入名称空间 tx</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span> </span></span><br><span class="line"><span class="tag"> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> </span></span><br><span class="line"><span class="tag"> <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span> </span></span><br><span class="line"><span class="tag"> <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span> </span></span><br><span class="line"><span class="tag"> <span class="attr">xmlns:tx</span>=<span class="string">&quot;http://www.springframework.org/schema/tx&quot;</span> </span></span><br><span class="line"><span class="tag"> <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans </span></span></span><br><span class="line"><span class="string"><span class="tag">					 http://www.springframework.org/schema/beans/spring-beans.xsd </span></span></span><br><span class="line"><span class="string"><span class="tag"> 					 http://www.springframework.org/schema/context </span></span></span><br><span class="line"><span class="string"><span class="tag">					 http://www.springframework.org/schema/context/spring-context.xsd </span></span></span><br><span class="line"><span class="string"><span class="tag"> 					 http://www.springframework.org/schema/aop </span></span></span><br><span class="line"><span class="string"><span class="tag">					 http://www.springframework.org/schema/aop/spring-aop.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">                     http://www.springframework.org/schema/tx </span></span></span><br><span class="line"><span class="string"><span class="tag">					 http://www.springframework.org/schema/tx/spring-tx.xsd&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>开启事务注解</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--开启事务注解--&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">tx:annotation-driven</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;transactionManager&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">tx:annotation-driven</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>在 service 类上面（或者service类里面方法上面）添加事务注解</p>
<ul>
<li>@Transactional，这个注解添加到类上面，也可以添加方法上面</li>
<li>如果把这个注解添加类上面，这个类里面所有的方法都添加事务</li>
<li>如果把这个注解添加方法上面，为这个方法添加事务</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="声明式事务管理参数配置"><a href="#声明式事务管理参数配置" class="headerlink" title="声明式事务管理参数配置"></a>声明式事务管理参数配置</h2><ul>
<li><p>service 类上面添加注解**@Transactional**，在这个注解里面可以配置事务相关参数</p>
<ul>
<li><p><strong>propagation</strong>：事务传播行为</p>
<ul>
<li>多事务方法直接进行调用，这个过程中事务 是如何进行管理的</li>
</ul>
<p><img src="/2021/09/27/day23/day23_6.png" alt="事务传播"></p>
</li>
</ul>
<p><img src="/2021/09/27/day23/day23_7.bmp" alt="7种传播行为"></p>
<ul>
<li><p><strong>ioslation</strong>：事务隔离级别</p>
<ul>
<li><p>Mysql默认为可重复读</p>
</li>
<li><p>事务有特性成为隔离性，多事务操作之间不会产生影响。</p>
</li>
<li><p>不考虑隔离性产生很多问题：脏读、不可重复读、虚（幻）读</p>
</li>
</ul>
<p><img src="/2021/09/27/day23/day23_8.bmp" alt="事务隔离级别"></p>
</li>
</ul>
<ul>
<li><p><strong>timeout</strong>：超时时间</p>
<ul>
<li><p>事务需要在一定时间内进行提交，如果不提交进行回滚</p>
</li>
<li><p>默认值是 -1 ，设置时间以秒单位进行计算</p>
</li>
</ul>
</li>
<li><p><strong>readOnly</strong>：是否只读</p>
<ul>
<li>读：查询操作，写：添加修改删除操作</li>
<li>readOnly 默认值 false，表示可以查询，可以添加修改删除操作</li>
<li>设置 readOnly 值是 true，设置成 true 之后，只能查询</li>
</ul>
</li>
<li><p><strong>rollbackFor</strong>：回滚</p>
<ul>
<li>设置出现哪些异常进行事务回滚</li>
</ul>
</li>
<li><p><strong>noRollbackFor</strong>：不回滚</p>
<ul>
<li>设置出现哪些异常不进行事务回滚</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="XML申明事务管理"><a href="#XML申明事务管理" class="headerlink" title="XML申明事务管理"></a>XML申明事务管理</h2><ul>
<li>在 spring配置文件中进行配置<ul>
<li>配置事务管理器</li>
<li>配置通知</li>
<li>配置切入点和切面</li>
</ul>
</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--1 创建事务管理器--&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transactionManager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line"> 	<span class="comment">&lt;!--注入数据源--&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--2 配置通知--&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">&quot;txadvice&quot;</span>&gt;</span></span><br><span class="line"> 	<span class="comment">&lt;!--配置事务参数--&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line"> 		<span class="comment">&lt;!--指定哪种规则的方法上面添加事务--&gt;</span></span><br><span class="line"> 		<span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;accountMoney&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;REQUIRED&quot;</span>/&gt;</span></span><br><span class="line"> 		<span class="comment">&lt;!--&lt;tx:method name=&quot;account*&quot;/&gt;--&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--3 配置切入点和切面--&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line"> 	<span class="comment">&lt;!--配置切入点--&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;pt&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* com.atguigu.spring5.service.UserService.*(..))&quot;</span>/&gt;</span></span><br><span class="line"> 	<span class="comment">&lt;!--配置切面--&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">&quot;txadvice&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pt&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="完全注解声明式事务管理"><a href="#完全注解声明式事务管理" class="headerlink" title="完全注解声明式事务管理"></a>完全注解声明式事务管理</h2><ul>
<li><p>创建配置类，使用配置类替代 xml 配置文件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span> <span class="comment">//配置类</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &quot;com.atguigu&quot;)</span> <span class="comment">//组件扫描</span></span><br><span class="line"><span class="meta">@EnableTransactionManagement</span> <span class="comment">//开启事务</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TxConfig</span> </span>&#123;</span><br><span class="line"> 	<span class="comment">//创建数据库连接池</span></span><br><span class="line"> 	<span class="meta">@Bean</span></span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> DruidDataSource <span class="title">getDruidDataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> 		DruidDataSource dataSource = <span class="keyword">new</span> DruidDataSource();</span><br><span class="line"> 		dataSource.setDriverClassName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line"> 		dataSource.setUrl(<span class="string">&quot;jdbc:mysql:///user_db&quot;</span>);</span><br><span class="line"> 		dataSource.setUsername(<span class="string">&quot;root&quot;</span>);</span><br><span class="line"> 		dataSource.setPassword(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> dataSource;</span><br><span class="line"> 	&#125;</span><br><span class="line">    </span><br><span class="line"> 	<span class="comment">//创建 JdbcTemplate 对象</span></span><br><span class="line"> 	<span class="meta">@Bean</span></span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> JdbcTemplate <span class="title">getJdbcTemplate</span><span class="params">(DataSource dataSource)</span> </span>&#123;</span><br><span class="line"> 		<span class="comment">//到 ioc 容器中根据类型找到 dataSource</span></span><br><span class="line"> 		JdbcTemplate jdbcTemplate = <span class="keyword">new</span> JdbcTemplate();</span><br><span class="line"> 		<span class="comment">//注入 dataSource</span></span><br><span class="line"> 		jdbcTemplate.setDataSource(dataSource);</span><br><span class="line"> 		<span class="keyword">return</span> jdbcTemplate;</span><br><span class="line"> 	&#125;</span><br><span class="line">    </span><br><span class="line"> 	<span class="comment">//创建事务管理器</span></span><br><span class="line"> 	<span class="meta">@Bean</span></span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> DataSourceTransactionManager <span class="title">getDataSourceTransactionManager</span><span class="params">(DataSource dataSource)</span> </span>&#123;</span><br><span class="line"> 		DataSourceTransactionManager transactionManager = <span class="keyword">new</span> DataSourceTransactionManager();</span><br><span class="line"> 		transactionManager.setDataSource(dataSource);</span><br><span class="line"> 		<span class="keyword">return</span> transactionManager;</span><br><span class="line"> 	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="Spring5新功能"><a href="#Spring5新功能" class="headerlink" title="Spring5新功能"></a>Spring5新功能</h1><ul>
<li>整个Spring5框架的代码基于Java8，运行时兼容JDK9，许多不建议使用的类和方法在代码库中删除</li>
<li>Spring 5.0 框架自带了通用的日志封装，可以整合 Log4j2</li>
</ul>
<blockquote>
<p>整合Log4j2步骤：</p>
<ol>
<li>导入jar包</li>
<li>创建 log4j2.xml 配置文件（名字不能更改）</li>
</ol>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="comment">&lt;!--日志级别以及优先级排序: OFF &gt; FATAL &gt; ERROR &gt; WARN &gt; INFO &gt; DEBUG &gt; TRACE &gt; ALL --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--Configuration 后面的 status 用于设置 log4j2 自身内部的信息输出，可以不设置，</span></span><br><span class="line"><span class="comment">当设置成 trace 时，可以看到 log4j2 内部各种详细输出--&gt;</span> </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span> <span class="attr">status</span>=<span class="string">&quot;INFO&quot;</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"> 	<span class="comment">&lt;!--先定义所有的 appender--&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;<span class="name">appenders</span>&gt;</span></span><br><span class="line"> 		<span class="comment">&lt;!--输出日志信息到控制台--&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">console</span> <span class="attr">name</span>=<span class="string">&quot;Console&quot;</span> <span class="attr">target</span>=<span class="string">&quot;SYSTEM_OUT&quot;</span>&gt;</span></span><br><span class="line"> 			<span class="comment">&lt;!--控制日志输出的格式--&gt;</span></span><br><span class="line"> 			<span class="tag">&lt;<span class="name">PatternLayout</span> <span class="attr">pattern</span>=<span class="string">&quot;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%t] %-5level %logger&#123;36&#125; - %msg%n&quot;</span>/&gt;</span></span><br><span class="line"> 		<span class="tag">&lt;/<span class="name">console</span>&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;/<span class="name">appenders</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">     <span class="comment">&lt;!--然后定义 logger，只有定义 logger 并引入的 appender，appender 才会生效--&gt;</span></span><br><span class="line">     <span class="comment">&lt;!--root：用于指定项目的根日志，如果没有单独指定 Logger，则会使用 root 作为默认的日志输出--&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">loggers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">&quot;info&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;Console&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">loggers</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li><p>Spring5框架核心容器支持**@Nullable**注解</p>
<ul>
<li>@Nullable 注解可以使用在方法上面，属性上面，参数上面，表示方法返回可以为空，属性值可以为空，参数值可以为空</li>
</ul>
</li>
<li><p>Spring5核心容器支持函数式风格<strong>GenericApplicationContext</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数式风格创建对象，交给 spring 进行管理</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testGenericApplicationContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="comment">//1 创建 GenericApplicationContext 对象</span></span><br><span class="line">     GenericApplicationContext context = <span class="keyword">new</span> GenericApplicationContext();</span><br><span class="line">    </span><br><span class="line">     <span class="comment">//2 调用 context 的方法对象注册</span></span><br><span class="line">     context.refresh();</span><br><span class="line">     context.registerBean(<span class="string">&quot;user1&quot;</span>,User.class,() -&gt; <span class="keyword">new</span> User());</span><br><span class="line">    </span><br><span class="line">     <span class="comment">//3 获取在 spring 注册的对象</span></span><br><span class="line">     <span class="comment">// User user = (User)context.getBean(&quot;com.atguigu.spring5.test.User&quot;);</span></span><br><span class="line">     User user = (User)context.getBean(<span class="string">&quot;user1&quot;</span>);</span><br><span class="line">     System.out.println(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Spring5支持整合 <strong>JUnit5</strong></p>
<ul>
<li><p>整合JUnit4</p>
<ul>
<li><p>引入 Spring 相关针对测试依赖</p>
</li>
<li><p>创建测试类，使用注解方式完成</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringJUnit4ClassRunner.class)</span> <span class="comment">//单元测试框架</span></span><br><span class="line"><span class="meta">@ContextConfiguration(&quot;classpath:bean1.xml&quot;)</span> <span class="comment">//加载配置文件</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JTest4</span> </span>&#123;</span><br><span class="line">     <span class="meta">@Autowired</span></span><br><span class="line">     <span class="keyword">private</span> UserService userService;</span><br><span class="line">    </span><br><span class="line">     <span class="meta">@Test</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     	userService.accountMoney();</span><br><span class="line"> 	 &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>整合JUnit5</p>
<ul>
<li>引入 JUnit5 的 jar 包</li>
<li>创建测试类，使用注解完成</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ExtendWith(SpringExtension.class)</span></span><br><span class="line"><span class="meta">@ContextConfiguration(&quot;classpath:bean1.xml&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JTest5</span> </span>&#123;</span><br><span class="line">     <span class="meta">@Autowired</span></span><br><span class="line">     <span class="keyword">private</span> UserService userService;</span><br><span class="line">     <span class="meta">@Test</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     	userService.accountMoney();</span><br><span class="line">     &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>使用一个复合注解替代上面两个注解完成整合</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringJUnitConfig(locations = &quot;classpath:bean1.xml&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JTest5</span> </span>&#123;</span><br><span class="line">     <span class="meta">@Autowired</span></span><br><span class="line">     <span class="keyword">private</span> UserService userService;</span><br><span class="line">     <span class="meta">@Test</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     	userService.accountMoney();</span><br><span class="line">     &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="SpringWebFlux"><a href="#SpringWebFlux" class="headerlink" title="SpringWebFlux"></a>SpringWebFlux</h2><ul>
<li>是 Spring5 添加新的模块，用于 web 开发，功能和 SpringMVC 类似。Webflux 使用当前一种比较流程响应式编程出现的框架。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Kaixuan Wang"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Kaixuan Wang</p>
  <div class="site-description" itemprop="description">只争朝夕</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">33</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Kaixuan Wang</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>

<script src="/js/utils.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>

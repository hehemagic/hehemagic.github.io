<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/study-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/study-16x16.png">
  <link rel="mask-icon" href="/images/study.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="JAVA基础基础Java 泛型了解么？什么是类型擦除？介绍一下常用的通配符？ Java 泛型（generics）是 JDK 5 中引入的一个新特性, 泛型提供了编译时类型安全检测机制，该机制允许程序员在编译时检测到非法的类型。泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。 Java 的泛型是伪泛型，这是因为 Java 在编译期间，所有的泛型信息都会被擦掉，也就是编译生成的字节码">
<meta property="og:type" content="article">
<meta property="og:title" content="八股">
<meta property="og:url" content="http://example.com/2022/01/03/day29/index.html">
<meta property="og:site_name" content="Magic">
<meta property="og:description" content="JAVA基础基础Java 泛型了解么？什么是类型擦除？介绍一下常用的通配符？ Java 泛型（generics）是 JDK 5 中引入的一个新特性, 泛型提供了编译时类型安全检测机制，该机制允许程序员在编译时检测到非法的类型。泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。 Java 的泛型是伪泛型，这是因为 Java 在编译期间，所有的泛型信息都会被擦掉，也就是编译生成的字节码">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/2022/01/03/day29/day29_1.jpg">
<meta property="og:image" content="http://example.com/2022/01/03/day29/day29_2.jpg">
<meta property="og:image" content="http://example.com/2022/01/03/day29/day29_3.png">
<meta property="og:image" content="http://example.com/2022/01/03/day29/day29_4.png">
<meta property="og:image" content="http://example.com/2022/01/03/day29/day29_28.png">
<meta property="og:image" content="http://example.com/2022/01/03/day29/day29_5.png">
<meta property="og:image" content="http://example.com/2022/01/03/day29/day29_27.png">
<meta property="og:image" content="http://example.com/2022/01/03/day29/day29_6.png">
<meta property="og:image" content="http://example.com/2022/01/03/day29/day29_7.png">
<meta property="og:image" content="http://example.com/2022/01/03/day29/day29_8.png">
<meta property="og:image" content="http://example.com/2022/01/03/day29/day29_9.png">
<meta property="og:image" content="http://example.com/2022/01/03/day29/day29_10.png">
<meta property="og:image" content="http://example.com/2022/01/03/day29/day29_11.png">
<meta property="og:image" content="http://example.com/2022/01/03/day29/day29_12.png">
<meta property="og:image" content="http://example.com/2022/01/03/day29/day29_13.png">
<meta property="og:image" content="http://example.com/2022/01/03/day29/day29_14.png">
<meta property="og:image" content="http://example.com/2022/01/03/day29/day29_15.png">
<meta property="og:image" content="http://example.com/2022/01/03/day29/day29_19.png">
<meta property="og:image" content="http://example.com/2022/01/03/day29/day29_25.png">
<meta property="og:image" content="http://example.com/2022/01/03/day29/day29_26.png">
<meta property="og:image" content="http://example.com/2022/01/03/day29/day29_29.png">
<meta property="og:image" content="http://example.com/2022/01/03/day29/day29_20.png">
<meta property="og:image" content="http://example.com/2022/01/03/day29/day29_21.png">
<meta property="og:image" content="http://example.com/2022/01/03/day29/day29_22.png">
<meta property="og:image" content="http://example.com/2022/01/03/day29/day29_23.png">
<meta property="og:image" content="http://example.com/2022/01/03/day29/day29_24.png">
<meta property="og:image" content="http://example.com/2022/01/03/day29/day29_30.png">
<meta property="og:image" content="http://example.com/2022/01/03/day29/day29_31.png">
<meta property="og:image" content="http://example.com/2022/01/03/day29/day29_32.png">
<meta property="og:image" content="http://example.com/2022/01/03/day29/day29_33.png">
<meta property="og:image" content="http://example.com/2022/01/03/day29/day29_34.png">
<meta property="og:image" content="http://example.com/2022/01/03/day29/day29_35.png">
<meta property="og:image" content="http://example.com/2022/01/03/day29/day29_36.png">
<meta property="og:image" content="http://example.com/2022/01/03/day29/day29_58.png">
<meta property="og:image" content="http://example.com/2022/01/03/day29/day29_59.png">
<meta property="og:image" content="http://example.com/2022/01/03/day29/day29_60.png">
<meta property="og:image" content="http://example.com/2022/01/03/day29/day29_61.png">
<meta property="og:image" content="http://example.com/2022/01/03/day29/day29_56.png">
<meta property="og:image" content="http://example.com/2022/01/03/day29/day29_57.png">
<meta property="og:image" content="http://example.com/2022/01/03/day29/day29_37.png">
<meta property="og:image" content="http://example.com/2022/01/03/day29/day29_38.png">
<meta property="og:image" content="http://example.com/2022/01/03/day29/day29_39.png">
<meta property="og:image" content="http://example.com/2022/01/03/day29/day29_40.png">
<meta property="og:image" content="http://example.com/2022/01/03/day29/day29_41.png">
<meta property="og:image" content="http://example.com/2022/01/03/day29/day29_42.png">
<meta property="og:image" content="http://example.com/2022/01/03/day29/day29_43.png">
<meta property="og:image" content="http://example.com/2022/01/03/day29/day29_46.png">
<meta property="og:image" content="http://example.com/2022/01/03/day29/day29_47.png">
<meta property="og:image" content="http://example.com/2022/01/03/day29/day29_48.png">
<meta property="og:image" content="http://example.com/2022/01/03/day29/day29_49.png">
<meta property="og:image" content="http://example.com/2022/01/03/day29/day29_50.png">
<meta property="og:image" content="http://example.com/2022/01/03/day29/day29_52.png">
<meta property="og:image" content="http://example.com/2022/01/03/day29/day29_51.png">
<meta property="og:image" content="http://example.com/2022/01/03/day29/day29_53.png">
<meta property="og:image" content="http://example.com/2022/01/03/day29/day29_54.png">
<meta property="og:image" content="http://example.com/2022/01/03/day29/day29_55.png">
<meta property="og:image" content="http://example.com/2022/01/03/day29/day29_44.png">
<meta property="og:image" content="http://example.com/2022/01/03/day29/day29_45.png">
<meta property="article:published_time" content="2022-01-03T12:08:04.570Z">
<meta property="article:modified_time" content="2022-10-08T07:19:29.293Z">
<meta property="article:author" content="Kaixuan Wang">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2022/01/03/day29/day29_1.jpg">

<link rel="canonical" href="http://example.com/2022/01/03/day29/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>八股 | Magic</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Magic</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/01/03/day29/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Kaixuan Wang">
      <meta itemprop="description" content="只争朝夕">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Magic">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          八股
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-01-03 20:08:04" itemprop="dateCreated datePublished" datetime="2022-01-03T20:08:04+08:00">2022-01-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-10-08 15:19:29" itemprop="dateModified" datetime="2022-10-08T15:19:29+08:00">2022-10-08</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="JAVA基础"><a href="#JAVA基础" class="headerlink" title="JAVA基础"></a>JAVA基础</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="Java-泛型了解么？什么是类型擦除？介绍一下常用的通配符？"><a href="#Java-泛型了解么？什么是类型擦除？介绍一下常用的通配符？" class="headerlink" title="Java 泛型了解么？什么是类型擦除？介绍一下常用的通配符？"></a><strong>Java 泛型了解么？什么是类型擦除？介绍一下常用的通配符？</strong></h3><ul>
<li>Java 泛型（generics）是 JDK 5 中引入的一个新特性, 泛型提供了编译时类型安全检测机制，该机制允许程序员在编译时检测到非法的类型。泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。</li>
<li>Java 的泛型是伪泛型，这是因为 Java 在编译期间，所有的泛型信息都会被擦掉，也就是编译生成的字节码中不包含泛型信息，但泛型信息还是会保存下来</li>
</ul>
<h3 id="为什么重写-equals-时必须重写-hashCode-方法？"><a href="#为什么重写-equals-时必须重写-hashCode-方法？" class="headerlink" title="为什么重写 equals 时必须重写 hashCode 方法？"></a><strong>为什么重写 equals 时必须重写 hashCode 方法？</strong></h3><ul>
<li>例如HashSet存放元素，会先调用hashCode()方法判断，如果存在hashCode()，才调用equals()方法判断是否相等。</li>
<li>如果两个对象相等，则 hashcode 一定也是相同的。两个对象相等,对两个对象分别调用 equals 方法都返回 true。但是，两个对象有相同的 hashcode 值，它们也不一定是相等的 。因此，equals 方法被覆盖过，则 hashCode 方法也必须被覆盖。</li>
</ul>
<h3 id="8-种基本类型的包装类和常量池"><a href="#8-种基本类型的包装类和常量池" class="headerlink" title="8 种基本类型的包装类和常量池"></a><strong>8 种基本类型的包装类和常量池</strong></h3><ul>
<li>Java 基本类型的包装类的大部分都实现了常量池技术。Byte,Short,Integer,Long 这 4 种包装类默认创建了数值 [-128，127] 的相应类型的缓存数据，Character 创建了数值在[0,127]范围的缓存数据，Boolean 直接返回 True Or False</li>
<li><strong>为什么缓存设置在[-128, 127]？</strong>性能和资源的平衡，太大的话占用资源太多，太小的话性能不会有很大提升，可以进行调整</li>
<li>valueOf方法会直接从缓存池中获得对象</li>
</ul>
<h3 id="成员变量与局部变量的区别有哪些？"><a href="#成员变量与局部变量的区别有哪些？" class="headerlink" title="成员变量与局部变量的区别有哪些？"></a><strong>成员变量与局部变量的区别有哪些？</strong></h3><ul>
<li>从语法形式上看，成员变量是属于类的，而局部变量是在代码块或方法中定义的变量或是方法的参数；成员变量可以被 public,private,static 等修饰符所修饰，而局部变量不能被访问控制修饰符及 static 所修饰；但是，成员变量和局部变量都能被 final 所修饰。</li>
<li>从变量在内存中的存储方式来看,如果成员变量是使用 static 修饰的，那么这个成员变量是属于类的，如果没有使用 static 修饰，这个成员变量是属于实例的。而对象存在于堆内存，局部变量则存在于栈内存。</li>
<li>从变量在内存中的生存时间上看，成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动消失。</li>
<li>从变量是否有默认值来看，成员变量如果没有被赋初，则会自动以类型的默认值而赋值（一种情况例外:被 final 修饰的成员变量也必须显式地赋值），而局部变量则不会自动赋值。</li>
</ul>
<h3 id="如何从子类调用父类的private属性和方法？"><a href="#如何从子类调用父类的private属性和方法？" class="headerlink" title="如何从子类调用父类的private属性和方法？"></a><strong>如何从子类调用父类的private属性和方法？</strong></h3><ul>
<li>可以通过反射获得。可以将子类和父类定义为同一个类的内部类。之后实例化的子类就可以访问父类的私有方法和私有属性，父类也可以直接调用私有方法和私有属性</li>
</ul>
<h3 id="String-StringBuffer-和-StringBuilder-的区别是什么-String-为什么是不可变的-不可变有什么好处"><a href="#String-StringBuffer-和-StringBuilder-的区别是什么-String-为什么是不可变的-不可变有什么好处" class="headerlink" title="**String StringBuffer 和 StringBuilder 的区别是什么? String 为什么是不可变的?**不可变有什么好处?"></a>**String StringBuffer 和 StringBuilder 的区别是什么? String 为什么是不可变的?**不可变有什么好处?</h3><ul>
<li>简单的来说：String类中使用 final 关键字修饰字符数组来保存字符串，private final char value[]，所以String 对象是不可变的。</li>
</ul>
<ul>
<li>String 真正不可变有下面几点原因：<ul>
<li><p>保存字符串的数组被 final 修饰且为私有的，并且String 类没有提供/暴露修改这个字符串的方法。</p>
<p>String 类被 final 修饰导致其不能被继承，进而避免了子类破坏 String 不可变。</p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>补充：在 Java 9 之后，String 、StringBuilder 与 StringBuffer 的实现改用 byte 数组存储字符串 private final byte[] value</p>
</blockquote>
<ul>
<li>而 StringBuilder 与 StringBuffer 都继承自 AbstractStringBuilder 类，在 AbstractStringBuilder 中也是使用字符数组保存字符串char[]value 但是没有用 final 关键字修饰，所以这两种对象都是可变的。</li>
<li>StringBuffer 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder 并没有对方法进行加同步锁，所以是非线程安全的。</li>
<li>每次对 String 类型进行改变的时候，都会生成一个新的 String 对象，然后将指针指向新的 String 对象。StringBuffer 每次都会对 StringBuffer 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 StringBuilder 相比使用 StringBuffer 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。</li>
<li>StringBuilder扩容时，长度变为原来的两倍再加上2，加2主要是因为append()之后会在后面加上一个分隔符char，char占用两个字节，避免因为分隔符而再次扩容</li>
</ul>
<blockquote>
<p>不可变好处：</p>
<ol>
<li>可以缓存hash值</li>
<li>String Pool需要，如果String已经被创建过了，就会直接从常量池中获得，只有String不可变才可以使用String Pool</li>
<li>线程安全 new String(“abc”)会创建两个string 对象，分别在堆中和字符串常量池中</li>
</ol>
</blockquote>
<h3 id="浅拷贝和引用拷贝区别"><a href="#浅拷贝和引用拷贝区别" class="headerlink" title="浅拷贝和引用拷贝区别"></a><strong>浅拷贝和引用拷贝区别</strong></h3><ul>
<li>浅拷贝会在堆上创建一个新的对象，但是如果原对象内部属性为引用类型的话，新对象直接复制内部对象的引用地址</li>
<li>引用拷贝只是在栈上创建一个引用变量</li>
</ul>
<h3 id="反射机制优缺点"><a href="#反射机制优缺点" class="headerlink" title="反射机制优缺点"></a><strong>反射机制优缺点</strong></h3><p>优点 ： 可以让咱们的代码更加灵活、为各种框架提供开箱即用的功能提供了便利</p>
<p>缺点 ：让我们在运行时有了分析操作类的能力，这同样也增加了安全问题。比如可以无视泛型参数的安全检查（泛型参数的安全检查发生在编译时）。另外，反射的性能也要稍差点，不过，对于框架来说实际是影响不大的。</p>
<h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a><strong>异常</strong></h3><p>除了RuntimeException及其子类以外，其他的Exception类及其子类都属于受检查异常 。</p>
<p><img src="/2022/01/03/day29/day29_1.jpg" alt="异常分类"> </p>
<p><img src="/2022/01/03/day29/day29_2.jpg" alt="异常分类（2）"> </p>
<h3 id="Java-序列化中如果有些字段不想进行序列化，怎么办？"><a href="#Java-序列化中如果有些字段不想进行序列化，怎么办？" class="headerlink" title="Java 序列化中如果有些字段不想进行序列化，怎么办？"></a><strong>Java 序列化中如果有些字段不想进行序列化，怎么办？</strong></h3><p>对于不想进行序列化的变量，使用 transient 关键字修饰。  </p>
<p>transient 关键字的作用是：阻止实例中那些用此关键字修饰的的变量序列化；当对象被反序列化时，被 transient 修饰的变量值不会被持久化和恢复。</p>
<blockquote>
<p>关于 transient 还有几点注意：<br>transient 只能修饰变量，不能修饰类和方法。<br>transient 修饰的变量，在反序列化后变量值将会被置成类型的默认值。例如，如果是修饰 int 类型，那么反序列后结果就是 0。<br>static 变量因为不属于任何对象(Object)，所以无论有没有 transient 关键字修饰，均不会被序列化。</p>
</blockquote>
<h3 id="Java中只有值传递"><a href="#Java中只有值传递" class="headerlink" title="Java中只有值传递"></a><strong>Java中只有值传递</strong></h3><p>如果参数是基本类型的话，很简单，传递的就是基本类型的字面量值的拷贝，会创建副本。</p>
<p>如果参数是引用类型，传递的就是实参所引用的对象在堆中地址值的拷贝，同样也会创建副本。</p>
<h3 id="BIO-NIO-AIO"><a href="#BIO-NIO-AIO" class="headerlink" title="BIO NIO AIO"></a><strong>BIO NIO AIO</strong></h3><ul>
<li><p>BIO(Blocking IO)：同步阻塞型IO，一个客户端对应一个处理线程，同时处理多个客户端必须使用多线程。<strong>在没有读取到相应数据时，程序一直阻塞</strong></p>
</li>
<li><p>伪异步线程：对BIO的改进。在客户端发起请求后，维护一个消息队列，将请求放入消息队列中，再通过线程池进行线程管理，处理消息队列中的请求。这样可以满足客户端请求大于线程数</p>
</li>
<li><p>NIO(new IO):同步非阻塞型IO，使用缓冲区解决阻塞问题，读写数据都要通过缓存区实现。NIO中通过channel读写数据，是双向的通道，既可以读也可以写。NIO中有selector选择器，可以使用较少的线程处理多个通道，减少线程的切换，提高效率</p>
</li>
<li><p>IO 多路复用模型中，线程首先发起 select 调用，询问内核数据是否准备就绪，等内核把数据准备好了，用户线程再发起 read 调用，不需要一直发起read请求。read 调用的过程（数据从内核空间 -&gt; 用户空间）还是阻塞的。</p>
<blockquote>
<p>操作系统级别提供了一些接口来支持IO多路复用，最早的是select、poll，其后epoll是Linux下的IO多路复用的实现。</p>
<ul>
<li>select接口最早实现存在需要调用多次、线程不安全以及限制只能监视1024个链接的问题</li>
<li>poll接口修复了select函数的一些问题，但是依然不是线程安全的。</li>
<li>epoll接口修复了上述的问题，并且线程安全，会通知具体哪个连接有新数据。<ul>
<li>epoll通过epoll_ctl()来注册一个文件描述符,一旦基于某个文件描述符就绪时,内核会采用类似<strong>callback的回调机制</strong>,迅速激活这个文件描述符,当进程调用epoll_wait()时便得到通知(不再需要遍历文件描述符,通过监听回调的机制,也是epoll的魅力)</li>
<li>epoll除了性能优势，还有一个优点——同时支持水平触发(Level Trigger)和边沿触发(Edge Trigger)。<ul>
<li>水平触发只关心文件描述符中是否还有没完成处理的数据，如果有，不管怎样epoll_wait，总是会被返回。简单说——水平触发代表了一种“状态”</li>
<li>边沿触发只关心文件描述符是否有新的事件产生，如果有，则返回；如果返回过一次，不管程序是否处理了，只要没有新的事件产生，epoll_wait不会再认为这个fd被“触发”了。简单说——边沿触发代表了一个“事件”。</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
</li>
<li><p>AIO(Asynchronous I/O)：异步非阻塞型IO，相对于NIO而言，AIO是在数据完全处理完之后再通知cpu，而不需要cpu自己做同步的数据读写 </p>
</li>
</ul>
<h3 id="JDK动态代理和CGLIB动态代理对比"><a href="#JDK动态代理和CGLIB动态代理对比" class="headerlink" title="JDK动态代理和CGLIB动态代理对比"></a>JDK动态代理和CGLIB动态代理对比</h3><ul>
<li><strong>JDK 动态代理只能代理实现了接口的类或者直接代理接口，而 CGLIB 可以代理未实现任何接口的类。</strong> 另外， CGLIB 动态代理是通过生成一个被代理类的子类来拦截被代理类的方法调用，因此不能代理声明为 final 类型的类和方法</li>
<li>就二者的效率来说，大部分情况都是 JDK 动态代理更优秀，随着 JDK 版本的升级，这个优势更加明显</li>
</ul>
<h3 id="抽象类和接口"><a href="#抽象类和接口" class="headerlink" title="抽象类和接口"></a>抽象类和接口</h3><ul>
<li><strong>共同点</strong>：<ul>
<li>都不能被实例化</li>
<li>都可以包含抽象方法</li>
<li>都可以有默认的实现方法</li>
</ul>
</li>
<li><strong>区别</strong>：<ul>
<li>接口只要是对类的行为进行约束，实现了接口就有了具体的对应功能；抽象类主要用于代码复用，强调所属关系</li>
<li>一个类只能继承一个类，实现多个接口</li>
<li>接口中的成员变量只能是 <code>public static final</code> 类型的，不能被修改且必须有初始值，而抽象类的成员变量默认 default，可在子类中被重新定义，也可被重新赋值。</li>
</ul>
</li>
</ul>
<h3 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h3><ul>
<li>枚举类比较可以使用==或equals方法，是等价的</li>
<li>枚举类在jvm编译之后，实际变成final修饰的class，意味着实例化之后无法改变，并且只存在一个对象</li>
</ul>
<h3 id="IO类"><a href="#IO类" class="headerlink" title="IO类"></a>IO类</h3><ul>
<li>字节流：<ul>
<li>InputStream：所有字节输入流父类<ul>
<li>FileInputStream:一般与bufferedInputStream一起使用</li>
<li>DataInputStream：读取指定类型数据，与FileInputStream一起使用</li>
<li>ObjectInputStream：从输入流中读取Java对象</li>
</ul>
</li>
<li>OutputStream：所有字节输出流父类<ul>
<li>FileInputStream：一般与bufferedOutputStream一起使用</li>
<li>DataOutputStream：写入指定类型数据，与FileInputStream一起使用</li>
<li>ObjectOutputStream ：将对象写入到输出流</li>
</ul>
</li>
</ul>
</li>
<li>字符流：为了防止不知道编码出现乱码问题<ul>
<li>Reader：所有字符输入流父类，读取文本，抽象类<ul>
<li>InputStreamReader：字节流转换为字符流桥梁</li>
<li>FileReader</li>
</ul>
</li>
<li>Writer：所有字符输出流父类，抽象类<ul>
<li>OutputStreamWriter：字节流转换为字符流桥梁</li>
<li>FileWriter</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="设计模式总结"><a href="#设计模式总结" class="headerlink" title="设计模式总结"></a>设计模式总结</h3><ul>
<li>观察者模式：对象之间一对多的依赖。一个对象状态改变，所有的依赖者都会收到相应的通知。（如气象站和布告板，气象站温度变化，所有布告板都需要更新）</li>
<li>装饰者模式：将责任附加到对象上，例如IO类中，FileInputStream就是一个装饰者，增强了InputStream的功能</li>
<li>单例模式：只存在一个实例</li>
<li>工厂模式：由子类自己决定要实例化的类是哪一个，将类的实例化推迟到子类</li>
<li>适配器模式：将一个类的接口，转化成另一个客户期待的接口</li>
</ul>
<h3 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h3><ul>
<li><p>交换</p>
<ul>
<li><p>冒泡排序：每一轮将最大的元素放在结尾</p>
</li>
<li><p>快速排序：优化：随机选择基准、设定一个阈值，低于阈值使用插入排序</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &gt;= right) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> l = left;</span><br><span class="line">    <span class="keyword">int</span> r = right;</span><br><span class="line">    <span class="keyword">int</span> temp = nums[l];</span><br><span class="line">    <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r &amp;&amp; nums[r]&gt;=temp) r--;</span><br><span class="line">       	nums[l] = nums[r];</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r &amp;&amp; nums[l]&lt;=temp) l++;</span><br><span class="line">        nums[r] = nums[l];</span><br><span class="line">    &#125;</span><br><span class="line">    nums[l] = temp;</span><br><span class="line">    quickSort(nums,left,l-<span class="number">1</span>);</span><br><span class="line">    quickSort(nums,l+<span class="number">1</span>,right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>插入</p>
<ul>
<li>插入排序：每次将新元素插入到队列中</li>
<li>希尔排序：每次设定一个增量，初始为length/2，增量每轮减半，直到减为1，完成排序</li>
</ul>
</li>
<li><p>选择</p>
<ul>
<li>选择排序：选择最小的元素交换至第一位</li>
<li>堆排序：建立大根堆</li>
</ul>
</li>
<li><p>归并排序：将数组长度逐渐分割很小，再进行有序数组合并</p>
</li>
<li><p>桶</p>
<ul>
<li>桶排序：每个桶对应不同的数据范围，将所有数据分成几个小的数组，分别排序。时间复杂度可以接近O（n）</li>
<li>计数排序：根据数据范围创建max-min+1辅助空间，记录每个元素出现个数</li>
<li>基数排序：逐次比较数据每一位的大小，创建0-9的桶。</li>
</ul>
</li>
</ul>
<blockquote>
<p>对于小的数据排序使用插入排序、中等数据使用快排、对于结构化的数组使用归并排序</p>
<ol>
<li><p>如果待排序列中数据含有大量重复值——优先使用计数排序；</p>
</li>
<li><p>如果待排序列中数据近乎有序——优先使用插入排序；</p>
</li>
<li><p>如果待排序列中数据取值范围有限——优先使用计数排序；</p>
</li>
<li><p>如果待排序列中数据要求稳定——优先使用归并排序；</p>
</li>
<li><p>如果待排序列需要使用链表——优先链表归并、链表快排；</p>
</li>
<li><p>如果待排序列中数据无法全部装到内存——优先使用外部排序（归并排序，基数排序，计数排序，桶排序）</p>
</li>
</ol>
</blockquote>
<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><h3 id="ArrayList扩容"><a href="#ArrayList扩容" class="headerlink" title="ArrayList扩容"></a>ArrayList扩容</h3><ul>
<li><p>默认初始容量为10。但如果使用默认容量，在没有添加元素之前，容量为0。</p>
</li>
<li><p>在进行添加元素时，如果需要的空间大于目前的容量，需要进行扩容：</p>
<ul>
<li>正常情况下，容量会增大到原来容量的1.5倍，<strong>newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1)</strong></li>
<li>如果增加1.5倍后的容量大于定义的最大容量<strong>Integer.MAX_VALUE-8</strong>，此时需要比较所需的最小容量和最大容量<ul>
<li>若所需最小容量小于最大容量，扩容到最大容量</li>
<li>若所需最小容量大于最大容量，扩容到<strong>Integer.MAX_VALUE</strong></li>
</ul>
</li>
</ul>
<blockquote>
<p>扩容因子为什么是1.5？</p>
<p>因为一般在内存中，扩容时首先需要开辟扩容后的空间，再将原来的数据复制进去。如果扩容因子&gt;=2，每次扩容的容量都会大于之前所有扩容的容量之和，就没办法使用前面释放的空间，扩容因子设为1.5的话也比较容易计算，也可以复用之前的空间</p>
</blockquote>
</li>
<li><p>Arrays.asList()方法返回的是Arrays内部的ArrayList，因为没有重写抽象父类的方法，不支持元素的新增和删除</p>
</li>
</ul>
<h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><h4 id="无序性和不可重复性的含义是什么"><a href="#无序性和不可重复性的含义是什么" class="headerlink" title="无序性和不可重复性的含义是什么?"></a>无序性和不可重复性的含义是什么?</h4><ul>
<li><p>无序性不等于随机性 ，无序性是指存储的数据在底层数组中并非按照数组索引的顺序添加 ，而是根据数据的哈希值决定的。</p>
</li>
<li><p>不可重复性是指添加的元素按照 equals()判断时 ，返回 false，需要同时重写 equals()方法和 HashCode()方法。</p>
</li>
</ul>
<h4 id="比较-HashSet、LinkedHashSet-和-TreeSet-三者的异同"><a href="#比较-HashSet、LinkedHashSet-和-TreeSet-三者的异同" class="headerlink" title="比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同"></a>比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同</h4><ul>
<li>都是 <code>Set</code> 接口的实现类，都能保证元素唯一，并且都不是线程安全的。</li>
<li><code>HashSet</code> 的底层数据结构是哈希表（基于 <code>HashMap</code> 实现）。<code>LinkedHashSet</code> 的底层数据结构是链表和哈希表，元素的插入和取出顺序满足 FIFO。<code>TreeSet</code> 底层数据结构是红黑树，元素是有序的，排序的方式有自然排序和定制排序。</li>
<li><code>HashSet</code> 用于不需要保证元素插入和取出顺序的场景，<code>LinkedHashSet</code> 用于保证元素的插入和取出顺序满足 FIFO 的场景，<code>TreeSet</code> 用于支持对元素自定义排序规则的场景</li>
</ul>
<h3 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h3><h4 id="ArrayDeque-与-LinkedList-的区别"><a href="#ArrayDeque-与-LinkedList-的区别" class="headerlink" title="ArrayDeque 与 LinkedList 的区别"></a>ArrayDeque 与 LinkedList 的区别</h4><ul>
<li><p><code>ArrayDeque</code> 是基于可变长的数组和双指针来实现，而 <code>LinkedList</code> 则通过链表来实现。</p>
</li>
<li><p><code>ArrayDeque</code> 不支持存储 <code>NULL</code> 数据，但 <code>LinkedList</code> 支持。</p>
</li>
<li><p><code>ArrayDeque</code> 是在 JDK1.6 才被引入的，而<code>LinkedList</code> 早在 JDK1.2 时就已经存在。</p>
</li>
<li><p><code>ArrayDeque</code> 插入时可能存在扩容过程, 不过均摊后的插入操作依然为 O(1)。虽然 <code>LinkedList</code> 不需要扩容，但是每次插入数据时均需要申请新的堆空间，均摊性能相比更慢。</p>
</li>
<li><p>从性能的角度上，选用 <code>ArrayDeque</code> 来实现队列要比 <code>LinkedList</code> 更好。</p>
</li>
</ul>
<h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><h4 id="HashMap和HashTable区别"><a href="#HashMap和HashTable区别" class="headerlink" title="HashMap和HashTable区别"></a>HashMap和HashTable区别</h4><ul>
<li><p><strong>线程是否安全：</strong> <code>HashMap</code> 是非线程安全的，<code>Hashtable</code> 是线程安全的,因为 <code>Hashtable</code> 内部的方法基本都经过<code>synchronized</code> 修饰。</p>
</li>
<li><p><strong>效率：</strong> 因为线程安全的问题，<code>HashMap</code> 要比 <code>Hashtable</code> 效率高一点。另外，<code>Hashtable</code> 基本被淘汰，不要在代码中使用它，保证线程安全的话就使用 <code>ConcurrentHashMap</code> </p>
</li>
<li><p><strong>对 Null key 和 Null value 的支持：</strong> <code>HashMap</code> 可以存储 null 的 key 和 value，但 null 作为键只能有一个，null 作为值可以有多个；<code>Hashtable</code> 不允许有 null 键和 null 值，否则会抛出 <code>NullPointerException</code>。</p>
</li>
<li><p><strong>初始容量大小和每次扩充容量大小的不同 ：</strong> </p>
<ul>
<li><p>创建时如果不指定容量初始值，<code>Hashtable</code> 默认的初始大小为 11，之后每次扩充，容量变为原来的 2n+1。<code>HashMap</code> 默认的初始化大小为 16。之后每次扩充，容量变为原来的 2 倍。</p>
</li>
<li><p> 创建时如果给定了容量初始值，那么 Hashtable 会直接使用你给定的大小，而 <code>HashMap</code> 会将其扩充为 2 的幂次方大小（<code>HashMap</code> 中的<code>tableSizeFor()</code>方法保证）。</p>
</li>
</ul>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns a power of two size for the given target capacity.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>底层数据结构：</strong> JDK1.8 以后的 <code>HashMap</code> 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，<strong>如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树</strong>）时，将链表转化为红黑树，以减少搜索时间。Hashtable 没有这样的机制。</p>
</li>
</ul>
<h4 id="HashMap-、TreeMap和LinkedHashMap区别"><a href="#HashMap-、TreeMap和LinkedHashMap区别" class="headerlink" title="HashMap 、TreeMap和LinkedHashMap区别"></a>HashMap 、TreeMap和LinkedHashMap区别</h4><ul>
<li><code>TreeMap</code> 和<code>HashMap</code> 都继承自<code>AbstractMap</code> ，但是需要注意的是<code>TreeMap</code>它还实现了<code>NavigableMap</code>接口和<code>SortedMap</code> 接口</li>
<li>实现 <code>NavigableMap</code> 接口让 <code>TreeMap</code> 有了对集合内元素的搜索的能力.实现<code>SortedMap</code>接口让 <code>TreeMap</code> 有了对集合中的元素根据键排序的能力，可以自定义比较器</li>
<li>相比于<code>HashMap</code>来说 <code>TreeMap</code> 主要多了对集合中的元素根据键排序的能力以及对集合内元素的搜索的能力</li>
<li><code>LinkedHashMap</code>在HashMap的基础上添加了双向链表，可以保证插入节点的顺序，在访问时可以进行顺序访问</li>
</ul>
<h4 id="HashSet检测重复"><a href="#HashSet检测重复" class="headerlink" title="HashSet检测重复"></a>HashSet检测重复</h4><ul>
<li>先判断<code>hashCode()</code>是否相同，如果相同，再判断<code>equals()</code></li>
<li>在jdk8中，<code>HashSet</code>的<code>add()</code>方法只是简单的调用了<code>HashMap</code>的<code>put()</code>方法，并且判断了一下返回值以确保是否有重复元素。<strong>也就是说，即使有重复元素，<code>HashSet</code>还是会将元素插入，只是通过返回值告诉我们存在重复元素</strong></li>
</ul>
<h4 id="HashMap底层实现"><a href="#HashMap底层实现" class="headerlink" title="HashMap底层实现"></a>HashMap底层实现</h4><ul>
<li><p>jdk8之前使用<code>数组+链表</code>实现。HashMap 通过 key 的 hashCode 经过扰动函数处理过后得到 hash 值，然后通过 (n - 1) &amp; hash 判断当前元素存放的位置（这里的 n 指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突</p>
</li>
<li><p>jdk8之后，使用<code>数组+链表+红黑树</code>实现。当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间</p>
<blockquote>
<p>链表长度大于8：链表长度太短没必要转化为红黑树，查找效率不会有很大提升，并且插入删除操作耗时</p>
<p>数组长度大于64：数组长度小于64发生hash冲突的几率比较高，转为红黑树可能会导致插入次数变多；数组长度比较小时，扩容的几率比较高，红黑树结构在rehash的过程中比较复杂</p>
</blockquote>
</li>
<li><p>默认加载因子为0.75，加载因子太大会导致冲突几率增大，太小空间利用率太低，0.75是一个折中的方案</p>
</li>
<li><p>最大容量：2^30；树的长度小于6时，重新转换为链表</p>
</li>
<li><p><code>put</code>操作，调用<code>putVal</code>方法</p>
<ul>
<li>如果是插入进链表，则插入到链表尾部。JDK7,插入到头部</li>
</ul>
<p><img src="/2022/01/03/day29/day29_3.png" alt="put方法大致流程"></p>
</li>
<li><p><code>resize</code>方法，一般伴随着<code>rehash</code>非常耗时，要尽量避免</p>
<ul>
<li>如果当前的数组大小超过了最大值就不再扩容，否则容量变为原来的两倍</li>
<li>rehash的过程中，需要将原数据复制到新数组中<ul>
<li>没有冲突的位置，直接<code>hashcoe &amp; (newCap-1)</code>计算位置</li>
<li>对于链表，要么位置不变，要么在原位置+oldCap位置</li>
<li>对于红黑树，算法较为复杂</li>
</ul>
</li>
</ul>
<blockquote>
<p>各种树：</p>
<ol>
<li><strong>红黑树和AVL树区别</strong></li>
</ol>
<ul>
<li>AVL树是<strong>严格的平衡二叉树</strong>，平衡条件必须满足（<strong>所有节点的左右子树高度差不超过1</strong>）。不管我们是执行插入还是删除操作，只要不满足上面的条件，就要通过旋转来保持平衡。它的高度会更低，所以<strong>AVL树适合用于插入与删除次数比较少，但查找多的情况。</strong></li>
<li>红黑树是<strong>弱平衡二叉树</strong>，它通过着色限制的关系，<strong>确保没有一条路径会比其它路径长出两倍，</strong>相对于AVL树来说，它的旋转次数少，所以<strong>对于搜索，插入，删除操作较多的情况下，我们就用红黑树</strong></li>
<li>红黑树插入操作的时间复杂度为O(logn)，AVL树插入操作的时间复杂度也为O(logn)</li>
</ul>
<ol start="2">
<li><strong>红黑树的性质</strong></li>
</ol>
<ul>
<li>红色结点不可能相连，黑色节点可以相连</li>
<li>根节点是黑色节点</li>
<li>每个红色节点的两个子节点都是黑色，叶子节点都是黑色(Null节点)</li>
<li>从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。</li>
<li>插入的点默认都是红色</li>
</ul>
<ol start="3">
<li><strong>红黑树插入规则</strong></li>
</ol>
<ul>
<li><p>变颜色</p>
<ul>
<li><p>当前结点的父亲是红色，且它的爷爷结点的另一个结点(叔叔)也是红色：</p>
<ul>
<li><p>把父结点设为黑色</p>
</li>
<li><p>把叔叔结点设为黑色</p>
</li>
<li><p>把爷爷结点设为红色</p>
</li>
<li><p>把指针定位到爷爷节点继续往上分析变换规则</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>左旋</p>
<ul>
<li>当前父节点是红色，叔叔是黑色的时候，且当前的结点是右子树，左旋以父结点左旋</li>
</ul>
</li>
<li><p>右旋</p>
<ul>
<li>当前父结点是红色，叔叔是黑色的时候，且当前节点是左子树：<ul>
<li>把父点变成黑色</li>
<li>把爷爷节点变成红色</li>
<li>以爷爷节点进行右旋</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
</li>
</ul>
<ul>
<li>hash方法：将hashcode()计算出来的值右移16位，再和原来的数进行异或<ul>
<li>为什么要这样做：混合后，低位掺杂了高位的特性，保留高位的特征，加大低位的随机性；hashcode()可能被重写，不一定可以保证随机性</li>
</ul>
</li>
</ul>
<h4 id="HashMap-的长度为什么是-2-的幂次方"><a href="#HashMap-的长度为什么是-2-的幂次方" class="headerlink" title="HashMap 的长度为什么是 2 的幂次方"></a>HashMap 的长度为什么是 2 的幂次方</h4><ul>
<li>由于hash值的范围很大，在使用之前需要对数组的长度取模，得到的余数才能用来要存放的位置也就是对应的数组下标。这个数组下标的计算方法是 <code>(n - 1) &amp; hash</code>。（n 代表数组长度）。这也就解释了 HashMap 的长度为什么是 2 的幂次方</li>
<li><strong>取余(%)操作中如果除数是 2 的幂次则等价于与其除数减一的与(&amp;)操作（也就是说 hash%length==hash&amp;(length-1)的前提是 length 是 2 的 n 次方）</strong>。采用二进制位操作 &amp;，相对于%能够提高运算效率，这就解释了 HashMap 的长度为什么是 2 的幂次方</li>
</ul>
<h4 id="HashMap多线程操作导致死循环"><a href="#HashMap多线程操作导致死循环" class="headerlink" title="HashMap多线程操作导致死循环"></a>HashMap多线程操作导致死循环</h4><ul>
<li><p>在并发编程下，HashMap线程不安全，在Rehash的时候可能会出现循环链表，jdk8已经解决</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://coolshell.cn/articles/9606.html">源码图文分析</a></p>
</blockquote>
</li>
</ul>
<h4 id="ConcurrentHashMap和HashTable区别"><a href="#ConcurrentHashMap和HashTable区别" class="headerlink" title="ConcurrentHashMap和HashTable区别"></a>ConcurrentHashMap和HashTable区别</h4><ul>
<li><strong>底层数据结构：</strong> <code>ConcurrentHashMap</code> JDK1.8 采用的数据结构跟 <code>HashMap1.8</code> 的结构一样，数组+链表/红黑二叉树。<code>Hashtable</code> 和 JDK1.8 之前的 <code>HashMap</code> 的底层数据结构类似都是采用 <strong>数组+链表</strong> 的形式</li>
<li><strong>实现线程安全的方式：</strong> <ul>
<li><strong>在 JDK1.7 的时候，<code>ConcurrentHashMap</code>（分段锁）</strong> 对整个桶数组进行了分割分段(<code>Segment</code>)，每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。 <strong>到了 JDK1.8 的时候已经摒弃了 <code>Segment</code> 的概念，而是直接用 <code>Node</code> 数组+链表+红黑树的数据结构来实现，并发控制使用 <code>synchronized</code> 和 CAS 来操作。（JDK1.6 以后 对 <code>synchronized</code> 锁做了很多优化）</strong> 整个看起来就像是优化过且线程安全的 <code>HashMap</code>，虽然在 JDK1.8 中还能看到 <code>Segment</code> 的数据结构，但是已经简化了属性，只是为了兼容旧版本</li>
<li><strong><code>Hashtable</code>(同一把锁)</strong> :使用 <code>synchronized</code> 来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用 put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低。</li>
<li><strong>总的来说，<code>HashTable</code>使用的是全表锁，JDK1.7的<code>ConcurrentHashMap</code>使用<code>Segment</code>分段锁，JDK1.8之后的<code>ConcurrentHashMap</code>使用Node数组+链表/红黑树，红黑树情况使用TreeNode</strong></li>
</ul>
</li>
</ul>
<h4 id="ConcurrentHashMap线程安全具体实现方法"><a href="#ConcurrentHashMap线程安全具体实现方法" class="headerlink" title="ConcurrentHashMap线程安全具体实现方法"></a>ConcurrentHashMap线程安全具体实现方法</h4><ul>
<li>JDK7，首先将数据分为一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据时，其他段的数据也能被其他线程访问。Segment 实现了 <code>ReentrantLock</code>,所以 <code>Segment</code> 是一种可重入锁，扮演锁的角色。</li>
<li>JDK8，<code>ConcurrentHashMap</code> 取消了 <code>Segment</code> 分段锁，采用 CAS 和 <code>synchronized</code> 来保证并发安全。<code>synchronized</code> 只锁定当前链表或红黑二叉树的首节点，这样只要 hash 不冲突，就不会产生并发。</li>
</ul>
<h4 id="ConcurrentHashMap底层实现"><a href="#ConcurrentHashMap底层实现" class="headerlink" title="ConcurrentHashMap底层实现"></a>ConcurrentHashMap底层实现</h4><ul>
<li><p>JDK1.7，<strong>Segment 数组 + HashEntry 数组 + 链表</strong>，使用<code>segment</code>分段锁实现并发，每一个segment类似HashMap的结构，在每个segment内部可以进行扩容，但是segment的个数不能改变，也就是并发的线程个数无法扩容。</p>
<ul>
<li><p>默认容量16，负载因子0.75，并发级别(segment个数)16</p>
</li>
<li><p>并发级别高于2^16时，会被强制设置为65536，同时在进行初始化时，会将并发级别设置为不超过设定值的最大2的倍数</p>
</li>
<li><p>每个segment的容量也必须是2的倍数</p>
</li>
<li><p>记录 segmentShift 偏移量，这个值为【容量 = 2 的N次方】中的 N，在后面 Put 时计算位置时会用到。<strong>默认是 32 - sshift = 28</strong>.</p>
</li>
<li><p>记录 segmentMask，默认是 ssize - 1 = 16 -1 = 15</p>
</li>
<li><p><code>put</code>操作：</p>
<ul>
<li><p>计算要 put 的 key 的位置，获取指定位置的 Segment。</p>
</li>
<li><p>如果指定位置的 Segment 为空，则初始化这个 Segment.</p>
<ul>
<li><strong>初始化 Segment 流程：</strong><ol>
<li>检查计算得到的位置的 Segment 是否为null.</li>
<li>为 null 继续初始化，使用 Segment[0] 的容量和负载因子创建一个 HashEntry 数组。</li>
<li>再次检查计算得到的指定位置的 Segment 是否为null.</li>
<li>使用创建的 HashEntry 数组初始化这个 Segment.</li>
<li>自旋判断计算得到的指定位置的 Segment 是否为null，使用 CAS 在这个位置赋值为 Segment.</li>
</ol>
</li>
</ul>
</li>
<li><p>Segment.put 插入 key,value 值</p>
<ul>
<li><p>tryLock() 获取锁，获取不到使用 <strong><code>scanAndLockForPut</code></strong> 方法继续获取。</p>
</li>
<li><p>计算 put 的数据要放入的 index 位置，然后获取这个位置上的 HashEntry </p>
</li>
<li><p>如果这个位置上的 <strong>HashEntry 不存在</strong>：</p>
<ol>
<li>如果当前容量大于扩容阀值，小于最大容量，<strong>进行扩容</strong>。</li>
<li>直接头插法插入。</li>
</ol>
<p>如果这个位置上的 <strong>HashEntry 存在</strong>：</p>
<ol>
<li>判断链表当前元素 Key 和 hash 值是否和要 put 的 key 和 hash 值一致。一致则替换值</li>
<li>不一致，获取链表下一个节点，直到发现相同进行值替换，或者链表表里完毕没有相同的。<ol>
<li>如果当前容量大于扩容阀值，小于最大容量，<strong>进行扩容</strong>。</li>
<li>直接链表头插法插入。</li>
</ol>
</li>
</ol>
</li>
<li><p>如果要插入的位置之前已经存在，替换后返回旧值，否则返回 null</p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>自旋获得锁时，如果尝试获取锁超过了一定次数，直接阻塞，直到获得锁</p>
</blockquote>
</li>
</ul>
</li>
<li><p>扩容<code>rehash</code>：ConcurrentHashMap 的扩容只会扩容到原来的两倍。老数组里的数据移动到新的数组时，位置要么不变，要么变为 index+ oldSize，参数里的 node 会在扩容之后使用链表<strong>头插法</strong>插入到指定位置</p>
</li>
<li><p>JDK1.8，<strong>Node 数组 + 链表 / 红黑树</strong></p>
<ul>
<li><p>ConcurrentHashMap 的初始化是通过<strong>自旋和 CAS</strong> 操作完成的，需要注意的是变量 <code>sizeCtl</code> ，它的值决定着当前的初始化状态</p>
<ol>
<li>-1 说明正在初始化</li>
<li>-N 说明有N-1个线程正在进行扩容</li>
<li>表示 table 初始化大小，如果 table 没有初始化</li>
<li>表示 table 容量，如果 table　已经初始化</li>
</ol>
</li>
<li><p><code>put</code>方法：</p>
<ul>
<li>根据 key 计算出 hashcode 。</li>
<li>判断是否需要进行初始化。</li>
<li>即为当前 key 定位出的 Node，如果为空表示当前位置可以写入数据，利用 CAS 尝试写入，失败则自旋保证成功。</li>
<li>如果当前位置的 <code>hashcode == MOVED == -1</code>,则需要进行扩容。</li>
<li>如果都不满足，则利用 synchronized 锁写入数据。</li>
<li>如果数量大于 <code>TREEIFY_THRESHOLD</code> 则要执行树化方法，在treeifyBin中会首先判断当前数组长度≥64时才会将链表转换为红黑树。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="Hash冲突解决方案"><a href="#Hash冲突解决方案" class="headerlink" title="Hash冲突解决方案"></a>Hash冲突解决方案</h4><ul>
<li>链地址法：使用链表和红黑树</li>
<li>线性探测再散列：线性向后探索，直到找到下一个空节点</li>
<li>再哈希法：多个hash函数，直到不冲突</li>
<li>建立公共溢出区：将哈希表分为基本表和溢出表，相当于使用多个哈希表</li>
</ul>
<h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><h3 id="为什么程序计数器、虚拟机栈和本地方法栈是线程私有的？"><a href="#为什么程序计数器、虚拟机栈和本地方法栈是线程私有的？" class="headerlink" title="为什么程序计数器、虚拟机栈和本地方法栈是线程私有的？"></a>为什么程序计数器、虚拟机栈和本地方法栈是线程私有的？</h3><ul>
<li><p><strong>程序计数器主要有下面两个作用</strong>：</p>
<ol>
<li>通过改变程序计数器来依次读取指令，从而实现代码的流程控制，</li>
<li>记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该从哪里开始运行</li>
</ol>
<p>需要注意的是，如果执行的是 native 方法，那么程序计数器记录的是 undefined 地址，只有执行的是 Java 代码时程序计数器记录的才是下一条指令的地址。</p>
<p>所以，程序计数器私有主要是为了<strong>线程切换后能恢复到正确的执行位置</strong></p>
</li>
<li><p>为了<strong>保证线程中的局部变量不被别的线程访问到</strong>，虚拟机栈和本地方法栈是线程私有的。</p>
<ul>
<li><p><strong>虚拟机栈：</strong> 每个 Java 方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至执行完成的过程，就对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程</p>
</li>
<li><p><strong>本地方法栈：</strong> 和虚拟机栈所发挥的作用非常相似，区别是： <strong>虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。</strong> 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一</p>
</li>
</ul>
</li>
</ul>
<h3 id="为什么要使用多线程？"><a href="#为什么要使用多线程？" class="headerlink" title="为什么要使用多线程？"></a>为什么要使用多线程？</h3><ul>
<li><p>先从总体上来说：</p>
<ul>
<li><strong>从计算机底层来说：</strong> 线程可以比作是轻量级的进程，是程序执行的最小单位,线程间的切换和调度的成本远远小于进程。另外，多核 CPU 时代意味着多个线程可以同时运行，这减少了线程上下文切换的开销。</li>
<li><strong>从当代互联网发展趋势来说：</strong>多线程并发编程是开发高并发系统的基础，利用好多线程机制可以大大提高系统整体的并发能力以及性能。</li>
</ul>
</li>
<li><p>再深入到计算机底层来探讨：</p>
<ul>
<li><strong>单核时代</strong>： <strong>在单核时代多线程主要是为了提高单进程利用 CPU 和 IO 系统的效率</strong>。 假设只运行了一个 Java 进程的情况，当我们请求 IO 的时候，如果 Java 进程中只有一个线程，此线程被 IO 阻塞则整个进程被阻塞。CPU 和 IO 设备只有一个在运行，那么可以简单地说系统整体效率只有 50%。当使用多线程的时候，一个线程被 IO 阻塞，其他线程还可以继续使用 CPU。从而提高了 Java 进程利用系统资源的整体效率。</li>
<li><strong>多核时代</strong>: <strong>多核时代多线程主要是为了提高进程利用多核 CPU 的能力</strong>。举个例子：假如我们要计算一个复杂的任务，我们只用一个线程的话，不论系统有几个 CPU 核心，都只会有一个 CPU 核心被利用到。而创建多个线程，这些线程可以被映射到底层多个 CPU 上执行，在任务中的多个线程没有资源竞争的情况下，任务执行的效率会有显著性的提高，约等于（单核时执行时间/CPU 核心数）。</li>
</ul>
</li>
</ul>
<h3 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h3><ul>
<li><strong>NEW（新建）</strong>：线程被创建之后处于的状态</li>
<li><strong>RUNNABLE（运行中）</strong>：NEW状态之后，调用<code>start()</code>方法后处于的状态，其实包含了两种状态<ul>
<li>READY(就绪)：调用<code>start()</code>方法后，处于的状态</li>
<li>RUNNING(运行)：线程获得CPU时间片之后，真正开始运行处于的状态</li>
<li><strong>JVM中不区分这两种状态</strong>：现在的操作系统架构导致每个线程最多一次在CPU上运行10-20ms，之后又会放到调度队列末尾再次调度，切换得太快，区分这两种状态没有意义</li>
</ul>
</li>
<li>**WAITING(等待)、TIMED_WAITING(超时等待)**：执行<code>wait()</code>方法后进入等待状态，如果加入了超时限制，就进入超时等待状态<ul>
<li>超时时间达到后，线程会返回到RUNNABLE状态</li>
</ul>
</li>
<li>**BLOCKED(阻塞)**：当线程调用同步方法，没有获得锁时，进入的状态</li>
<li>**TERMINATERD(终止)**：线程<code>run()</code>方法执行结束进入的状态</li>
</ul>
<p><img src="/2022/01/03/day29/day29_4.png" alt="Java 线程状态变迁"></p>
<h3 id="什么是死锁，产生死锁的条件"><a href="#什么是死锁，产生死锁的条件" class="headerlink" title="什么是死锁，产生死锁的条件"></a>什么是死锁，产生死锁的条件</h3><ul>
<li><p>死锁：两个线程分别都持有一个资源，同时都想要得到对方的资源，导致两个线程都阻塞</p>
</li>
<li><p>产生死锁的条件：</p>
<ul>
<li>互斥条件：该资源任意一个时刻只由一个线程占用。</li>
<li>请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。</li>
<li>不剥夺条件:线程已获得的资源在未使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。</li>
<li>循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系</li>
</ul>
</li>
</ul>
<h3 id="如何避免死锁"><a href="#如何避免死锁" class="headerlink" title="如何避免死锁"></a>如何避免死锁</h3><ul>
<li>破坏产生四个产生条件的其中一个</li>
<li>使用banker算法分配资源，使系统进入安全状态<ul>
<li>寻找安全序列：<ul>
<li>假设进程需要最多的资源</li>
<li>寻找使用空闲资源能够满足的进程（找不到进程，非安全状态）</li>
<li>释放该进程的资源</li>
<li>继续寻找进程</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="sleep和wait方法区别和共同点"><a href="#sleep和wait方法区别和共同点" class="headerlink" title="sleep和wait方法区别和共同点"></a>sleep和wait方法区别和共同点</h3><ul>
<li>两者最主要的区别在于：**<code>sleep()</code> 方法没有释放锁，而 <code>wait()</code> 方法释放了锁** 。</li>
<li>两者都可以暂停线程的执行。</li>
<li><code>wait()</code> 通常被用于线程间交互/通信，<code>sleep() </code>通常被用于暂停执行。</li>
<li><code>wait()</code> 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 <code>notify() </code>或者 <code>notifyAll()</code> 方法。<code>sleep() </code>方法执行完成后，线程会自动苏醒。或者可以使用 <code>wait(long timeout)</code> 超时后线程会自动苏醒。</li>
</ul>
<h3 id="为什么我们调用-start-方法时会执行-run-方法，为什么我们不能直接调用-run-方法？"><a href="#为什么我们调用-start-方法时会执行-run-方法，为什么我们不能直接调用-run-方法？" class="headerlink" title="为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run() 方法？"></a>为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run() 方法？</h3><ul>
<li><p>new 一个 Thread，线程进入了新建状态。调用 <code>start()</code>方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。 <code>start()</code> 会执行线程的相应准备工作，然后自动执行 <code>run()</code> 方法的内容，这是真正的多线程工作。 </p>
</li>
<li><p>直接执行 <code>run()</code> 方法，会把 <code>run()</code> 方法当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。</p>
</li>
<li><p><strong>总结： 调用 <code>start()</code> 方法方可启动线程并使线程进入就绪状态，直接执行 <code>run()</code> 方法的话不会以多线程的方式执行</strong></p>
</li>
</ul>
<h3 id="synchronized关键字"><a href="#synchronized关键字" class="headerlink" title="synchronized关键字"></a>synchronized关键字</h3><ul>
<li><p>在 Java 早期版本中，<code>synchronized</code> 属于 <strong>重量级锁</strong>，效率低下。因为监视器锁（monitor）是依赖于底层的操作系统的 <code>Mutex Lock</code> 来实现的，Java 的线程是映射到操作系统的原生线程之上的。如果要挂起或者唤醒一个线程，都需要操作系统帮忙完成，而操作系统实现线程之间的切换时需要从<strong>用户态转换到内核态</strong>，这个状态之间的转换需要相对比较长的时间，时间成本相对较高</p>
</li>
<li><p><strong>三种主要使用方式</strong>：</p>
<ul>
<li>修饰实例方法：相当于对当前对象加锁，进入同步代码前需要获得当前实例对象的锁</li>
<li>修饰静态方法：相当于对当前类加锁，进入同步代码前需要获得当前类的锁<ul>
<li>允许一个线程调用一个实例对象的非静态同步方法，同时另一个线程调用静态同步方法，因为获得的锁不同</li>
</ul>
</li>
<li>修饰代码块：指定加锁对象，对给定对象/类加锁。<code>synchronized(this|object)</code> 表示进入同步代码库前要获得<strong>给定对象的锁</strong>。<code>synchronized(类.class)</code> 表示进入同步代码前要获得 <strong>当前 class 的锁</strong></li>
<li>对于具有缓存功能的对象，尽量不使用synchronized加锁，例如尽量不使用sychronized(String s)，可能会导致线程不执行</li>
</ul>
</li>
<li><p><strong>构造方法不能被synchronized关键字修饰，因为构造方法本身就是线程安全的</strong>，对象还未产生，就不存在加不加锁的问题</p>
</li>
<li><p>双重检验锁方式实现单例模式：</p>
<ul>
<li><p><code>uniqueInstance</code> 采用 <code>volatile</code> 关键字修饰也是很有必要，对象创建其实分为三步：</p>
<ul>
<li>为 <code>uniqueInstance</code> 分配内存空间</li>
<li>初始化 <code>uniqueInstance</code></li>
<li>将 <code>uniqueInstance</code> 指向分配的内存地址</li>
</ul>
<p>volatile可以防止指令重排，在多线程情况下可以保证获得的单例模式对象不为空</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton uniqueInstance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">static</span> Singleton <span class="title">getUniqueInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">//先判断对象是否已经实例过，没有实例化过才进入加锁代码</span></span><br><span class="line">        <span class="keyword">if</span> (uniqueInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//类对象加锁</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (uniqueInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    uniqueInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="synchronized底层原理"><a href="#synchronized底层原理" class="headerlink" title="synchronized底层原理"></a>synchronized底层原理</h3><ul>
<li>修饰同步代码块：<code>synchronized</code> 同步语句块的实现使用的是 <code>monitorenter</code> 和 <code>monitorexit</code> 指令，其中 <code>monitorenter</code> 指令指向同步代码块的开始位置，<code>monitorexit</code> 指令则指明同步代码块的结束位置。<ul>
<li>在 Java 虚拟机(HotSpot)中，Monitor 是基于 C++实现的，由ObjectMonitor实现的。每个对象中都内置了一个 <code>ObjectMonitor</code>对象</li>
<li>在执行<code>monitorenter</code>时，会尝试获取对象的锁，如果锁的计数器为 0 则表示锁可以被获取，获取后将锁计数器设为 1 也就是加 1</li>
<li>对象锁的的拥有者线程才可以执行 <code>monitorexit</code> 指令来释放锁。在执行 <code>monitorexit</code> 指令后，将锁计数器设为 0，表明锁被释放，其他线程可以尝试获取锁</li>
<li>如果获取对象锁失败，那当前线程就要阻塞等待，直到锁被另外一个线程释放为止</li>
</ul>
</li>
<li>修饰方法：<code>synchronized</code> 修饰的方法并没有 <code>monitorenter</code> 指令和 <code>monitorexit</code> 指令，取得代之的确实是 <code>ACC_SYNCHRONIZED</code> 标识，该标识指明了该方法是一个同步方法。JVM 通过该 <code>ACC_SYNCHRONIZED</code> 访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用。<ul>
<li>如果是实例方法，JVM 会尝试获取实例对象的锁。如果是静态方法，JVM 会尝试获取当前 class 的锁</li>
</ul>
</li>
</ul>
<h3 id="JDK1-6-之后的-synchronized-关键字底层做了哪些优化"><a href="#JDK1-6-之后的-synchronized-关键字底层做了哪些优化" class="headerlink" title="JDK1.6 之后的 synchronized 关键字底层做了哪些优化"></a>JDK1.6 之后的 synchronized 关键字底层做了哪些优化</h3><ul>
<li><p>JDK1.6 对锁的实现引入了大量的优化，如偏向锁、轻量级锁、自旋锁、适应性自旋锁、锁消除、锁粗化等技术来减少锁操作的开销</p>
<ul>
<li><code>自旋锁</code>：对于锁状态很短的线程，挂起和恢复线程是开销很大的，因此让线程执行一个忙等待（自旋），这就是自旋锁的技术</li>
<li><code>自适应锁</code>：本质还是自旋锁，如果上次通过自旋获得了锁，这次可以等待时间长一些，否则，等待时间变短</li>
<li><code>锁消除</code>：方法体中的所有数据都不会逃逸出去，是线程私有的，可以不使用锁</li>
<li><code>锁粗化</code>：频繁获得锁释放锁很消耗资源，可以将锁的范围扩大</li>
</ul>
</li>
<li><p>锁主要存在四种状态，依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态。注意锁可以升级不可降级，这种策略是为了提高获得锁和释放锁的效率。</p>
</li>
<li><p>锁的升级：</p>
<ul>
<li><p><strong>偏向锁</strong>：有竞争才释放锁。某个线程持有当前锁后，当前java对象头会存储锁偏向的线程ID。没有竞争的情况下，相同线程下次再获得相同的锁，不需要使用CAS进行竞争，也不用释放。</p>
<ul>
<li><strong>偏向锁释放</strong>：如果有其他线程竞争锁，偏向锁的释放需要等到全局安全点（没有正在执行的字节码）。首先暂停持有锁的线程，其次检测该线程是否活着，如果死亡，则将对象头设置为无锁状态；如果活着，遍历偏向对象的锁记录，修改对象头和栈中的锁记录，要么偏向于另一个线程，要么恢复无锁，要么标记对象不适合作为偏向锁</li>
</ul>
</li>
<li><p><strong>轻量级锁</strong>：将对象头中的Mark Word赋值记录到栈帧的锁记录中，使用CAS修改对象头，获得锁。如果有其他线程竞争锁，当前线程没有释放锁的情况下，其他线程会通过自旋来获得锁。当前线程释放锁时，会再次使用CAS将保存的对象头信息重新写入对象头。</p>
</li>
<li><p><strong>轻量级锁升级</strong>：长时间自旋导致CPU消耗，CAS自旋10次还未获得锁；竞争的线程超过CPU核数的一半。自动升级为重量级锁</p>
</li>
<li><p><strong>重量级锁</strong>：竞争的线程较多，阻塞所有等待竞争的线程，防止CPU空转，阻塞等待线程释放锁后进入无锁状态重新竞争</p>
<ul>
<li>线程在进入Contention List时阻塞等待之前，程会先尝试自旋使用CAS操作获取锁，如果获取不到就进入Contention List队列的尾部</li>
<li>Owner线程在解锁时，如果Entry List为空，那么会<strong>先将Contention List中队列尾部的部分线程移动到Entry List</strong></li>
<li>Owner线程在解锁时，如果Entry List不为空，从Entry List中取一个线程，让它成为OnDeck线程，Owner线程并不直接把锁传递给OnDeck线程，而是把<strong>锁竞争</strong>的权利交给OnDeck，OnDeck需要重新竞争锁，JVM中这种选择行为称为 “竞争切换”。（<strong>主要是与还没有进入到ContentionList，还在自旋获取重量级锁的线程竞争</strong>）</li>
<li>OnDeck线程获取到锁，成为Owner线程进行执行。</li>
</ul>
</li>
<li><p>Owner线程调用锁对象的wait（）方法进行等待，会移动到Wait Set中，并且会释放CPU资源，也同时释放锁，</p>
<ul>
<li>当其他线程调用锁对象的notify（）方法，之前调用wait方法等待的这个线程才会从Wait Set移动到Entry List，等待获取锁</li>
</ul>
<p><img src="/2022/01/03/day29/day29_28.png" alt="重量级锁"></p>
</li>
</ul>
</li>
</ul>
<h3 id="为什么JDK8在4s之后才开启偏向锁？"><a href="#为什么JDK8在4s之后才开启偏向锁？" class="headerlink" title="为什么JDK8在4s之后才开启偏向锁？"></a>为什么JDK8在4s之后才开启偏向锁？</h3><ul>
<li>代码刚执行时，一定有很多线程来竞争锁，开启了偏向锁反而效率低</li>
</ul>
<h3 id="synchronized-和-ReentrantLock-的区别"><a href="#synchronized-和-ReentrantLock-的区别" class="headerlink" title="synchronized 和 ReentrantLock 的区别"></a>synchronized 和 ReentrantLock 的区别</h3><ul>
<li><p>两者都是可重入锁：<strong>“可重入锁”</strong> 指的是自己可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果不可锁重入的话，就会造成死锁。<strong>同一个线程每次获取锁，锁的计数器都自增 1，所以要等到锁的计数器下降为 0 时才能释放锁。</strong></p>
</li>
<li><p>synchronized 依赖于 JVM 而 ReentrantLock 依赖于 API：<code>synchronized</code> 是依赖于 JVM 实现的，优化都是在虚拟机层面实现的，并没有直接暴露给我们。<code>ReentrantLock</code> 是 JDK 层面实现的（也就是 API 层面，需要 lock() 和 unlock() 方法配合 try/finally 语句块来完成）。</p>
</li>
<li><p>发生异常时，synchronized会自动释放锁，ReetrantLock需要开发者手动释放</p>
</li>
<li><p>ReentrantLock 比 synchronized 增加了一些高级功能：</p>
<ul>
<li><strong>等待可中断</strong> : <code>ReentrantLock</code>提供了一种能够中断等待锁的线程的机制，通过<code>lock.lockInterruptibly()</code> 来实现这个机制。也就是说正在等待的线程可以选择放弃等待，改为处理其他事情。</li>
<li><strong>可实现公平锁</strong> : <code>ReentrantLock</code>可以指定是公平锁还是非公平锁。而<code>synchronized</code>只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。<code>ReentrantLock</code>默认情况是非公平的，可以通过 <code>ReentrantLock</code>类的<code>ReentrantLock(boolean fair)</code>构造方法来制定是否是公平的。</li>
<li><strong>可实现选择性通知（锁可以绑定多个条件）</strong>: <code>ReentrantLock</code>类可以实现对指定线程的通知唤醒，但是需要借助于<code>Condition</code>接口与<code>newCondition()</code>方法。</li>
</ul>
<blockquote>
<p><code>Condition</code>是 JDK1.5 之后才有的，它具有很好的灵活性，比如可以实现多路通知功能也就是在一个<code>Lock</code>对象中可以创建多个<code>Condition</code>实例（即对象监视器），<strong>线程对象可以注册在指定的<code>Condition</code>中，从而可以有选择性的进行线程通知，在调度线程上更加灵活。 在使用<code>notify()/notifyAll()</code>方法进行通知时，被通知的线程是由 JVM 选择的，用<code>ReentrantLock</code>类结合<code>Condition</code>实例可以实现“选择性通知”</strong> 。而<code>synchronized</code>关键字就相当于整个 Lock 对象中只有一个<code>Condition</code>实例，所有的线程都注册在它一个身上。如果执行<code>notifyAll()</code>方法的话就会通知所有处于等待状态的线程这样会造成很大的效率问题，而<code>Condition</code>实例的<code>signalAll()</code>方法 只会唤醒注册在该<code>Condition</code>实例中的所有等待线程。</p>
</blockquote>
</li>
</ul>
<h3 id="并发编程的三个重要特性"><a href="#并发编程的三个重要特性" class="headerlink" title="并发编程的三个重要特性"></a>并发编程的三个重要特性</h3><ul>
<li><p><strong>原子性</strong> : 一个的操作或者多次操作，要么所有的操作全部都得到执行并且不会受到任何因素的干扰而中断，要么所有的操作都执行，要么都不执行。<code>synchronized</code> 可以保证代码片段的原子性。</p>
</li>
<li><p><strong>可见性</strong> ：当一个线程对共享变量进行了修改，那么另外的线程都是立即可以看到修改后的最新值。<code>volatile</code> 关键字可以保证共享变量的可见性。</p>
</li>
<li><p><strong>有序性</strong> ：代码在执行的过程中的先后顺序，Java 在编译器以及运行期间的优化，代码的执行顺序未必就是编写代码时候的顺序。<code>volatile</code> 关键字可以禁止指令进行重排序优化。</p>
</li>
</ul>
<h3 id="volatile和synchronized关键字区别"><a href="#volatile和synchronized关键字区别" class="headerlink" title="volatile和synchronized关键字区别"></a>volatile和synchronized关键字区别</h3><ul>
<li><p><code>volatile</code> 关键字 除了防止 JVM 的指令重排 ，还有一个重要的作用就是保证变量的可见性</p>
<blockquote>
<p>volatile：将数据写入系统内存。采用缓存一致性协议，其他cpu在使用缓存数据时会进行嗅探，如果发现自己的缓存行地址对应的内存地址发生变换，则缓存无效</p>
<p>读取共享变量时，会先清空本地内存的变量值，再从主内存中获取最新值</p>
<p>写入共享变量时，会直接写到主内存中，而且会导致其他线程的缓存无效</p>
</blockquote>
</li>
<li><p><strong><code>volatile</code> 关键字</strong>是线程同步的<strong>轻量级实现</strong>，所以 <strong><code>volatile </code>性能肯定比<code>synchronized</code>关键字要好</strong> 。但是 <strong><code>volatile</code> 关键字只能用于变量而 <code>synchronized</code> 关键字可以修饰方法以及代码块</strong> </p>
</li>
<li><p><strong><code>volatile</code> 关键字能保证数据的可见性，但不能保证数据的原子性。<code>synchronized</code> 关键字两者都能保证。</strong></p>
</li>
<li><p>volatile是非阻塞的，synchronized阻塞</p>
</li>
<li><p><strong><code>volatile</code>关键字主要用于解决变量在多个线程之间的可见性，而 <code>synchronized</code> 关键字解决的是多个线程之间访问资源的同步性。</strong></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实现单例模式，线程安全</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton singleton = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(singleton == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Singleton.class)&#123;</span><br><span class="line">                <span class="keyword">if</span>(singleton ==<span class="keyword">null</span>) &#123;</span><br><span class="line">                    singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="ThreadLocal原理"><a href="#ThreadLocal原理" class="headerlink" title="ThreadLocal原理"></a>ThreadLocal原理</h3><ul>
<li><p>访问<code>ThreadLocal</code>变量的每个线程都会有这个变量的本地副本。他们可以使用 <code>get（）</code> 和 <code>set（）</code> 方法来获取默认值或将其值更改为当前线程所存的副本的值，从而避免了线程安全问题</p>
</li>
<li><p>最终的变量是放在了当前线程的 <code>ThreadLocalMap</code> 中，并不是存在 <code>ThreadLocal</code> 上，<code>ThreadLocal</code> 可以理解为只是<code>ThreadLocalMap</code>的封装，传递了变量值。<code>ThrealLocal</code> 类中可以通<code>Thread.currentThread()</code>获取到当前线程对象后，直接通过<code>getMap(Thread t)</code>可以访问到该线程的<code>ThreadLocalMap</code>对象，每个<code>Thread</code>中都具备一个<code>ThreadLocalMap</code>，而<code>ThreadLocalMap</code>可以存储以<code>ThreadLocal</code>为 key ，Object 对象为 value 的键值对</p>
<p><img src="/2022/01/03/day29/day29_5.png" alt="ThreadLocal数据结构"></p>
</li>
</ul>
<h3 id="ThreadLocal-内存泄露问题"><a href="#ThreadLocal-内存泄露问题" class="headerlink" title="ThreadLocal 内存泄露问题"></a>ThreadLocal 内存泄露问题</h3><ul>
<li><p><code>ThreadLocalMap</code> 中使用的 <strong>key 为 <code>ThreadLocal</code> 的弱引用</strong>,而 value 是强引用。所以，如果 <code>ThreadLocal</code> 没有被外部强引用的情况下，在垃圾回收的时候，key 会被清理掉，而 value 不会被清理掉。这样一来，<code>ThreadLocalMap</code> 中就会出现 key 为 null 的 Entry。假如我们不做任何措施的话，value 永远无法被 GC 回收，这个时候就可能会产生内存泄露。ThreadLocalMap 实现中已经考虑了这种情况，在调用 <code>set()</code>、<code>get()</code>、<code>remove()</code> 方法的时候，会清理掉 key 为 null 的记录。使用完 <code>ThreadLocal</code>方法后 最好手动调用<code>remove()</code>方法</p>
<blockquote>
<p>为什么要把key设计为弱引用？</p>
<p>当我们在外部将ThreadLocal变量的强引用设置为null时，Entry中的ThreadLocal理应被回收，如果设置为强引用就无法被回收</p>
</blockquote>
</li>
</ul>
<h3 id="ThreadLocalMap"><a href="#ThreadLocalMap" class="headerlink" title="ThreadLocalMap"></a>ThreadLocalMap</h3><ul>
<li>类似HashMap，但底层数据结构只是数组</li>
<li>threadLocalHashCode的计算，采用黄金分割数，每创建一个ThreadLocal对象就加1，hash分布很均匀</li>
<li>采用线性探测法处理hash冲突，线性探测遇到过期的数据时，会进行数据清理<ul>
<li>探测式数据清理：以当前Entry 向后迭代查找，遇到为null则结束清理，遇到entry为空的值，清空数组位置，size–。非空的entry计算重哈希的位置</li>
<li>启发性清理：向后递归查找一个过期的位置，找到过期的位置触发探测性清理</li>
</ul>
</li>
</ul>
<h3 id="线程池的好处"><a href="#线程池的好处" class="headerlink" title="线程池的好处"></a>线程池的好处</h3><ul>
<li><strong>降低资源消耗</strong>。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li>
<li><strong>提高响应速度</strong>。当任务到达时，任务可以不需要等到线程创建就能立即执行。</li>
<li><strong>提高线程的可管理性</strong>。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li>
</ul>
<h3 id="线程池的状态"><a href="#线程池的状态" class="headerlink" title="线程池的状态"></a>线程池的状态</h3><p><img src="/2022/01/03/day29/day29_27.png" alt="线程池状态"></p>
<ul>
<li><p><code>RUNNING</code>：线程池处在RUNNING状态时，能够接收新任务，以及对已添加的任务进行处理。线程池一被创建就处于RUNNING状态</p>
</li>
<li><p><code>SHUTDOWN</code>：线程池处在SHUTDOWN状态时，不接收新任务，但能处理已添加的任务</p>
<ul>
<li>调用线程池的shutdown()接口时，线程池由RUNNING -&gt; SHUTDOWN</li>
</ul>
</li>
<li><p><code>STOP</code>：线程池处在STOP状态时，不接收新任务，不处理已添加的任务，并且会中断正在处理的任务</p>
<ul>
<li>调用线程池的shutdownNow()接口时，线程池由(RUNNING or SHUTDOWN ) -&gt; STOP。</li>
</ul>
</li>
<li><p><code>TIDYING</code>：当所有的任务已终止，ctl记录的”任务数量”为0，线程池会变为TIDYING状态</p>
<ul>
<li>当线程池在SHUTDOWN状态下，阻塞队列为空并且线程池中执行的任务也为空时，就会由 SHUTDOWN -&gt; TIDYING。当线程池在STOP状态下，线程池中执行的任务为空时，就会由STOP -&gt; TIDYING。</li>
</ul>
</li>
<li><p><code>TERMINATED</code>：线程池彻底终止，就变成TERMINATED状态</p>
<ul>
<li>线程池处在TIDYING状态时，执行完terminated()之后，就会由 TIDYING -&gt; TERMINATED</li>
</ul>
</li>
</ul>
<h3 id="实现-Runnable-接口和-Callable-接口的区别"><a href="#实现-Runnable-接口和-Callable-接口的区别" class="headerlink" title="实现 Runnable 接口和 Callable 接口的区别"></a>实现 Runnable 接口和 Callable 接口的区别</h3><ul>
<li><code>Runnable</code> 接口<em>不会返回结果或抛出检查异常，但是 <code>Callable</code> 接口</em>可以。所以，如果任务不需要返回结果或抛出异常推荐使用 <strong><code>Runnable</code> 接口</strong> 。</li>
</ul>
<h3 id="执行-execute-方法和-submit-方法的区别是什么呢？"><a href="#执行-execute-方法和-submit-方法的区别是什么呢？" class="headerlink" title="执行 execute()方法和 submit()方法的区别是什么呢？"></a>执行 execute()方法和 submit()方法的区别是什么呢？</h3><ul>
<li><code>execute()</code>方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功与否；</li>
<li><code>submit()</code>方法用于提交需要返回值的任务。线程池会返回一个 <code>Future</code> 类型的对象，通过这个 <code>Future</code> 对象可以判断任务是否执行成功，并且可以通过 <code>Future</code> 的 <code>get()</code>方法来获取返回值，<code>get()</code>方法会阻塞当前线程直到任务完成，而使用 <code>get(long timeout，TimeUnit unit)</code>方法则会阻塞当前线程一段时间后立即返回，这时候有可能任务没有执行完。</li>
</ul>
<h3 id="ThreadPoolExecutor参数分析"><a href="#ThreadPoolExecutor参数分析" class="headerlink" title="ThreadPoolExecutor参数分析"></a>ThreadPoolExecutor参数分析</h3><ul>
<li><strong><code>corePoolSize</code> :</strong> 核心线程数定义了最小可以同时运行的线程数量。</li>
<li><strong><code>maximumPoolSize</code> :</strong> 当队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。</li>
<li><strong><code>workQueue</code>:</strong> 当新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中</li>
<li><strong><code>keepAliveTime</code></strong>:当线程池中的线程数量大于 <code>corePoolSize</code> 的时候，如果这时没有新的任务提交，核心线程外的空闲线程不会立即销毁，而是会等待，直到等待的时间超过了 <code>keepAliveTime</code>才会被回收销毁；</li>
<li><strong><code>unit</code></strong> : <code>keepAliveTime</code> 参数的时间单位。</li>
<li><strong><code>threadFactory</code></strong> :executor 创建新线程的时候会用到。</li>
<li><strong><code>handler</code></strong> :饱和策略，同时运行的线程数量达到最大线程数量并且队列也已经被放满了任务，称为饱和<ul>
<li><strong><code>ThreadPoolExecutor.AbortPolicy</code>：</strong> 抛出 <code>RejectedExecutionException</code>来拒绝新任务的处理。</li>
<li><strong><code>ThreadPoolExecutor.CallerRunsPolicy</code>：</strong> 调用执行自己的线程运行任务，也就是直接在调用<code>execute</code>方法的线程中运行(<code>run</code>)被拒绝的任务，如果执行程序已关闭，则会丢弃该任务。因此这种策略会降低对于新任务提交速度，影响程序的整体性能。</li>
<li><strong><code>ThreadPoolExecutor.DiscardPolicy</code>：</strong> 不处理新任务，直接丢弃掉。</li>
<li><strong><code>ThreadPoolExecutor.DiscardOldestPolicy</code>：</strong> 此策略将丢弃最早的未处理的任务请求</li>
</ul>
</li>
</ul>
<p><img src="/2022/01/03/day29/day29_6.png" alt="线程池实现原理"></p>
<h3 id="FixedThreadPool、SingleThreadExecutor和CachedThreadPool"><a href="#FixedThreadPool、SingleThreadExecutor和CachedThreadPool" class="headerlink" title="FixedThreadPool、SingleThreadExecutor和CachedThreadPool"></a>FixedThreadPool、SingleThreadExecutor和CachedThreadPool</h3><ul>
<li><p><strong>FixedThreadPool</strong>：固定线程数的线程池，调用ThreadPoolExecutor实现</p>
<ul>
<li><code>FixedThreadPool</code> 使用无界队列 <code>LinkedBlockingQueue</code>（队列的容量为 Integer.MAX_VALUE）作为线程池的工作队列，任务较多时会出现OOM</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                       <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                       <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(),</span><br><span class="line">                       threadFactory);</span><br></pre></td></tr></table></figure></li>
<li><p><strong>SingleThreadExecutor</strong>：只有一个线程的线程池，同样也是使用无界队列作为线程池的工作队列</p>
</li>
<li><p><strong>CachedThreadPool</strong>：<code>corePoolSize</code>设置为0，<code>maximumPoolSize</code>设置为Integer.MAX_VALUE，无界</p>
<ul>
<li>如果任务的添加速度大于线程的处理速度，会不断创建线程，耗尽CPU资源</li>
</ul>
</li>
</ul>
<h3 id="Atomic原子类有哪些"><a href="#Atomic原子类有哪些" class="headerlink" title="Atomic原子类有哪些"></a>Atomic原子类有哪些</h3><ul>
<li><strong>基本类型</strong>：使用原子的方式更新基本类型<ul>
<li><code>AtomicInteger</code>：整形原子类</li>
<li><code>AtomicLong</code>：长整型原子类</li>
<li><code>AtomicBoolean</code>：布尔型原子类</li>
</ul>
</li>
<li><strong>数组类型</strong>：使用原子的方式更新数组里的某个元素<ul>
<li><code>AtomicIntegerArray</code>：整形数组原子类</li>
<li><code>AtomicLongArray</code>：长整形数组原子类</li>
<li><code>AtomicReferenceArray</code>：引用类型数组原子类</li>
</ul>
</li>
<li><strong>引用类型</strong><ul>
<li><code>AtomicReference</code>：引用类型原子类</li>
<li><code>AtomicStampedReference</code>：原子更新带有版本号的引用类型。该类将整数值与引用关联起来，可用于解决原子的更新数据和数据的版本号，可以解决使用 CAS 进行原子更新时可能出现的 ABA 问题。</li>
<li><code>AtomicMarkableReference</code> ：原子更新带有标记位的引用类型</li>
</ul>
</li>
<li><strong>对象的属性修改类型</strong>：原子更新某个类里的某个字段，更新的对象属性必须使用 public volatile 修饰符<ul>
<li><code>AtomicIntegerFieldUpdater</code>：原子更新整形字段的更新器</li>
<li><code>AtomicLongFieldUpdater</code>：原子更新长整形字段的更新器</li>
<li><code>AtomicReferenceFieldUpdater</code>：原子更新引用类型字段的更新器</li>
</ul>
</li>
</ul>
<h3 id="AtomicInteger-线程安全原理简单分析"><a href="#AtomicInteger-线程安全原理简单分析" class="headerlink" title="AtomicInteger 线程安全原理简单分析"></a>AtomicInteger 线程安全原理简单分析</h3><ul>
<li>AtomicInteger 类主要利用 CAS (compare and swap) + volatile 和 native 方法来保证原子操作，从而避免 synchronized 的高开销，执行效率大为提升。</li>
<li>CAS的原理是拿期望的值和原本的一个值作比较，如果相同则更新成新的值。UnSafe 类的 objectFieldOffset() 方法是一个本地方法，这个方法是用来拿到“原来的值”的内存地址，返回值是 valueOffset。另外 value 是一个volatile变量，在内存中可见，因此 JVM 可以保证任何时刻任何线程总能拿到该变量的最新值。</li>
</ul>
<h3 id="AQS原理"><a href="#AQS原理" class="headerlink" title="AQS原理"></a>AQS原理</h3><ul>
<li><strong>AQS 核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制 AQS 是用 CLH 队列锁实现的，即将暂时获取不到锁的线程加入到队列中。</strong></li>
</ul>
<p><img src="/2022/01/03/day29/day29_7.png" alt="AQS原理图"></p>
<ul>
<li>AQS 使用一个 <code>private volatile int</code> 成员变量来表示同步状态，通过内置的 FIFO 队列来完成获取资源线程的排队工作。AQS 使用 CAS 对该同步状态进行原子操作实现对其值的修改，控制线程的同步</li>
<li><strong>AQS 定义两种资源共享方式</strong></li>
<li>独占：只有一个线程能够获得资源，又分为公平锁和非公平锁<ul>
<li>共享：多个线程可同时执行，如<code> CountDownLatch</code>、<code>Semaphore</code>、 <code>CyclicBarrier</code>、<code>ReadWriteLock</code>等</li>
</ul>
</li>
<li><strong>AQS 底层使用了模板方法模式</strong></li>
</ul>
<h3 id="AQS-组件总结"><a href="#AQS-组件总结" class="headerlink" title="AQS 组件总结"></a>AQS 组件总结</h3><ul>
<li><strong><code>Semaphore</code>(信号量)-允许多个线程同时访问：</strong> <code>synchronized</code> 和 <code>ReentrantLock</code> 都是一次只允许一个线程访问某个资源，<code>Semaphore</code>(信号量)可以指定多个线程同时访问某个资源<ul>
<li>每次访问资源需要得到许可证，许可证的个数可以设置</li>
<li>支持公平和非公平模式</li>
</ul>
</li>
<li><strong><code>CountDownLatch </code>（倒计时器）：</strong> <code>CountDownLatch</code> 是一个同步工具类，用来协调多个线程之间的同步。这个工具通常用来控制线程等待，它可以让某一个线程等待直到倒计时结束，再开始执行。</li>
<li><strong><code>CyclicBarrier</code>(循环栅栏)：</strong> <code>CyclicBarrier</code> 和 <code>CountDownLatch</code> 非常类似，它也可以实现线程间的技术等待，但是它的功能比 <code>CountDownLatch</code> 更加复杂和强大。主要应用场景和 <code>CountDownLatch</code> 类似。<code>CyclicBarrier</code> 意思是可循环使用（<code>Cyclic</code>）的屏障（<code>Barrier</code>）。它要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活。<code>CyclicBarrier</code> 默认的构造方法是 <code>CyclicBarrier(int parties)</code>，其参数表示屏障拦截的线程数量，每个线程调用 <code>await()</code> 方法告诉 <code>CyclicBarrier</code> 我已经到达了屏障，然后当前线程被阻塞<ul>
<li><code>CyclicBarrier</code> 可以用于多线程计算数据，最后合并计算结果的应用场景</li>
</ul>
</li>
</ul>
<h3 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h3><ul>
<li><p><code>CopyOnWriteArrayList</code> 类的所有可变操作（add，set 等等）都是通过创建底层数组的新副本来实现的。当 List 需要被修改的时候，并不修改原有内容，而是对原有数据进行一次复制，将修改的内容写入副本。写完之后，再将修改完的副本替换原来的数据，这样就可以保证<strong>写操作不会影响读操作了，适合读多写少的场景</strong></p>
</li>
<li><p>写入操作：加锁后复制数组进行修改</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Appends the specified element to the end of this list.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e element to be appended to this list</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; (as specified by &#123;<span class="doctag">@link</span> Collection#add&#125;)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();<span class="comment">//加锁</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="keyword">int</span> len = elements.length;</span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);<span class="comment">//拷贝新数组</span></span><br><span class="line">        newElements[len] = e;</span><br><span class="line">        setArray(newElements);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();<span class="comment">//释放锁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Blocking-Queue"><a href="#Blocking-Queue" class="headerlink" title="Blocking Queue"></a>Blocking Queue</h3><ul>
<li><p>阻塞队列：被广泛使用在“生产者-消费者”问题中，其原因是 <code>BlockingQueue</code> 提供了可阻塞的插入和移除的方法。当队列容器已满，生产者线程会被阻塞，直到队列未满；当队列容器为空时，消费者线程会被阻塞，直至队列非空时为止</p>
</li>
<li><p><strong>ArrayBlockingQueue</strong>：有界队列实现，底层为数组。一旦创建，容量无法改变，插入取出操作都需要获得锁。队列容量满时，阻塞插入操作；队列为空时，阻塞取出操作。默认为非公平</p>
</li>
<li><p><strong>LinkedBlockingQueue</strong>：可以当做无界队列也可以当做有界队列来使用，同样满足 FIFO 的特性，底层为单向链表，吞吐量更大</p>
</li>
<li><p><strong>PriorityBlockingQueue</strong>：支持优先级的误解阻塞队列，可以指定初始容量。并发控制采用ReentrantLock</p>
</li>
</ul>
<h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><h3 id="内存区域"><a href="#内存区域" class="headerlink" title="内存区域"></a>内存区域</h3><h4 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h4><ul>
<li><p>JDK1.8之前</p>
<p><img src="/2022/01/03/day29/day29_8.png" alt="JDK8之前"></p>
</li>
<li><p>JDK8之后</p>
<p><img src="/2022/01/03/day29/day29_9.png" alt="JDK8之后"></p>
</li>
</ul>
<h4 id="线程私有区域"><a href="#线程私有区域" class="headerlink" title="线程私有区域"></a>线程私有区域</h4><ul>
<li><p><strong>程序计数器</strong></p>
</li>
<li><p>实现代码的流程控制</p>
</li>
<li><p>多线程情况下，方便恢复线程程序</p>
</li>
<li><p><strong>唯一一个不会OutofMemory的区域，随线程创建而创建，随线程死亡而死亡</strong></p>
</li>
<li><p><strong>虚拟机栈</strong>：生命周期和程序计数器相同，不存在垃圾回收</p>
<ul>
<li><p>当虚拟机栈不允许动态扩展时，会出现StackOverFlow，如果允许动态扩展，会出现OutOfMemory</p>
</li>
<li><p>由一个一个栈帧组成，每个栈帧包含局部变量表、操作数栈、动态链接、方法出口信息</p>
</li>
<li><p><code>局部变量表</code>：存储方法参数和在方法内定义的局部变量。使用<code>slot(变量槽)</code>存储，this指针放在index为0的槽内</p>
</li>
<li><p><code>操作数栈</code>：方法执行过程中，往栈中写入或提取数据，作为计算过程中变量的临时存储空间，方法返回值也会放入操作数栈</p>
</li>
<li><p><code>动态链接</code>：每一个栈帧中都包含一个指向运行时常量池中该栈帧所属方法的引用，包含引用的目的就是为了实现动态链接，Java源文件被编译为字节码后，所有的变量和方法引用都会作为符号引用保存在class文件的常量池中，<strong>将符号引用转为调用方法的直接引用称为动态链接</strong></p>
<blockquote>
<p>方法的调用：</p>
<p>Java 栈可以类比数据结构中栈，Java 栈中保存的主要内容是栈帧，每一次函数调用都会有一个对应的栈帧被压入 Java 栈，每一个函数调用结束后，都会有一个栈帧被弹出</p>
</blockquote>
</li>
</ul>
</li>
<li><p><strong>本地方法栈</strong>：和虚拟机栈类似，主要为<strong>native方法</strong>服务，在HotySpot虚拟机中，与虚拟机栈合二为一</p>
</li>
</ul>
<h4 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h4><ul>
<li>内存中最大的一块，线程共享，在虚拟机启动时创建，是GC的主要区域</li>
<li>几乎所有的对象实例和数组都在堆上分配内存，但也不是绝对，<strong>例如JDK1.7之后会进行逃逸分析，方法中的对象引用没有被返回或未被方法外使用，可以直接在栈上分配</strong></li>
<li>堆中的对象又分为年轻代、老年代和永久代，jdk8之后将永久代放入了元空间中：<ul>
<li>年轻代：生命周期较短的对象<ul>
<li>年轻代分为：Eden空间，s0空间和s1空间，默认情况下的内存比例为8：1：1，几乎所有对象都是在Eden空间创建出来的</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>为什么又两个Survior区域：</p>
<ol>
<li>只有一个的话，有对象进入老年代时会产生空间碎片，最后可能会触发minorGC</li>
<li>新生代的垃圾回收算法采用标记-复制算法，需要两个区域</li>
</ol>
</blockquote>
<ul>
<li><p>老年代：生命周期较长的对象</p>
</li>
<li><p>容易出现OutOfMemory，比如：</p>
<ul>
<li><p><strong><code>java.lang.OutOfMemoryError: GC Overhead Limit Exceeded</code></strong> ： 当 JVM 花太多时间执行垃圾回收并且只能回收很少的堆空间时，就会发生此错误。</p>
<p><strong><code>java.lang.OutOfMemoryError: Java heap space</code></strong> :假如在创建新的对象时, 堆内存中的空间不足以存放新创建的对象, 就会引发此错误。(和配置的最大堆内存有关，且受制于物理内存大小。最大堆内存可通过<code>-Xmx</code>参数配置，若没有特别配置，将会使用默认值）</p>
</li>
</ul>
</li>
</ul>
<h4 id="堆、栈和方法区的关系"><a href="#堆、栈和方法区的关系" class="headerlink" title="堆、栈和方法区的关系"></a>堆、栈和方法区的关系</h4><ul>
<li><strong>方法区</strong>：用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据</li>
</ul>
<p><img src="/2022/01/03/day29/day29_10.png" alt="实际例子"></p>
<h4 id="为什么要使用元空间代替方法区"><a href="#为什么要使用元空间代替方法区" class="headerlink" title="为什么要使用元空间代替方法区"></a>为什么要使用元空间代替方法区</h4><ul>
<li><strong>出现溢出的可能性更小</strong>：整个永久代有一个 JVM 本身设置的固定大小上限，而元空间使用的是直接内存，受本机可用内存的限制，虽然元空间仍旧可能溢出，但是比原来出现的几率会更小</li>
<li>元空间里面存放的是类的元数据，由系统的实际可用空间来控制，这样能加载的类就更多了</li>
</ul>
<h4 id="JVM-常量池中存储的是对象还是引用呢"><a href="#JVM-常量池中存储的是对象还是引用呢" class="headerlink" title="JVM 常量池中存储的是对象还是引用呢?"></a>JVM 常量池中存储的是对象还是引用呢?</h4><ul>
<li><p><strong>JDK1.7之前</strong>运⾏时常量池包含：字符串常量池存放在⽅法区, 此时hotspot虚拟机对⽅法区的实现为永久代</p>
</li>
<li><p><strong>JDK1.7</strong>把字符串常量池拿出来放在了堆中，但是其他的仍在方法区（永久代）</p>
</li>
<li><p><strong>JDK8之后</strong>，字符串常量池被放在堆空间，包含了字符串对象和字符串常量值， hotspot移除了永久代⽤元空间(Metaspace)取⽽代之，元空间的常量池寻访的是引用</p>
</li>
</ul>
<h4 id="对象分配过程"><a href="#对象分配过程" class="headerlink" title="对象分配过程"></a>对象分配过程</h4><ul>
<li>首先创建对象。放在Eden区</li>
<li>Eden区放满后，再来对象会进行YGC/Minor GC，进行垃圾回收。非垃圾对象会进入Survivor0区，每个对象的年龄为1，Eden区清空。</li>
<li>重复前两个步骤，每次当Eden区放满，垃圾回收算法也会检测幸存者区的对象，并把非垃圾对象在S0和S1区中往返复制，并增加每个对象的年龄。S0和S1区总有一个区为空</li>
<li>当有对象的年龄达到阈值（默认为15）时，对象会从年轻代晋升到老年代</li>
</ul>
<blockquote>
<p>特殊情况：</p>
<ol>
<li>YGC后，需要创建的对象很大，Eden区无法放下，则直接放入老年代。如果老年代也放不下，先进行FGC/major GC对老年代进行垃圾回收；如果回收之后还放不下，报错OOM(不自动调整的情况)</li>
<li>YGC时，如果Eden区的对象S0或S1区放不下，则对象直接晋升老年代</li>
<li>如果幸存者区中相同年龄的对象大小的总和大于幸存者空间的一半，年龄大于等于该年龄的对象直接进入老年代</li>
<li>Hotspot 遍历所有对象时，按照年龄从小到大对其所占用的大小进行累积，当累积的某个年龄大小超过了 survivor 区的一半时，会将该年龄和晋升阈值作比较，选择较小的为新的晋升年龄</li>
</ol>
</blockquote>
<h4 id="对象的创建过程"><a href="#对象的创建过程" class="headerlink" title="对象的创建过程"></a>对象的创建过程</h4><ul>
<li><p><strong>类加载检查</strong>：虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程</p>
</li>
<li><p><strong>分配内存</strong>： <strong>“指针碰撞”</strong> 和 <strong>“空闲列表”</strong> 两种分配方式，选择哪种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定</p>
<ul>
<li>分配内存时，会存在并发问题，需要保证线程安全，采用两种方式<ul>
<li><strong>CAS+失败重试：</strong> CAS 是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。<strong>虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。</strong></li>
<li><strong>TLAB：</strong>线程私有， 为<strong>每一个线程</strong>预先在 Eden 区分配一块儿内存，JVM 在给线程中的对象分配内存时，首先在 TLAB 分配，当对象大于 TLAB 中的剩余内存或 TLAB 的内存已用尽时，再采用上述的 CAS 进行内存分配</li>
</ul>
</li>
</ul>
<p><img src="/2022/01/03/day29/day29_11.png" alt="分配内存"></p>
</li>
<li><p><strong>初始化零值</strong>：将对象的属性进行初始化</p>
</li>
<li><p><strong>设置对象头</strong>：将对象的所属类、HashCode和对象的GC信息、锁信息等数据存储在对象的对象头中</p>
</li>
<li><p><strong>执行init方法</strong>：父类静态代码块、父类静态变量初始化、子类静态代码块、子类静态变量初始化、父类变量初始化、父类代码块、父类构造函数、子类变量初始化、子类代码块、子类构造方法</p>
</li>
</ul>
<h4 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h4><ul>
<li>对象头：<ul>
<li>存储对象自身的运行时数据：希码、GC 分代年龄、锁状态标志等等</li>
<li>类型指针：对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例</li>
<li>如果是数组，还需要记录数组长度</li>
</ul>
</li>
<li>实例数据：存储对象有效信息，各字段的值<ul>
<li>规则：先放父类的字段；相同宽度字段放在一起；如果CompactFields设置为true(默认为true)，子类窄变量可能插入到父类变量的间隙</li>
</ul>
</li>
<li>对齐填充：占位作用，对象占用内存必须是8字节的整数倍</li>
</ul>
<h4 id="常量池问题"><a href="#常量池问题" class="headerlink" title="常量池问题"></a>常量池问题</h4><ul>
<li><p>字符串常量池，在编译期就可以确定的字符串，就直接是常量池的对象。否则会在堆上新建对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">String str1 = <span class="string">&quot;str&quot;</span>;</span><br><span class="line">String str2 = <span class="string">&quot;ing&quot;</span>;</span><br><span class="line">String str3 = <span class="string">&quot;str&quot;</span> + <span class="string">&quot;ing&quot;</span>;<span class="comment">//常量池中的对象</span></span><br><span class="line">String str4 = str1 + str2; <span class="comment">//在堆上创建的新的对象</span></span><br><span class="line">String str5 = <span class="string">&quot;string&quot;</span>;<span class="comment">//常量池中的对象</span></span><br><span class="line">System.out.println(str3 == str4);<span class="comment">//false</span></span><br><span class="line">System.out.println(str3 == str5);<span class="comment">//true</span></span><br><span class="line">System.out.println(str4 == str5);<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用final关键字会有变化</span></span><br><span class="line"><span class="keyword">final</span> String str1 = <span class="string">&quot;str&quot;</span>;</span><br><span class="line"><span class="keyword">final</span> String str2 = <span class="string">&quot;ing&quot;</span>;</span><br><span class="line">String c = <span class="string">&quot;str&quot;</span> + <span class="string">&quot;ing&quot;</span>;<span class="comment">// 常量池中的对象</span></span><br><span class="line">String d = str1 + str2; <span class="comment">// 常量池中的对象</span></span><br><span class="line">System.out.println(c == d);<span class="comment">// true</span></span><br></pre></td></tr></table></figure></li>
<li><p>包装类常量池，浮点类没有常量池，自动拆箱装箱</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Integer i1 = <span class="number">40</span>;</span><br><span class="line">Integer i2 = <span class="number">40</span>;</span><br><span class="line">Integer i3 = <span class="number">0</span>;</span><br><span class="line">Integer i4 = <span class="keyword">new</span> Integer(<span class="number">40</span>);</span><br><span class="line">Integer i5 = <span class="keyword">new</span> Integer(<span class="number">40</span>);</span><br><span class="line">Integer i6 = <span class="keyword">new</span> Integer(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(i1 == i2);<span class="comment">// true</span></span><br><span class="line">System.out.println(i1 == i2 + i3);<span class="comment">//true</span></span><br><span class="line">System.out.println(i1 == i4);<span class="comment">// false</span></span><br><span class="line">System.out.println(i4 == i5);<span class="comment">// false</span></span><br><span class="line">System.out.println(i4 == i5 + i6);<span class="comment">// true</span></span><br><span class="line">System.out.println(<span class="number">40</span> == i5 + i6);<span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>i1</code> , <code>i2</code> , <code>i3</code> 都是常量池中的对象，<code>i4</code> , <code>i5</code> , <code>i6</code> 是堆中的对象。</p>
<p><code>i4 == i5 + i6</code> 为什么是 true 呢？因为， <code>i5</code> 和 <code>i6</code> 会进行自动拆箱操作，进行数值相加，即 <code>i4 == 40</code> 。 <code>Integer</code> 对象无法与数值进行直接比较，所以 <code>i4</code> 自动拆箱转为 int 值 40，最终这条语句转为 <code>40 == 40</code> 进行数值比较</p>
</li>
</ul>
<blockquote>
<p>对于String对象:</p>
<ol>
<li>使用new关键字创建的字符串对象存储在堆的普通内存部分</li>
<li>不使用new 关键字创建的字符串对象存储在堆的字符串常量池部分</li>
</ol>
</blockquote>
</li>
</ul>
<h3 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h3><h4 id="空间担保"><a href="#空间担保" class="headerlink" title="空间担保"></a>空间担保</h4><ul>
<li><p>保证在Minor GC之前，老年代本身还有空间容纳新生代</p>
</li>
<li><p>JDK 6 Update 24 之前，在发生 Minor GC 之前，虚拟机必须先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那这一次 Minor GC 可以确保是安全的。如果不成立，则虚拟机会先查看 <code>-XX:HandlePromotionFailure</code> 参数的设置值是否允许担保失败(Handle Promotion Failure);如果允许，那会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试进行一次 Minor GC，尽管这次 Minor GC 是有风险的;如果小于，或者 <code>-XX: HandlePromotionFailure</code> 设置不允许冒险，那这时就要改为进行一次 Full GC。</p>
</li>
<li><p>JDK 6 Update 24 之后的规则变为只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小，就会进行 Minor GC，否则将进行 Full GC</p>
</li>
</ul>
<h4 id="判断对象死亡？"><a href="#判断对象死亡？" class="headerlink" title="判断对象死亡？"></a>判断对象死亡？</h4><ul>
<li><strong>引用计数法</strong>：给对象中添加一个引用计数器，每当有一个地方引用它，计数器就加 1；当引用失效，计数器就减 1；任何时候计数器为 0 的对象就是不可能再被使用的<ul>
<li>主流虚拟机不使用，因为无法解决循环引用问题，两个对象互相引用的情形</li>
</ul>
</li>
<li><strong>可达性分析算法</strong>：以 <strong>“GC Roots”</strong> 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的，需要被回收<ul>
<li>可作为GC Roots的对象：<ul>
<li>虚拟机栈(栈帧中的本地变量表)中引用的对象</li>
<li>本地方法栈(Native 方法)中引用的对象</li>
<li>方法区中类静态属性引用的对象</li>
<li>方法区中常量引用的对象</li>
<li>所有被同步锁持有的对象</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>对象可以被回收，就代表一定会被回收吗？</strong></p>
<p>即使在可达性分析法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑阶段”，要真正宣告一个对象死亡，至少要经历两次标记过程；可达性分析法中不可达的对象被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行 <code>finalize</code> 方法。当对象没有覆盖 <code>finalize</code> 方法，或 <code>finalize</code> 方法已经被虚拟机调用过时，虚拟机将这两种情况视为没有必要执行。</p>
<p>被判定为需要执行的对象将会被放在一个队列中进行第二次标记，除非这个对象与引用链上的任何一个对象建立关联，否则就会被真的回收。</p>
</blockquote>
<h4 id="引用分类"><a href="#引用分类" class="headerlink" title="引用分类"></a>引用分类</h4><ul>
<li><strong>强引用</strong>：代码中普遍存在的引用赋值，只要强引用存在，垃圾回收就<strong>永远不会</strong>回收该对象</li>
<li><strong>软引用</strong>：系统将要发生内存溢出之前，这些对象会被列入回收范围。垃圾回收之后内存还不足，才会报OOM，可以和一个引用队列（ReferenceQueue）联合使用</li>
<li><strong>弱引用</strong>：被GC发现就会被回收，不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象，可以和一个引用队列（ReferenceQueue）联合使用</li>
<li><strong>虚引用</strong>：设置虚引用的唯一目的是为了对象在被回收时收到系统通知，在任何时候都有可能被回收，<strong>必须</strong>和引用队列（ReferenceQueue）联合使用</li>
</ul>
<blockquote>
<p>特别注意，在程序设计中一般很少使用弱引用与虚引用，使用软引用的情况较多，这是因为<strong>软引用可以加速 JVM 对垃圾内存的回收速度，可以维护系统的运行安全，防止内存溢出（OutOfMemory）等问题的产生</strong></p>
</blockquote>
<h4 id="如何判断一个常量是废弃的？或者一个类是无用的类？"><a href="#如何判断一个常量是废弃的？或者一个类是无用的类？" class="headerlink" title="如何判断一个常量是废弃的？或者一个类是无用的类？"></a>如何判断一个常量是废弃的？或者一个类是无用的类？</h4><ul>
<li>假如在字符串常量池中存在字符串 “abc”，如果当前没有任何 String 对象引用该字符串常量的话，就说明常量 “abc” 就是废弃常量，如果这时发生内存回收的话而且有必要的话，”abc” 就会被系统清理出常量池了</li>
<li>同时满足3 个条件才能算是 <strong>“无用的类”</strong> ：<ul>
<li>该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。</li>
<li>加载该类的 <code>ClassLoader</code> 已经被回收。</li>
<li>该类对应的 <code>java.lang.Class</code> 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li>
</ul>
</li>
</ul>
<h4 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h4><ul>
<li><p><strong>标记-清除算法</strong>：首先标记出所有不需要回收的对象，在标记完成后统一回收掉所有没有被标记的对象</p>
<ul>
<li><p>清除并不是真的清空，而是把需要清除的对象内存地址保存在地址列表中，有对象需要分配内存时，再进行判断</p>
</li>
<li><p>效率低；会产生不连续内存空间，产生内存碎片</p>
</li>
</ul>
</li>
<li><p><strong>标记-复制算法</strong>：将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。这样就使每次的内存回收都是对内存区间的一半进行回收</p>
<ul>
<li>需要两倍的内存空间；GC需要维护region之间对象引用关系，时间和内存消耗</li>
<li>适用场景：存活的对象不多，大部分都是垃圾，因此适用于新生代</li>
</ul>
<p><img src="/2022/01/03/day29/day29_12.png" alt="复制算法"></p>
</li>
</ul>
<ul>
<li><p><strong>标记-整理（压缩）算法</strong>：标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存</p>
<ul>
<li>优点：在标记清除算法的基础上加了碎片整理；没有额外空间</li>
<li>缺点：效率低于复制算法；需要调整引用地址；有STW</li>
<li>适用于老年代</li>
</ul>
<p><img src="/2022/01/03/day29/day29_13.png" alt="标记-整理算法 "></p>
</li>
</ul>
<h4 id="HotSpot-为什么要分为新生代和老年代？"><a href="#HotSpot-为什么要分为新生代和老年代？" class="headerlink" title="HotSpot 为什么要分为新生代和老年代？"></a>HotSpot 为什么要分为新生代和老年代？</h4><ul>
<li><p>当前虚拟机的垃圾收集都采用分代收集算法，根据对象存活周期的不同将内存分为几块。一般将 java 堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。</p>
</li>
<li><p>比如在新生代中，每次收集都会有大量对象死去，所以可以选择<strong>”标记-复制“算法</strong>，只需要付出少量对象的复制成本就可以完成每次垃圾收集。而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择<strong>“标记-清除”或“标记-整理”算法</strong>进行垃圾收集。</p>
</li>
</ul>
<h4 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h4><ul>
<li><strong>Serial收集器</strong>：用一条垃圾收集线程去完成垃圾收集工作，在进行垃圾收集工作的时候必须暂停其他所有的工作线程（ <strong>“Stop The World”</strong> ），直到它收集结束<ul>
<li><strong>新生代采用标记-复制算法，老年代采用标记-整理算法</strong></li>
<li>STW时间较长；没有线程切换开销；适合运行再client模式下的虚拟机</li>
</ul>
</li>
<li><strong>Serial Old 收集器</strong>：<strong>Serial 收集器的老年代版本</strong>，它同样是一个单线程收集器。它主要有两大用途：一种用途是在 JDK1.5 以及以前的版本中与 Parallel Scavenge 收集器搭配使用，另一种用途是作为 CMS 收集器的后备方案</li>
<li><strong>ParNew 收集器</strong>：Serial 收集器的多线程版本，除了使用多线程进行垃圾收集外，其余行为（控制参数、收集算法、回收策略等等）和 Serial 收集器完全一样<ul>
<li><strong>新生代采用标记-复制算法，老年代采用标记-整理算法</strong></li>
<li>适用运行再server模式下的虚拟机</li>
</ul>
</li>
<li><strong>Parallel Scavenge 收集器</strong>：几乎和 ParNew 都一样，<strong>关注点是吞吐量（高效率的利用 CPU），所谓吞吐量就是 CPU 中用于运行用户代码的时间与 CPU 总消耗时间的比值。</strong>Parallel Scavenge 收集器提供了很多参数供用户找到最合适的停顿时间或最大吞吐量<ul>
<li><strong>新生代采用标记-复制算法，老年代采用标记-整理算法</strong></li>
<li>JDK8默认收集器</li>
</ul>
</li>
<li><strong>Parallel Old 收集器</strong>：<strong>Parallel Scavenge 收集器的老年代版本</strong>。使用多线程和“标记-整理”算法。在注重吞吐量以及 CPU 资源的场合，都可以优先考虑 Parallel Scavenge 收集器和 Parallel Old 收集器</li>
<li><strong>CMS收集器</strong>：注重用户体验，获取最短的STW时间，基于<strong>标记-清除算法实现</strong>，主要分为四个步骤：<ul>
<li><strong>初始标记：</strong> 暂停所有的其他线程，并记录下直接与 root 相连的对象，速度很快 ；</li>
<li><strong>并发标记：</strong> 同时开启 GC 和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以 GC 线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。</li>
<li><strong>重新标记：</strong> 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短</li>
<li><strong>并发清除：</strong> 开启用户线程，同时 GC 线程开始对未标记的区域做清扫</li>
<li>缺点：对CPU资源敏感；无法处理浮动垃圾；会有空间碎片产生</li>
<li>不采用<strong>标记-压缩</strong>算法是因为CMS在工作时，用户线程也在工作，整理内存可能会使用户线程无法正常工作</li>
</ul>
</li>
<li><strong>G1收集器</strong>：面向服务器的垃圾收集器，主要针对配备多颗处理器及大容量内存的机器。以极高概率满足 GC 停顿时间要求的同时，还具备高吞吐量性能特征<ul>
<li>将堆内存分割成很多个不相关的区域，使用不同的Region表示Eden、幸存者0区、幸存者1区等。G1有计划地避免在整个Java堆中进行垃圾回收，G1跟踪每个Region里面的垃圾堆积价值大小，在后台维护优先列表，根据允许的收集时间，每次优先回收价值最大的Region</li>
<li>并行与并发<ul>
<li>并行性：多个GC线程同时工作，此时用户线程STW</li>
<li>并发性：G1拥有与应用程序交替执行的能力，部分工作和应用程序同时执行</li>
</ul>
</li>
<li>分代收集<ul>
<li>会区分年轻代和老年代，但是不要求他们物理地址连续，也不再坚持固定大小固定数量</li>
<li>同时兼顾年轻代和老年代</li>
</ul>
</li>
<li>空间整合<ul>
<li>G1内存的回收是以region为单位的，Region之间是复制算法，整体上可以看作标记-压缩算法，可以解决碎片化问题</li>
</ul>
</li>
<li>可预测的停顿：<ul>
<li>可以指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不超过N毫秒</li>
<li>G1选择部分区域进行回收，因此全局停顿的发生得到了控制</li>
<li>优先收集价值最大的Region</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="/2022/01/03/day29/day29_14.png" alt="对比"></p>
<h3 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h3><h4 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h4><ul>
<li>加载：<ul>
<li>通过全类名获取定义此类的二进制字节流</li>
<li>将字节流所代表的静态存储结构转换为方法区的运行时数据结构</li>
<li>在内存中生成一个代表该类的 <code>Class</code> 对象，作为方法区这些数据的访问入口</li>
</ul>
</li>
<li>验证：<ul>
<li>文件格式验证：字节流是否符合Class文件格式的规范</li>
<li>元数据验证：对字节码描述的信息进行语义分析，是否符合java语言规范。例如：是否继承了不能被继承的类</li>
<li>字节码验证：确定程序语义是否合法、是否符合逻辑</li>
<li>符号引用验证：确保解析能正确运行</li>
</ul>
</li>
<li>准备：为类变量分配内存并设置类变量初始值，这些内存都将在方法区中分配<ul>
<li>只对类变量进行初始化</li>
<li>JDK8之后，将字符串常量池、静态变量移到堆中，因此类变量也放在了堆中</li>
<li>在准备阶段就可以确定的值，不需要赋为初始值</li>
</ul>
</li>
<li>解析：虚拟机将常量池内的符号引用替换为直接引用，主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用限定符 7 类符号引用进行</li>
<li>初始化：初始化阶段是执行初始化方法 <code>&lt;clinit&gt; ()</code>方法的过程，是类加载的最后一步，这一步 JVM 才开始真正执行类中定义的 Java 程序代码(字节码)。<ul>
<li>如果没有静态变量和静态代码块，就不会存在clinit方法</li>
<li>若该类有父类，JVM会保证父类的<code>&lt;clinit&gt;</code>先执行完成</li>
<li><code>&lt;clinit&gt;</code>保证在多线程下同步，一个类保证只被加载一次</li>
</ul>
</li>
</ul>
<h4 id="类加载器分类"><a href="#类加载器分类" class="headerlink" title="类加载器分类"></a>类加载器分类</h4><ul>
<li><p><strong>BootstrapClassLoader(启动类加载器)</strong> ：最顶层的加载类，由 C++实现，负责加载 <code>%JAVA_HOME%/lib</code>目录下的 jar 包和类或者被 <code>-Xbootclasspath</code>参数指定的路径中的所有类。</p>
</li>
<li><p><strong>ExtensionClassLoader(扩展类加载器)</strong> ：主要负责加载 <code>%JRE_HOME%/lib/ext</code> 目录下的 jar 包和类，或被 <code>java.ext.dirs</code> 系统变量所指定的路径下的 jar 包。</p>
</li>
<li><p><strong>AppClassLoader(应用程序类加载器)</strong> ：面向我们用户的加载器，负责加载当前应用 classpath 下的所有 jar 包和类</p>
</li>
<li><p><strong>用户自定义类加载器</strong>：需要继承java.lang.ClassLoader类，重写findClass()方法</p>
</li>
</ul>
<h4 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h4><ul>
<li><p>加载的时候，首先会把该请求委派给父类加载器的 <code>loadClass()</code> 处理，因此所有的请求最终都应该传送到顶层的启动类加载器 <code>BootstrapClassLoader</code> 中。当父类加载器无法处理时，才由自己来处理。当父类加载器为 null 时，会使用启动类加载器 <code>BootstrapClassLoader</code> 作为父类加载器。</p>
<p><img src="/2022/01/03/day29/day29_15.png" alt="双亲委派机制"></p>
</li>
<li><p>好处：保证了 Java 程序的稳定运行，可以避免类的重复加载（JVM 区分不同类的方式不仅仅根据类名，相同的类文件被不同的类加载器加载产生的是两个不同的类），也保证了 Java 的核心 API 不被篡改。如果没有使用双亲委派模型，而是每个类加载器加载自己的话就会出现一些问题，比如我们编写一个称为 <code>java.lang.Object</code> 类的话，那么程序运行的时候，系统就会出现多个不同的 <code>Object</code> 类</p>
</li>
<li><p><strong>打破双亲委派机制</strong>：</p>
<ul>
<li><strong>不进行委派</strong>：自定义加载类，不重写<code>findClass()</code>方法，重写<code>loadClass()</code>方法</li>
<li><strong>向下委派</strong>：通过spi机制，使用SeviceLoader.load加载，需要有配置文件</li>
</ul>
</li>
</ul>
<h2 id="Java8新特性"><a href="#Java8新特性" class="headerlink" title="Java8新特性"></a>Java8新特性</h2><h3 id="Interface"><a href="#Interface" class="headerlink" title="Interface"></a>Interface</h3><ul>
<li>新 interface 的方法可以用<code>default</code> 或 <code>static</code>修饰，这样就可以有方法体，实现类也不必重写此方法<ul>
<li><code>default</code>修饰的方法，是普通实例方法，可以用<code>this</code>调用，可以被子类继承、重写</li>
<li><code>static</code>修饰的方法，使用上和一般类静态方法一样。但它不能被子类继承，只能用<code>Interface</code>调用</li>
</ul>
</li>
<li>Function-Interface(函数式接口)，支持Lamba表达式</li>
</ul>
<h3 id="Stream流"><a href="#Stream流" class="headerlink" title="Stream流"></a>Stream流</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  List&lt;String&gt; strings = Arrays.asList(<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;def&quot;</span>, <span class="string">&quot;gkh&quot;</span>, <span class="string">&quot;abc&quot;</span>);</span><br><span class="line">    <span class="comment">//返回符合条件的stream</span></span><br><span class="line">    Stream&lt;String&gt; stringStream = strings.stream().filter(s -&gt; <span class="string">&quot;abc&quot;</span>.equals(s));</span><br><span class="line">    <span class="comment">//计算流符合条件的流的数量</span></span><br><span class="line">    <span class="keyword">long</span> count = stringStream.count();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//forEach遍历-&gt;打印元素</span></span><br><span class="line">    strings.stream().forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//limit 获取到1个元素的stream</span></span><br><span class="line">    Stream&lt;String&gt; limit = strings.stream().limit(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//toArray 比如我们想看这个limitStream里面是什么，比如转换成String[],比如循环</span></span><br><span class="line">    String[] array = limit.toArray(String[]::<span class="keyword">new</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//map 对每个元素进行操作返回新流</span></span><br><span class="line">    Stream&lt;String&gt; map = strings.stream().map(s -&gt; s + <span class="string">&quot;22&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//sorted 排序并打印</span></span><br><span class="line">    strings.stream().sorted().forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Collectors collect 把abc放入容器中</span></span><br><span class="line">    List&lt;String&gt; collect = strings.stream().filter(string -&gt; <span class="string">&quot;abc&quot;</span>.equals(string)).collect(Collectors.toList());</span><br><span class="line">    <span class="comment">//把list转为string，各元素用，号隔开</span></span><br><span class="line">    String mergedString = strings.stream().filter(string -&gt; !string.isEmpty()).collect(Collectors.joining(<span class="string">&quot;,&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对数组的统计，比如用</span></span><br><span class="line">    List&lt;Integer&gt; number = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    IntSummaryStatistics statistics = number.stream().mapToInt((x) -&gt; x).summaryStatistics();</span><br><span class="line">    System.out.println(<span class="string">&quot;列表中最大的数 : &quot;</span>+statistics.getMax());</span><br><span class="line">    System.out.println(<span class="string">&quot;列表中最小的数 : &quot;</span>+statistics.getMin());</span><br><span class="line">    System.out.println(<span class="string">&quot;平均数 : &quot;</span>+statistics.getAverage());</span><br><span class="line">    System.out.println(<span class="string">&quot;所有数之和 : &quot;</span>+statistics.getSum());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//concat 合并流</span></span><br><span class="line">    List&lt;String&gt; strings2 = Arrays.asList(<span class="string">&quot;xyz&quot;</span>, <span class="string">&quot;jqx&quot;</span>);</span><br><span class="line">    Stream.concat(strings2.stream(),strings.stream()).count();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注意 一个Stream只能操作一次，不能断开，否则会报错。</span></span><br><span class="line">    Stream stream = strings.stream();</span><br><span class="line">    <span class="comment">//第一次使用</span></span><br><span class="line">    stream.limit(<span class="number">2</span>);</span><br><span class="line">    <span class="comment">//第二次使用</span></span><br><span class="line">    stream.forEach(System.out::println);</span><br><span class="line">    <span class="comment">//报错 java.lang.IllegalStateException: stream has already been operated upon or closed</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//但是可以这样, 连续使用</span></span><br><span class="line">    stream.limit(<span class="number">2</span>).forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h1 id="数据库-amp-中间件"><a href="#数据库-amp-中间件" class="headerlink" title="数据库 &amp; 中间件"></a>数据库 &amp; 中间件</h1><h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><h3 id="基础-1"><a href="#基础-1" class="headerlink" title="基础"></a>基础</h3><h4 id="三大范式"><a href="#三大范式" class="headerlink" title="三大范式"></a>三大范式</h4><ul>
<li>1NF：数据库每个字段都不能再分为多个字段（最基本要求），例如<strong>班级字段可分为专业和班号</strong>，<strong>解决方法拆字段</strong></li>
<li>2NF：满足1NF的情况下，在<strong>存在主键时，不能有部分依赖</strong>。(主要<strong>针对复合主键</strong>的)。例如订单号和商品号作为复合主键，商品信息只依赖商品号，<strong>解决方法是拆表</strong></li>
<li>3NF：满足1NF,2NF，确保数据库每个字段都和主键直接相关，而不是间接相关，例如学号为主键，课程号和学号并不是直接相关，<strong>解决方法是拆表</strong></li>
</ul>
<h4 id="drop、delete、和truncate区别？"><a href="#drop、delete、和truncate区别？" class="headerlink" title="drop、delete、和truncate区别？"></a>drop、delete、和truncate区别？</h4><ul>
<li><strong>用法不同</strong><ul>
<li>drop：删除整个表，包括表结构</li>
<li>truncate：清空整个表，保留表结构</li>
<li>delete：删除表中的某一列数据，不加条件，清空整个表，保留表结构</li>
</ul>
</li>
<li><strong>属于不同的数据库语言</strong><ul>
<li>truncate和drop属于DDL语言，原数据不会放入rollback segment中，无法回滚</li>
<li>delete是DML语言，会将原数据放入rollback segment中，可以回滚</li>
</ul>
</li>
</ul>
<blockquote>
<p><code>delete</code>命令执行的时候会产生数据库的<code>binlog</code>日志，而日志记录是需要消耗时间的，但是也有个好处方便数据回滚恢复。</p>
<p><code>truncate</code>命令执行的时候不会产生数据库日志，因此比<code>delete</code>要快。除此之外，还会把表的自增值重置和索引恢复到初始大小等。</p>
<p><code>drop</code>命令会把表占用的空间全部释放掉。</p>
</blockquote>
<h4 id="设计数据集步骤"><a href="#设计数据集步骤" class="headerlink" title="设计数据集步骤"></a>设计数据集步骤</h4><ul>
<li><strong>需求分析</strong> : 分析用户的需求，包括数据、功能和性能需求。</li>
<li><strong>概念结构设计</strong> : 主要采用 E-R 模型进行设计，包括画 E-R 图。</li>
<li><strong>逻辑结构设计</strong> : 通过将 E-R 图转换成表，实现从 E-R 模型到关系模型的转换。</li>
<li><strong>物理结构设计</strong> : 主要是为所设计的数据库选择合适的存储结构和存取路径。</li>
<li><strong>数据库实施</strong> : 包括编程、测试和试运行</li>
<li><strong>数据库的运行和维护</strong> : 系统的运行与数据库的日常维护</li>
</ul>
<h4 id="MyISAM和InnoDB区别"><a href="#MyISAM和InnoDB区别" class="headerlink" title="MyISAM和InnoDB区别"></a>MyISAM和InnoDB区别</h4><ul>
<li><strong>锁</strong>：MyISAM只有表级锁；InnoDB支持表级锁和行级锁</li>
<li><strong>事务</strong>：MyISAM不支持事务；InnoDB支持事务，可以提交和回滚</li>
<li><strong>外键</strong>：MyISAM不支持外键；InnoDB支持外键</li>
<li><strong>安全恢复</strong>：MyISAM不支持异常崩溃后的安全回复；InnoDB支持，恢复的过程依赖于 <code>redo log</code></li>
<li><strong>索引结构</strong>：MyISAM索引使用B+树，叶子节点存放的是数据记录的地址，索引文件和数据文件是分开的；InnoDB索引使用B+树，叶子节点存放的是完整的数据记录，非聚簇索引存放的是主键的值</li>
</ul>
<h4 id="事务ACID特性"><a href="#事务ACID特性" class="headerlink" title="事务ACID特性"></a>事务ACID特性</h4><ul>
<li><p><strong>原子性</strong>（<code>Atomicity</code>） ： 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用</p>
</li>
<li><p><strong>一致性</strong>（<code>Consistency</code>）： 执行事务前后，数据保持一致，例如转账业务中，无论事务是否成功，转账者和收款人的总额应该是不变的</p>
</li>
<li><p><strong>隔离性</strong>（<code>Isolation</code>）： 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的</p>
</li>
<li><p><strong>持久性</strong>（<code>Durability</code>）： 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响</p>
<blockquote>
<p>实现原理：</p>
<p>MySQL InnoDB 引擎使用 <strong>redo log(重做日志)</strong> 保证事务的<strong>持久性</strong>，使用 <strong>undo log(回滚日志)</strong> 来保证事务的<strong>原子性</strong>。</p>
<p>MySQL InnoDB 引擎通过 <strong>锁机制</strong>、<strong>MVCC</strong> 等手段来保证事务的隔离性（ 默认支持的隔离级别是 <strong><code>REPEATABLE-READ</code></strong> ）。</p>
<p>保证了事务的持久性、原子性、隔离性之后，一致性才能得到保障。</p>
</blockquote>
</li>
</ul>
<h4 id="并发事务带来的问题"><a href="#并发事务带来的问题" class="headerlink" title="并发事务带来的问题"></a>并发事务带来的问题</h4><ul>
<li><strong>脏读</strong>：一个事务读取了另一个事务未提交的数据<ul>
<li>添加写锁</li>
</ul>
</li>
<li><strong>丢失修改</strong>：两个事务同时操作同一个数据，同时读取了数据，修改之后提交，可能有一个事务的修改操作没有生效</li>
<li><strong>不可重复读</strong>：在同一个事务内，多次读取同一个数据，由于其他事务对数据的修改，多次读取的数据不同<ul>
<li>给查询范围内的数据加读锁并且读取之后不会马上释放</li>
<li>其他事务无法施加写锁，无法修改数据；但是可以插入数据，导致幻读</li>
</ul>
</li>
<li><strong>幻读</strong>：在同一个事务内，查询同一个表中的数据，由于其他事务添加或删除数据，发现多次查询总的数据量不同<ul>
<li>间隙锁加行锁</li>
</ul>
</li>
</ul>
<h4 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h4><ul>
<li><p><strong>READ-UNCOMMITTED(读取未提交)：</strong> 最低的隔离级别，允许读取尚未提交的数据变更</p>
</li>
<li><p><strong>READ-COMMITTED(读取已提交)：</strong> 允许读取并发事务已经提交的数据</p>
</li>
<li><p><strong>REPEATABLE-READ(可重复读)：</strong> 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，<strong>MySQL默认隔离级别</strong></p>
</li>
<li><p><strong>SERIALIZABLE(可串行化)：</strong> 最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行</p>
<p><img src="/2022/01/03/day29/day29_19.png" alt="事务隔离"></p>
</li>
</ul>
<h4 id="join的使用和原理"><a href="#join的使用和原理" class="headerlink" title="join的使用和原理"></a>join的使用和原理</h4><ul>
<li><p><code>left join</code>：保留左表的数据，左表没有的数据设置为null，外连接</p>
</li>
<li><p><code>right join</code>：保留右表的数据，右表没有的数据设置为null，外连接</p>
</li>
<li><p><code>join(inner join)</code>：取左右表数据的交集，内连接</p>
</li>
<li><p>原理：嵌套循环（Nested-Loop Join），需要区分驱动表和被驱动表，先访问驱动表，筛选出结果集</p>
<ul>
<li><p>SNLJ（Simple Nested-Loop Join）：简单嵌套循环，将驱动表中的数据一行一行读取出来进行匹配，每行数据都会出发被驱动表的整表扫描，对比数据，将结果加入结果集，不需要回表</p>
<p><img src="/2022/01/03/day29/day29_25.png" alt="SNLJ"></p>
</li>
<li><p>INLJ（Index Nested-Loop join）：索引嵌套循环。和SNLJ类似，最大的区别是用来join的字段在被驱动表中建立了索引，<strong>如果是非聚簇索引需要进行回表，聚簇索引不需要回表</strong></p>
<ul>
<li>SNLJ算法被驱动表需要每次全表查询，INLJ算法使用索引查询，性能提高</li>
</ul>
</li>
<li><p>BNLJ（Block Nested-Loop Join）：块嵌套循环，没有索引的情况下一种优化，降低被驱动表的扫描次数，使用join buffer缓冲区</p>
<ul>
<li>join bufffer缓存join所需的字段，在与被驱动表进行对比时，将buffer中的所有字段和被驱动表一起对比，如果buffer足够大，只需要对被驱动表查询一次</li>
</ul>
<p><img src="/2022/01/03/day29/day29_26.png" alt="BNLJ"></p>
</li>
</ul>
</li>
</ul>
<h4 id="SQL语句执行流程"><a href="#SQL语句执行流程" class="headerlink" title="SQL语句执行流程"></a>SQL语句执行流程</h4><p><img src="/2022/01/03/day29/day29_29.png" alt="执行流程"></p>
<h4 id="datetime和timestamp区别"><a href="#datetime和timestamp区别" class="headerlink" title="datetime和timestamp区别"></a>datetime和timestamp区别</h4><ul>
<li>共同点：存储精度都精确到秒</li>
<li>区别：<ul>
<li>datetime日期范围1001——9999年，timestamp范围为1970——2038年</li>
<li>datetime存储时间与时区无关，timestamp和时区相关</li>
<li>datetime占8个字节，timestamp占4字节</li>
<li>datetime默认值为null,timestamp默认为当前时间</li>
</ul>
</li>
</ul>
<h4 id="varchar和char区别"><a href="#varchar和char区别" class="headerlink" title="varchar和char区别"></a>varchar和char区别</h4><ul>
<li>char定长，varchar是变长的，用一个字符表示占用长度</li>
<li>检索效率char&gt;varchar，如果确认某个字段的值，使用char，例如MD5加密后的密码</li>
</ul>
<h4 id="in和exists区别"><a href="#in和exists区别" class="headerlink" title="in和exists区别"></a>in和exists区别</h4><ul>
<li>in先执行子查询，后执行主查询，exists相反。通常<strong>in+小表，exists+大表</strong>，遵循小表驱动大表原则，减少数据库连接次数</li>
</ul>
<h3 id="高性能优化"><a href="#高性能优化" class="headerlink" title="高性能优化"></a>高性能优化</h3><h4 id="字段设计规范"><a href="#字段设计规范" class="headerlink" title="字段设计规范"></a>字段设计规范</h4><ul>
<li><p><strong>优先选择符合存储需要的最小数据类型</strong>：建立索引的空间越小，一页中能够存储的索引节点数量也就越多，遍历时的IO次数就越少</p>
<ul>
<li><strong>将字符串转换成数字类型存储,如:将 IP 地址转换成整形数据</strong></li>
</ul>
</li>
<li><p><strong>避免使用 TEXT,BLOB 数据类型</strong>：可以将BLOB或是TEXT列分离到单独的扩展表中，查询时只取出必要的列</p>
<ul>
<li>大数据类型不能适用内存临时表，必须使用磁盘临时表，MySQL要进行二次查询，很慢</li>
</ul>
</li>
<li><p><strong>避免使用ENUM类型</strong>：修改ENUM值需要使用ALTER语句，排序效率很低</p>
</li>
<li><p><strong>尽可能把所有列定义为NOT NULL</strong>：索引NULL列需要额外的空间，会占用更多的空间，进行计算和比较时，也需要特殊处理</p>
</li>
<li><p><strong>使用TIMESTAMP（4字节）或DATETIME（8字节）存储时间</strong>：不要使用字符串存储日期</p>
</li>
<li><p><strong>财务类相关金额数据必须使用decimal类型</strong>：精准浮点数</p>
</li>
</ul>
<h4 id="索引设计规范"><a href="#索引设计规范" class="headerlink" title="索引设计规范"></a>索引设计规范</h4><ul>
<li><strong>建议单张表的索引不超过5个</strong>：索引在增加查询效率的同时，也会降低插入和更新的效率。MySQL在进行查询操作时，会对每一个可以使用的索引进行评估，选择最优的索引进行查询，索引太多会导致计划的时间变长，降低效率</li>
<li><strong>每个Innodb都必须有主键</strong>：Innodb按照主键索引的顺序来组织表<ul>
<li>不使用更新频繁的列作为主键</li>
<li>不要使用UUID,MD5,HASH字符串作为主键，无法保证数据的顺序增长</li>
<li>主键建议使用自增ID值</li>
</ul>
</li>
<li><strong>设置为索引的列</strong>：<ul>
<li>出现在WHERE从句中的列</li>
<li>包含在ORDER BY、GROUP BY、DISTINCT中的字段</li>
<li>不要对符合前两个条件的每个列都建立索引，建立联合索引效果更好</li>
<li>多表join的关联列</li>
</ul>
</li>
<li><strong>索引列的顺序</strong>：<ul>
<li>区分度最高的放在联合索引的最左侧</li>
<li>字段小的索引放在联合索引的最左侧</li>
<li>使用最频繁的列放在联合索引的最左侧</li>
</ul>
</li>
<li><strong>对于频繁的查询优先考虑使用覆盖索引</strong>：<ul>
<li><strong>避免 Innodb 表进行索引的二次查询:</strong> 对于 Innodb 来说，二级索引在叶子节点中所保存的是行的主键信息，如果是用二级索引查询数据的话，在查找到相应的键值后，还要通过主键进行二次查询才能获取我们真实所需要的数据。而在覆盖索引中，二级索引的键值中可以获取所有的数据，避免了对主键的二次查询 ，减少了 IO 操作，提升了查询效率。</li>
<li><strong>可以把随机 IO 变成顺序 IO 加快查询效率:</strong> 由于覆盖索引是按键值的顺序存储的，对于 IO 密集型的范围查找来说，顺序获取比随机获取每一行的数据 IO 要少的多，因此利用覆盖索引在访问时也可以把磁盘的随机读取的 IO 转变成索引查找的顺序 IO</li>
</ul>
</li>
</ul>
<h4 id="超-100-万行的批量写-UPDATE-DELETE-INSERT-操作-要分批多次进行操作"><a href="#超-100-万行的批量写-UPDATE-DELETE-INSERT-操作-要分批多次进行操作" class="headerlink" title="超 100 万行的批量写 (UPDATE,DELETE,INSERT) 操作,要分批多次进行操作"></a>超 100 万行的批量写 (UPDATE,DELETE,INSERT) 操作,要分批多次进行操作</h4><ul>
<li><p><strong>大批量操作可能会造成严重的主从延迟</strong></p>
<p>主从环境中,大批量操作可能会造成严重的主从延迟，大批量的写操作一般都需要执行一定长的时间， 而只有当主库上执行完成后，才会在其他从库上执行，所以会造成主库与从库长时间的延迟情况</p>
</li>
<li><p><strong>binlog 日志为 row 格式时会产生大量的日志</strong>：大批量写操作会产生大量日志，特别是对于 row 格式二进制数据而言，由于在 row 格式中会记录每一行数据的修改，我们一次修改的数据越多，产生的日志量也就会越多，日志的传输和恢复所需要的时间也就越长，这也是造成主从延迟的一个原因</p>
</li>
<li><p><strong>避免产生大事务操作</strong>：大批量修改数据，一定是在一个事务中进行的，这就会造成表中大批量数据进行锁定，从而导致大量的阻塞，阻塞会对 MySQL 的性能产生非常大的影响。</p>
</li>
<li><p>特别是长时间的阻塞会占满所有数据库的可用连接，这会使生产环境中的其他应用无法连接到数据库，因此一定要注意大批量写操作要进行分批</p>
</li>
</ul>
<h3 id="索引详解"><a href="#索引详解" class="headerlink" title="索引详解"></a>索引详解</h3><h4 id="索引优缺点"><a href="#索引优缺点" class="headerlink" title="索引优缺点"></a>索引优缺点</h4><ul>
<li>优点：大大加快数据的检索速度；通过创建唯一性索引，可以保证数据库中每一行数据的唯一性</li>
<li>缺点：<ul>
<li>创建维护索引需要耗时，对数据进行增删改查也需要改变索引</li>
<li>索引需要物理空间存储</li>
<li>数据库数据量不大时，索引不一定有很好的效果</li>
</ul>
</li>
</ul>
<h4 id="索引底层数据结构？为什么不使用HashMap"><a href="#索引底层数据结构？为什么不使用HashMap" class="headerlink" title="索引底层数据结构？为什么不使用HashMap?"></a>索引底层数据结构？为什么不使用HashMap?</h4><ul>
<li><p><code>不使用HashMap</code>：HashMap不支持顺序和范围查询，无法很快查找某个范围类的数据</p>
</li>
<li><p>使用B+树作为索引数据结构</p>
<blockquote>
<p>使用B树或B+树作为索引结构主要是为了减少磁盘IO的次数，降低二叉平衡查找树的高度，因此B树和B+树都为<strong>多路平衡查找树</strong></p>
<ul>
<li><p>一个m阶的B树具有如下几个特征：</p>
<ul>
<li>根结点至少有两个子女</li>
<li>每个中间节点都包含k-1个元素和k个孩子，其中 m/2 &lt;= k &lt;= m</li>
<li>每一个叶子节点都包含k-1个元素，其中 m/2 &lt;= k &lt;= m</li>
<li>所有的叶子结点都位于同一层</li>
<li>每个节点中的元素从小到大排列，节点当中k-1个元素正好是k个孩子包含的元素的值域分划</li>
<li>每个结点都有卫星数据</li>
</ul>
</li>
<li><p>插入操作：判断当前结点key的个数是否小于等于m-1，如果满足，直接插入即可，如果不满足，将节点的中间的key将这个节点分为左右两部分，中间的节点放到父节点中即可</p>
</li>
<li><p>一个m阶的B+树具有如下特征：</p>
<ul>
<li>有k个子树的中间节点包含有k个元素，每个元素不保存数据，只用来索引，所有数据都保存在叶子节点（m/2 &lt;= k &lt;=m）</li>
<li>所有的叶子结点中包含了全部元素的信息，及指向含这些元素记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接</li>
<li>所有的中间节点元素都同时存在于子节点，在子节点元素中是最大（或最小）元素</li>
<li>根节点的最大（或最小）元素也就是整个B+树中最大（或最小）的元素，要一直保持</li>
<li>只有叶子节点有卫星数据</li>
</ul>
</li>
<li><p>B+树的优势：</p>
<ul>
<li>单一节点存储更多的元素，使得查询的IO次数更少</li>
<li>所有查询都要查找到叶子节点，查询性能稳定</li>
<li>所有叶子节点形成有序链表，便于范围查询</li>
</ul>
</li>
</ul>
</blockquote>
</li>
<li><p>MyISAM中，B+树叶节点的data域中存放的是数据记录的地址，取出data域的值后，还需要根据相应的地址取出相应的数据记录，这被称为<code>非聚簇索引</code></p>
</li>
<li><p>InnoDB中，其数据本身就是索引文件，树的叶节点data域保存了完整的数据记录，这被称为<code>聚簇索引</code>，这个索引的key是数据表的主键，而其余的索引都是辅助索引。辅助索引的data域存的是主键的值。</p>
<ul>
<li>根据主索引查找时，可以直接取出查找的数据</li>
<li>根据辅助索引查找时，首先查询到主键的值，再走主索引取出相应的值</li>
</ul>
</li>
</ul>
<h4 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h4><ul>
<li><strong>主键索引</strong>：主键列使用的索引。InnoDB 的表中，当没有显示的指定表的主键时，InnoDB 会自动先检查表中是否有唯一索引且不允许存在null值的字段，如果有，则选择该字段为默认的主键，否则 InnoDB 将会自动创建一个 6Byte 的自增主键</li>
<li><strong>二级索引（辅助索引）</strong>：<ul>
<li>唯一索引：唯一索引的属性列<strong>不能出现重复的数据</strong>，允许数据为NULL，一张表可以创建多个唯一索引。一般是为了数据的唯一性，而不是为了查询效率</li>
<li>普通索引：为了快速查询数据，可以创建多个普通索引，允许数据重复和NULL</li>
<li>前缀索引：只适用于字符串数据，对文本的前几个字符创建的索引，相比普通索引建立的数据更小，<strong>会导致覆盖索引优化失效</strong></li>
<li>全文索引：为了检索大文本数据中的关键字信息</li>
</ul>
</li>
</ul>
<h4 id="唯一索引和普通索引"><a href="#唯一索引和普通索引" class="headerlink" title="唯一索引和普通索引"></a>唯一索引和普通索引</h4><ul>
<li><p>二者查询性能差不多。主要区别在于更新的记录目标页不在内存中时，<strong>普通索引</strong>更新会使用change Buffer。<strong>唯一索引</strong>，由于需要校验数据的唯一性，因此每次更新操作都需要读磁盘把数据载进内存，涉及IO操作</p>
<ul>
<li>在不影响数据一致性的前提下， InnoDB会将这些更新操作缓存在change buffer中， 这样就不需要从磁盘中读入这个数据页了。 在下次查询需要访问这个数据页的时候， 将数据页读入内存， 然后执行change buffer中与这个页有关的操作。 通过这种方式就能保证这个数据逻辑的正确性</li>
<li>change buffer中的操作应用到原数据页，得到最新结果的过程称为merge<ol>
<li>访问这个数据页会触发merge。</li>
<li>系统有后台线程会定期merge。</li>
<li>在数据库正常关闭（shutdown） 的过程中，也会执行merge操作</li>
</ol>
</li>
</ul>
<blockquote>
<p>change Buffer与redo log 区别</p>
<ul>
<li>change Buffer主要用于减少读磁盘的次数，在必要读磁盘时再更新数据。</li>
<li>redo log 则是减少内存更新后，写磁盘的次数</li>
</ul>
<p>merge的执行流程是这样的：</p>
<ol>
<li>从磁盘读入数据页到内存（老版本的数据页）；</li>
<li>从change buffer里找出这个数据页的change buffer 记录(可能有多个），依次应用，得到新版数据页；</li>
<li>写redo log。这个redo log包含了数据的变更和change buffer的变更</li>
</ol>
</blockquote>
</li>
</ul>
<h4 id="聚集索引和非聚集索引"><a href="#聚集索引和非聚集索引" class="headerlink" title="聚集索引和非聚集索引"></a>聚集索引和非聚集索引</h4><ul>
<li><strong>聚集索引</strong>：索引结构和数据一起存放的索引。主键索引属于聚集索引，物理地址连续<ul>
<li>优点：查询速度快，不需要进行二次查询</li>
<li>缺点：<ul>
<li>依赖于有序的数据：如果索引的数据不是有序的，需要在插入时排序</li>
<li>更新代价大：被索引的列进行修改时，对应的索引也要修改，而叶子节点也包含着数据，也要更新，代价比较大。所以对于主键索引来说，一般不可被修改</li>
</ul>
</li>
</ul>
</li>
<li><strong>非聚集索引</strong>：索引结构和数据分开存放的索引。二级索引属于非聚集索引，逻辑上连续，物理地址不连续<ul>
<li>优点：更新代价比聚集索引小</li>
<li>缺点：<ul>
<li>依赖于有序的数据</li>
<li>可能会产生二次查询</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>非聚集索引不一定回表查询：查询的字段刚好建立了索引，直接返回就行了</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> name <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> name<span class="operator">=</span><span class="string">&#x27;guang19&#x27;</span>;</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h4><ul>
<li>一个索引包含（或者说覆盖）所有需要查询的字段的值，我们就称之为“覆盖索引”。覆盖索引就是把要查询出的列和索引是对应的，不做回表操作</li>
</ul>
<h4 id="索引失效"><a href="#索引失效" class="headerlink" title="索引失效"></a>索引失效</h4><ul>
<li>where语句中包含or时，可能会导致索引失效<ul>
<li>若or的条件中包含非索引，就会只用全表扫描的。如果or的条件两边都是索引，那么会使用<code>index_merge</code>的优化技术</li>
<li>index_merge：<strong>对多个索引分别进行条件扫描，然后将它们各自的结果进行合并</strong></li>
</ul>
</li>
<li>where语句中索引列使用了负向查询，可能会导致索引失效<ul>
<li>负向查询包括：NOT、!=、&lt;&gt;、!&lt;、!&gt;、NOT IN、NOT LIKE等</li>
</ul>
</li>
<li>对索引列进行<strong>运算</strong>，一定会导致索引失效</li>
<li>在索引列上使用<strong>内置函数</strong>，一定会导致索引失效</li>
<li>like通配符可能会导致索引失效，未满足最左匹配原则。</li>
<li>隐式类型转换导致的索引失效，如索引列user_id为varchar类型，使用int做条件关联。或者关联表字符集编码不一致。</li>
<li>索引字段可以为null，使用is null或is not null时，可能会导致索引失效</li>
<li>联合索引未满足最左匹配原则</li>
</ul>
<h4 id="建立索引的注意事项"><a href="#建立索引的注意事项" class="headerlink" title="建立索引的注意事项"></a>建立索引的注意事项</h4><ul>
<li><p><strong>选择合适的字段创建索引：</strong></p>
<ul>
<li><p><strong>不为 NULL 的字段</strong> ：索引字段的数据应该尽量不为 NULL，因为对于数据为 NULL 的字段，数据库较难优化。如果字段频繁被查询，但又避免不了为 NULL，建议使用 0,1,true,false 这样语义较为清晰的短值或短字符作为替代。</p>
</li>
<li><p><strong>被频繁查询的字段</strong> ：我们创建索引的字段应该是查询操作非常频繁的字段。</p>
</li>
<li><p><strong>被作为条件查询的字段</strong> ：被作为 WHERE 条件查询的字段，应该被考虑建立索引。</p>
</li>
<li><p><strong>频繁需要排序的字段</strong> ：索引已经排序，这样查询可以利用索引的排序，加快排序查询时间。</p>
</li>
<li><p><strong>被经常频繁用于连接的字段</strong> ：经常用于连接的字段可能是一些外键列，对于外键列并不一定要建立外键，只是说该列涉及到表与表的关系。对于频繁被连接查询的字段，可以考虑建立索引，提高多表连接查询的效率。</p>
</li>
</ul>
</li>
<li><p><strong>被频繁更新的字段应该慎重建立索引</strong>：虽然索引能带来查询上的效率，但是维护索引的成本也是不小的。 如果一个字段不被经常查询，反而被经常修改，那么就更不应该在这种字段上建立索引了。</p>
</li>
<li><p><strong>尽可能的考虑建立联合索引而不是单列索引</strong>：因为索引是需要占用磁盘空间的，可以简单理解为每个索引都对应着一颗 B+树。如果一个表的字段过多，索引过多，那么当这个表的数据达到一个体量后，索引占用的空间也是很多的，且修改索引时，耗费的时间也是较多的。如果是联合索引，多个字段在一个索引上，那么将会节约很大磁盘空间，且修改数据的操作效率也会提升。</p>
</li>
<li><p><strong>注意避免冗余索引</strong>：冗余索引指的是索引的功能相同，能够命中索引(a, b)就肯定能命中索引(a) ，那么索引(a)就是冗余索引。如（name,city ）和（name ）这两个索引就是冗余索引，能够命中前者的查询肯定是能够命中后者的 在大多数情况下，都应该尽量扩展已有的索引而不是创建新索引。</p>
</li>
<li><p><strong>考虑在字符串类型的字段上使用前缀索引代替普通索引</strong>：前缀索引仅限于字符串类型，较普通索引会占用更小的空间，所以可以考虑使用前缀索引带替普通索引</p>
</li>
</ul>
<h4 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h4><ul>
<li>最左匹配原则：查询条件中必须要有联合索引的第一个字段才可以使用索引</li>
<li>索引覆盖：不满足最左匹配原则的情况下，如果查询的字段都在联合索引中，也可以使用到索引，并且不需要回表操作</li>
</ul>
<h3 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h3><h4 id="redo-log-重做日志"><a href="#redo-log-重做日志" class="headerlink" title="redo log(重做日志)"></a>redo log(重做日志)</h4><ul>
<li><p>InnoDB独有，在系统崩溃时可以通过<code>redo log</code>恢复数据</p>
</li>
<li><p>MySQL中，查询记录是会一次将一页的信息都查询出来，加载到<code>Buffer Pool</code>中，后续查询都在<code>Buffer Pool</code>中进行，减少IO开销，更新数据也会在<code>Buffer Pool</code>中更新。然后会把在这个数据页上所做的修改，记录到<code>redo log buffer</code>中，接着刷盘到<code>redo log</code>文件中</p>
<blockquote>
<p>理想情况下，事务一提交就会进行刷盘，但实际情况下，刷盘的实际是根据策略来进行的</p>
<p> 每条redo记录由<code>表空间号+数据页号+偏移量+修改数据长度+具体修改数据</code>组成</p>
</blockquote>
</li>
<li><p><strong>刷盘时机</strong>：通过设置<code>innodb_flush_log_at_trx_commit</code>参数，支持三种策略</p>
<ul>
<li><p>0：每次事务提交时不进行刷盘操作，宕机或者崩溃可能会有1秒的数据损失</p>
</li>
<li><p>1：每次事务提交时进行刷盘操作（默认），不会有数据损失</p>
</li>
<li><p>2：每次事务提交时，只把redo log buffer内容写入page cache，MySQL崩溃不会有损失，宕机可能会有一秒损失</p>
</li>
<li><p>除此之外，InnoDB引擎有一个后台线程，每隔1秒，会把<code>redo log buffer</code>中的内容写入文件系统缓存（page cache）中，然后调用<code>fsync</code>进行刷盘。当<code>redo log buffer</code>占用空间即将达到<code>innodb_log_buffer_size</code>一半时，后台线程也会主动刷盘</p>
</li>
</ul>
<p><img src="/2022/01/03/day29/day29_20.png" alt="刷盘"></p>
</li>
<li><p><strong>日志文件组</strong>：硬盘上存储的 <code>redo log</code> 日志文件不只一个，而是以一个<strong>日志文件组</strong>的形式出现的，每个的<code>redo</code>日志文件大小都是一样的</p>
<ul>
<li><strong>write pos</strong> ：当前记录的位置，一边写一边后移</li>
<li><strong>checkpoint</strong> ：当前要擦除的位置，也是往后推移</li>
<li>每次刷盘写入日志时，write pos会后移；每次MySQL加载日志文件组恢复数据时，会清空加载过的<code>redo log</code>，checkpoint会后移</li>
</ul>
</li>
</ul>
<h4 id="binlog"><a href="#binlog" class="headerlink" title="binlog"></a>binlog</h4><ul>
<li><p>binlog是逻辑日志，记录内容是语句的原始逻辑，属于<code>MySQL Server</code>层。不管使用什么引擎，只要发生表更新，都会产生binlog。<strong>主要用于主从复制和数据恢复</strong></p>
</li>
<li><p><strong>三种格式</strong>：</p>
<ul>
<li>statement：记录SQL语句原文</li>
<li>row：记录SQL原句和操作的具体数据，比较占用空间</li>
<li>mixed：statement和row的混合，如果SQL语句会引起数据不一致，使用row；否则，使用statement</li>
</ul>
</li>
<li><p><strong>写入时机</strong>：事务执行过程中，先将日志写到binlog cache，事务提交时，再将binlog cache写入binlog文件中。</p>
<ul>
<li>一个事务的<code>binlog</code>不能被拆开，无论这个事务多大，也要确保一次性写入，所以系统会给每个线程分配一个块内存作为<code>binlog cache</code></li>
<li>设置<code>sync_binlog</code>控制刷盘时机：<ul>
<li>0：每次提交事务只write，系统自行判断执行fsync</li>
<li>1：每次提交事务都fsync</li>
<li>N：累计N个事务再执行fsync</li>
</ul>
</li>
</ul>
<p><img src="/2022/01/03/day29/day29_21.png" alt="binlog"></p>
</li>
</ul>
<h4 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a>两阶段提交</h4><ul>
<li><p><code>redo log</code>（重做日志）让<code>InnoDB</code>存储引擎拥有了崩溃恢复能力；<code>binlog</code>（归档日志）保证了<code>MySQL</code>集群架构的数据一致性，但二者的写入时机不同</p>
<p><img src="/2022/01/03/day29/day29_22.png" alt="写入时机"></p>
</li>
<li><p>为了防止binlog和redo log数据不一致，将<code>redo log</code>的写入拆成了两个步骤<code>prepare</code>和<code>commit</code>两个阶段</p>
<ul>
<li>在使用<code>redo log</code>恢复数据时，如果发现redo log还处于 prepare阶段，并且没有对应的binlog，就会回滚该事务</li>
</ul>
<p><img src="/2022/01/03/day29/day29_23.png" alt="两阶段提交"></p>
</li>
</ul>
<h4 id="undo-log-回滚日志"><a href="#undo-log-回滚日志" class="headerlink" title="undo log(回滚日志)"></a>undo log(回滚日志)</h4><ul>
<li>保证事务的原子性，所有事务的修改都会先记录到undo log中，在执行相关操作。回滚日志会优先于数据持久化到磁盘上，宕机也可以回滚</li>
</ul>
<h3 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h3><h4 id="InnoDB对MVCC的实现"><a href="#InnoDB对MVCC的实现" class="headerlink" title="InnoDB对MVCC的实现"></a>InnoDB对MVCC的实现</h4><ul>
<li>通过隐藏字段、Read View和undo log实现MVCC<ul>
<li>隐藏字段：每行数据有三个隐藏字段<ul>
<li><code>DB_TRX_ID</code>：最后一次插入或者更新该行的事务id</li>
<li><code>DB_ROLL_PTR</code>：回滚指针，指向改行的undo log</li>
<li><code>DB_ROW_ID</code>：没有主键且没有唯一非空索引的情况下，<code>InnoDB</code>会使用该id生成聚簇索引</li>
</ul>
</li>
<li>ReadView：主要用来做可见性判断，保存了当前对本事务不可见的其他活跃事务<ul>
<li><code>m_low_limit_id</code>：目前出现过的最大的事务 ID+1，即下一个将被分配的事务 ID。大于等于这个 ID 的数据版本均不可见</li>
<li><code>m_up_limit_id</code>：活跃事务列表 <code>m_ids</code> 中最小的事务 ID，如果 <code>m_ids</code> 为空，则 <code>m_up_limit_id</code> 为 <code>m_low_limit_id</code>。小于这个 ID 的数据版本均可见</li>
<li><code>m_ids</code>：<code>Read View</code> 创建时其他未提交的活跃事务 ID 列表。创建 <code>Read View</code>时，将当前未提交事务 ID 记录下来，后续即使它们修改了记录行的值，对于当前事务也是不可见的。<code>m_ids</code> 不包括当前事务自己和已提交的事务（正在内存中）</li>
<li><code>m_creator_trx_id</code>：创建该 <code>Read View</code> 的事务 ID</li>
</ul>
</li>
<li>undo log：若该记录被其他事务占用或当前版本对该事务不可见，则可以通过 <code>undo log</code> 读取之前的版本数据，以此实现非锁定读</li>
</ul>
</li>
<li><strong>数据可见性算法</strong>：本次事务中读取某一行的数据<ul>
<li>如果<code>DB_TRX_ID</code>&lt;<code>m_up_limit_id</code>，则可见</li>
<li>如果<code>DB_TRX_ID</code>&gt;=<code>m_low_limit_id</code>，表明事务快照之后才出现这一行数据，不可见</li>
<li><code>m_ids</code>为空，表示当前事务是最新的事务，可见</li>
<li>如果<code>m_up_limit_id</code>&lt;=<code>DB_TRX_ID</code>&lt;<code>m_low_limit_id</code>，若该事务id存在m_ids中，则不可见，否则可见</li>
<li>如果事务不可见，可以通过<code>DB_ROLL_PTR</code>指针，查询该行的历史数据是否可见</li>
</ul>
</li>
</ul>
<h4 id="RC和RR隔离级别下MVCC的ReadView生成时机不同"><a href="#RC和RR隔离级别下MVCC的ReadView生成时机不同" class="headerlink" title="RC和RR隔离级别下MVCC的ReadView生成时机不同"></a>RC和RR隔离级别下MVCC的ReadView生成时机不同</h4><ul>
<li>RC下，每次查询前都要生成一个ReadView</li>
<li>RR下，只有第一次查询生成一个ReadView</li>
</ul>
<h4 id="MVCC-Next-key-Lock防止幻读（RR隔离级别）"><a href="#MVCC-Next-key-Lock防止幻读（RR隔离级别）" class="headerlink" title="MVCC+Next-key-Lock防止幻读（RR隔离级别）"></a>MVCC+Next-key-Lock防止幻读（RR隔离级别）</h4><ul>
<li>执行普通的select语句：为快照读，只在第一次查询时生成ReadView，后续事务提交不影响，可以解决幻读</li>
<li>执行select…for update/lock in share mode、insert、update、delete等语句：为锁定读，读取的是最新的数据。InnoDB使用Next-key-Lock锁定读取到的记录以及它们之间的间隙，防止其他事务在查询范围内插入数据，防止了幻读</li>
</ul>
<p><img src="/2022/01/03/day29/day29_24.png" alt="SQL语句执行流程"></p>
<blockquote>
<ul>
<li>查询语句的执行流程如下：权限校验（如果命中缓存）—&gt;查询缓存—&gt;分析器—&gt;优化器—&gt;权限校验—&gt;执行器—&gt;引擎</li>
<li>更新语句执行流程如下：分析器—-&gt;权限校验—-&gt;执行器—&gt;引擎—redo log(prepare 状态)—&gt;binlog—&gt;redo log(commit状态)</li>
</ul>
</blockquote>
<h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><h4 id="锁分类"><a href="#锁分类" class="headerlink" title="锁分类"></a>锁分类</h4><ul>
<li>全局锁：对整个数据库实例加锁，命令：<code>Flush tables with read lock (FTWRL)</code><ul>
<li>应用场景：全库逻辑备份</li>
</ul>
</li>
<li>表锁：分为表锁和元数据锁<ul>
<li>表锁：<code>lock tables t1 read,t2 write</code><ul>
<li>对其他线程来说，t1表，可以读，不可以写；t2表，读写都不可以</li>
<li>对本线程来说，t1表只能读，t2表只能读写</li>
</ul>
</li>
<li>元数据锁：Metadata Lock(MDL)，面向DML和DDL之间得并发控制，元数据锁不需要我们显式的加，系统默认会加<ul>
<li>当做DML操作时，会申请一个MDL读锁</li>
<li>当做DDL操作时，会申请一个MDL写锁</li>
<li>读锁之间不互斥，读写和写写之间都互斥</li>
</ul>
</li>
</ul>
</li>
<li>行锁：InnoDB的行锁是针对索引加的，而不是针对记录，该索引不能失效，否则会升级为表锁<ul>
<li><code>select * from t lock in share mode</code></li>
</ul>
</li>
</ul>
<h4 id="两阶段锁"><a href="#两阶段锁" class="headerlink" title="两阶段锁"></a>两阶段锁</h4><ul>
<li><p>在InnoDB事务中， 行锁是在需要的时候才加上的， 但并不是不需要了就立刻释放， 而是要等到事务结束时才释放</p>
<ul>
<li>事务B要在事务A提交之后才会执行</li>
</ul>
<p><img src="/2022/01/03/day29/day29_30.png" alt="示例"></p>
</li>
<li><p>出现死锁：</p>
<ul>
<li>进入等待，超时</li>
<li>发起死锁检测，回滚死锁链中的某一个事务，打破死锁</li>
</ul>
</li>
</ul>
<h4 id="加锁原则"><a href="#加锁原则" class="headerlink" title="加锁原则"></a>加锁原则</h4><ul>
<li>原则1： 加锁的基本单位是next-keylock，前开后闭区间</li>
<li>原则2： 查找过程中访问到的对象才会加锁</li>
<li>优化1： 索引上的等值查询， 给唯一索引加锁的时候， next-keylock退化为行锁</li>
<li>优化2： 索引上的等值查询， 向右遍历时且最后一个值不满足等值条件的时候， next-key lock退化为间隙锁。</li>
<li>一个bug： 唯一索引上的范围查询会访问到不满足条件的第一个值为止。</li>
</ul>
<h3 id="特殊情况处理"><a href="#特殊情况处理" class="headerlink" title="特殊情况处理"></a>特殊情况处理</h3><h4 id="超大分页如何处理？"><a href="#超大分页如何处理？" class="headerlink" title="超大分页如何处理？"></a>超大分页如何处理？</h4><ul>
<li>使用主键id优化，找到上次分页的最大ID，利用主键索引进行查询。<strong>要求ID必须是连续的</strong></li>
<li>覆盖索引优化，先查出索引的主键ID，再使用主键索引拿数据</li>
</ul>
<h4 id="优化SQL？"><a href="#优化SQL？" class="headerlink" title="优化SQL？"></a>优化SQL？</h4><ul>
<li>添加合适索引：索引创建原则</li>
<li>优化表结构：数据类型越小越好、尽量少使用NULL</li>
<li>优化查询语句：是否命中索引等</li>
</ul>
<h4 id="分布式主键方案？"><a href="#分布式主键方案？" class="headerlink" title="分布式主键方案？"></a>分布式主键方案？</h4><ul>
<li>数据库自增序列</li>
<li>UUID</li>
<li>Redis生成ID</li>
<li>等</li>
</ul>
<h4 id="分库分表？"><a href="#分库分表？" class="headerlink" title="分库分表？"></a>分库分表？</h4><ul>
<li><p>分表：单表数据量过大，会影响查询性能。将一个表的数据放在多个表中</p>
<ul>
<li><p>垂直分表：把一个表的多个字段拆分为多个表，一般将字段作冷热拆分，冷字段一个表，热字段一个表</p>
<p><img src="/2022/01/03/day29/day29_31.png" alt="垂直分表案例"></p>
</li>
<li><p>水平分表：减少单个表中的数据量</p>
</li>
</ul>
</li>
<li><p>分库：单库的并发量最多到2000，将一个库的数据拆分到多个库中，可以增加并发量</p>
<ul>
<li><p>垂直分库：将关联度低的表存放在不同的库中</p>
<p><img src="/2022/01/03/day29/day29_32.png" alt="垂直分库案例"></p>
</li>
<li><p>水平分库：提升单个业务系统的QPS</p>
<p><img src="/2022/01/03/day29/day29_33.png" alt="水平分库案例"></p>
</li>
</ul>
</li>
<li><p>垂直切分的优缺点：</p>
<ul>
<li>优点：切合业务系统结构；方便对数据进行管理；提升系统的高并发性能</li>
<li>缺点：没有解决单表数据量过大的问题；分布式事务处理复杂</li>
</ul>
</li>
<li><p>水平切分的优缺点：</p>
<ul>
<li>优点：提升系统性能，不存在性能瓶颈；对业务没有影响</li>
<li>缺点：数据多次扩展难度和维护大</li>
</ul>
</li>
</ul>
<h4 id="大表查询优化"><a href="#大表查询优化" class="headerlink" title="大表查询优化"></a>大表查询优化</h4><ul>
<li>优化sql语句，增加索引</li>
<li>增加缓存，使用redis</li>
<li>主从复制，读写分离</li>
<li>分库分表</li>
</ul>
<h4 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h4><p><img src="/2022/01/03/day29/day29_34.png" alt="主从复制过程"></p>
<ul>
<li><ol>
<li><p>Master的更新事件(update、insert、delete)会按照顺序写入bin-log中。当Slave连接到Master的后,Master机器会为Slave开启  binlog dump线程,该线程会去读取bin-log日志  </p>
</li>
<li><p>Slave连接到Master后,Slave库有一个I/O线程 通过请求binlog dump thread读取bin-log日志,然后写入从库的relay log日志中。  </p>
</li>
<li><p>Slave还有一个 SQL线程,实时监控 relay-log日志内容是否有更新,解析文件中的SQL语句,在Slave数据库中去执行。</p>
</li>
</ol>
</li>
</ul>
<h4 id="主从复制同步方式"><a href="#主从复制同步方式" class="headerlink" title="主从复制同步方式"></a>主从复制同步方式</h4><ul>
<li><strong>异步复制</strong>  ：Mysql主从同步 默认是异步复制的。就是上面三步中,只有第一步是同步的(也就是Mater写入bin log日志),就是主库写入binlog日志后即可成功返回客户端，无须等待binlog日志传递给从库的过程。  Master 不关心 Slave 的数据有没有写入成功。因此如果Master和Slave之间有网络延迟，就会造成暂时的数据不一致的现象；如果Master出故障，而数据还没有复制过去，则会造成数据丢失；但也有好处，<strong>效率较其他两种复制方式最高</strong>。 </li>
<li><strong>同步复制</strong>  ：Master主机将事件发送给Slave主机后会触发一个等待，直到所有Slave节点（如果有多个Slave）返回数据复制成功的信息给Master。 这种复制方式最安全，但是同时，效率也是最差的。  </li>
<li><strong>半同步复制</strong>  ：对于半同步复制而言，Master主机将事件发送给Slave主机后会触发一个等待，直到其中一个Slave节点（如果有多个Slave）返回数据复制成功的信息给Master。  由此增强了数据的一致性，但是因为Master主机的确认开销，会损耗一部分的性能； 另外，半同步复制除了不需要等待所有Slave主机确认事件的接收外，半同步数据复制并不要求那些事件完全地执行，因此，仍有可能看到在Slave主机上数据复制延迟的发生，如果因为网络延迟等原因造成Slave迟迟没有返回复制成功的信息，超过了Master设置的超时时长，<strong>半同步复制就降级为异步复制方式</strong>，而后继续数据复制。</li>
</ul>
<h4 id="Mysql主从同步延时产生原因-怎么优化？"><a href="#Mysql主从同步延时产生原因-怎么优化？" class="headerlink" title="Mysql主从同步延时产生原因?怎么优化？"></a>Mysql主从同步延时产生原因?怎么优化？</h4><ul>
<li>原因：<ul>
<li>主节点如果执行一个很大的事务，会对主从延迟产生较大的影响</li>
<li>网络延迟，日志较大，slave数量过多</li>
<li>机器性能问题，从节点是否使用了“烂机器”</li>
</ul>
</li>
<li>优化：<ul>
<li>大事务：将大事务分为小事务，分批更新数据</li>
<li>减少Slave的数量，不要超过5个，减少单次事务的大小</li>
</ul>
</li>
</ul>
<h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><h3 id="Redis为什么快？"><a href="#Redis为什么快？" class="headerlink" title="Redis为什么快？"></a>Redis为什么快？</h3><ul>
<li><strong>基于内存</strong>：Redis是使用内存存储，没有磁盘IO上的开销。数据存在内存中，读写速度快。</li>
<li><strong>单线程实现</strong>（ Redis 6.0以前）：Redis使用单个线程处理请求，避免了多个线程之间线程切换和锁资源争用的开销。</li>
<li><strong>IO多路复用模型</strong>：Redis 采用 IO 多路复用技术。Redis 使用单线程来轮询描述符，将数据库的操作都转换成了事件，不在网络I/O上浪费过多的时间。</li>
<li><strong>高效的数据结构</strong>：Redis 每种数据类型底层都做了优化，目的就是为了追求更快的速度。</li>
</ul>
<h3 id="Redis应用场景有哪些？"><a href="#Redis应用场景有哪些？" class="headerlink" title="Redis应用场景有哪些？"></a>Redis应用场景有哪些？</h3><ul>
<li><strong>缓存热点数据</strong>，缓解数据库的压力。 </li>
<li>利用 Redis 原子性的自增操作，可以实现<strong>计数器</strong>的功能，比如统计用户点赞数、用户访问数等。 </li>
<li><strong>简单的消息队列</strong>，可以使用Redis自身的发布/订阅模式或者List来实现简单的消息队列，实现异步操作。 </li>
<li><strong>限速器</strong>，可用于限制某个用户访问某个接口的频率，比如秒杀场景用于防止用户快速点击带来不必要的压力。 </li>
<li><strong>好友关系</strong>，利用集合的一些命令，比如交集、并集、差集等，实现共同好友、共同爱好之类的功能。</li>
</ul>
<h3 id="Redis-数据类型有哪些？"><a href="#Redis-数据类型有哪些？" class="headerlink" title="Redis 数据类型有哪些？"></a>Redis 数据类型有哪些？</h3><ul>
<li><p><strong>基本数据类型</strong>：</p>
<ul>
<li><strong>String</strong>：String类型的值可以是字符串、数字或者二进制，但值最大不能超过512MB。可以存储编码后的数据<ul>
<li>String的数据结构为**简单动态字符串(Simple Dynamic String,缩写SDS)**。内部结构实现上类似于Java的ArrayList，采用预分配冗余空间的方式来减少内存的频繁分配</li>
</ul>
</li>
<li><strong>Hash</strong>：Hash 是一个键值对集合。适合存储对象<ul>
<li>Hash类型对应的数据结构是两种：ziplist（压缩列表），hashtable（哈希表）。当field-value长度较短且个数较少时，使用ziplist，否则使用hashtable</li>
</ul>
</li>
<li><strong>Set</strong>：无序去重的集合。Set 提供了交集、并集等方法，对于实现共同好友、共同关注等功能特别方便<ul>
<li>底层是一个value为null的hash表</li>
</ul>
</li>
<li><strong>List</strong>：有序可重复的集合，实际上是一个双向链表。<ul>
<li>List的数据结构采用快速链表quickList</li>
<li>在列表元素较少的情况下会使用一块连续的内存存储，这个结构是ziplist，也即是压缩列表<ul>
<li>ziplist将所有的元素紧挨着一起存储，分配的是一块连续的内存</li>
</ul>
</li>
<li>当数据量比较多的时候才会改成quickList<ul>
<li>quickList将链表和ziplist进行结合，构成了快速链表，减少了空间冗余</li>
</ul>
</li>
</ul>
</li>
<li><strong>SortedSet</strong>：有序Set。内部维护了一个<code>score</code>的参数来实现。适用于排行榜和带权重的消息队列等场景。<ul>
<li>zset底层使用了两个数据结构:<ul>
<li>hash，hash的作用就是关联元素value和权重score，保障元素value的唯一性，可以通过元素value找到相应的score值</li>
<li>跳跃表，跳跃表的目的在于给元素value排序，根据score的范围获取元素列表。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>特殊的数据类型</strong>：</p>
<ul>
<li><strong>Bitmap</strong>：位图，其实是一个字符串，字符串每一位只能是0或1,下标在 Bitmap 中叫做偏移量。可以用于统计用户状态，例如是否订阅新闻。比较节约空间</li>
<li><strong>Hyperloglog</strong>。HyperLogLog 是用来做基数统计，也就是求解集合中不重复元素个数。其优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定的、并且是很小的。<strong>典型的使用场景是统计独立访客。他只是统计数量，并不能返回统计的元素</strong></li>
<li><strong>Geospatial</strong> ：主要用于存储地理位置信息，并对存储的信息进行操作，适用场景如定位、附近的人等。</li>
</ul>
</li>
</ul>
<h3 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h3><ul>
<li><p>RDB：在指定的<strong>时间间隔</strong>内，将内存中的<strong>数据集快照</strong>写入到磁盘中。恢复时将快照文件直接读到内存里</p>
<ul>
<li>优点：RDB恢复数据速度高于AOF；使用子线程进行持久化，主线程继续处理，性能更高</li>
<li>缺点：出现异常会丢失最后一次持久化的数据；<strong>RDB方式<a target="_blank" rel="noopener" href="https://www.nowcoder.com/jump/super-jump/word?word=%E6%95%B0%E6%8D%AE">数据</a>无法做到实时持久化</strong>。因为<code>BGSAVE</code>每次运行都要执行<code>fork</code>操作创建子进程，属于重量级操作，频繁执行成本比较高。</li>
</ul>
<p><img src="/2022/01/03/day29/day29_35.png" alt="RDB持久化流程"></p>
</li>
<li><p>AOF:以日志的形式记录<strong>写操作</strong>（不记录读操作），将Redis执行过的所有指令记录下来，<strong>只允许追加文件不允许修改文件</strong>。redis启动之初会读取该文件重新构建数据。主要作用是<strong>解决了<a target="_blank" rel="noopener" href="https://www.nowcoder.com/jump/super-jump/word?word=%E6%95%B0%E6%8D%AE">数据</a>持久化的实时性</strong>，AOF 是Redis持久化的主流方式。</p>
<ul>
<li><p>AOF缓冲区根据AOF持久化策略**[always,everysec,no]**将操作sync同步到磁盘的AOF文件中</p>
<ul>
<li>always：每次写入都记入日志</li>
<li>everysec：每秒记录一次</li>
<li>no：redis不主动同步，将同步时机交给操作系统</li>
</ul>
</li>
<li><p>优点：AOF可以更好的保护<a href>数据</a>不丢失，可以配置 AOF 每秒执行一次<code>fsync</code>操作，如果Redis进程挂掉，最多丢失1秒的数据；</p>
<p>AOF以<code>append-only</code>的模式写入，所以没有磁盘寻址的开销，写入性能非常高</p>
</li>
<li><p>缺点：数据恢复慢；AOF文件大<br><img src="/2022/01/03/day29/day29_36.png" alt="AOF流程"></p>
</li>
</ul>
</li>
</ul>
<h3 id="主从复制-1"><a href="#主从复制-1" class="headerlink" title="主从复制"></a>主从复制</h3><ul>
<li>当启动一个从节点时，它会发送一个 <code>PSYNC</code> 命令给主节点；</li>
<li>如果是从节点初次连接到主节点，那么会触发一次全量复制。此时主节点会启动一个后台线程，开始生成一份 <code>RDB</code> 快照文件；同时还会将从客户端 client 新收到的所有写命令缓存在内存中。<code>RDB</code> 文件生成完毕后， 主节点会将<code>RDB</code>文件发送给从节点，从节点会先将<code>RDB</code>文件<strong>写入本地磁盘，然后再从本地磁盘加载到内存中</strong>； 接着主节点会将内存中缓存的写命令发送到从节点，从节点同步这些<a href>数据</a>； </li>
<li>如果从节点跟主节点之间网络出现故障，连接断开了，会自动重连，连接之后主节点仅会将部分缺失的<a href>数据</a>同步给从节点。</li>
</ul>
<h3 id="过期键的删除策略？"><a href="#过期键的删除策略？" class="headerlink" title="过期键的删除策略？"></a>过期键的删除策略？</h3><ul>
<li><p><strong>被动删除</strong>。在访问key时，如果发现key已经过期，那么会将key删除。</p>
</li>
<li><p><strong>主动删除</strong>。定时清理key，每次清理会依次遍历所有DB，从db随机取出20个key，如果过期就删除，如果其中有5个key过期，那么就继续对这个db进行清理，否则开始清理下一个db。</p>
</li>
<li><p><strong>内存不够时清理</strong>。Redis有最大内存的限制，通过maxmemory参数可以设置最大内存，当使用的内存超过了设置的最大内存，就要进行内存释放， 在进行内存释放的时候，会按照配置的淘汰策略清理内存</p>
</li>
</ul>
<h3 id="内存淘汰策略有哪些？"><a href="#内存淘汰策略有哪些？" class="headerlink" title="内存淘汰策略有哪些？"></a>内存淘汰策略有哪些？</h3><ul>
<li><p>当Redis的内存超过最大允许的内存之后，Redis 会触发内存淘汰策略，删除一些不常用的<a href>数据</a>，以保证Redis服务器正常运行。</p>
</li>
<li><p><strong>volatile-lru</strong>：LRU（<code>Least Recently Used</code>），<strong>最近使用</strong>。利用LRU<a href>算法</a>移除设置了过期时间的key </p>
</li>
<li><p><strong>allkeys-lru</strong>：从<a href>数据</a>集中移除<strong>最近最少使用</strong>的key </p>
</li>
<li><p><strong>volatile-ttl</strong>：从已设置过期时间的<a href>数据</a>集中挑选<strong>将要过期的数据淘汰</strong> </p>
</li>
<li><p><strong>volatile-random</strong>：从已设置过期时间的<a href>数据</a>集中<strong>任意选择<a href>数据</a>淘汰</strong> </p>
</li>
<li><p><strong>allkeys-random</strong>：从<a href>数据</a>集中<strong>任意选择<a href>数据</a>淘汰</strong> </p>
</li>
<li><p><strong>no-eviction</strong>：**禁止删除<a href>数据</a>**，当内存不足以容纳新写入<a href>数据</a>时，新写入操作会报错 </p>
</li>
<li><p><strong>volatile-lfu</strong>：LFU，Least Frequently Used，最少使用，从已设置过期时间的<a href>数据</a>集中挑选<strong>最不经常使用的<a href>数据</a>淘汰</strong>。 </p>
</li>
<li><p><strong>allkeys-lfu</strong>：当内存不足以容纳新写入<a href>数据</a>时，<strong>从<a href>数据</a>集中移除最不经常使用的key</strong>。 </p>
</li>
</ul>
<h3 id="如何保证缓存与数据库双写时的数据一致性？"><a href="#如何保证缓存与数据库双写时的数据一致性？" class="headerlink" title="如何保证缓存与数据库双写时的数据一致性？"></a>如何保证缓存与数据库双写时的数据一致性？</h3><ul>
<li><p><strong>先删除缓存再更新数据库</strong>：进行更新操作时，先删除缓存，然后更新<a href>数据</a>库，后续的请求再次读取时，会从<a href>数据</a>库读取后再将新<a href>数据</a>更新到缓存。</p>
<ul>
<li>问题：删除缓存<a href>数据</a>之后，更新<a href>数据</a>库完成之前，<strong>这个时间段内如果有新的读请求过来</strong>，就会从<a href>数据</a>库读取旧<a href>数据</a>重新写到缓存中，再次造成不一致，并且后续读的都是旧<a href>数据</a>。</li>
</ul>
</li>
<li><p><strong>先更新<a href>数据</a>库再删除缓存</strong>：进行更新操作时，先更新MySQL，成功之后，删除缓存，后续读取请求时再将新<a href>数据</a>回写缓存。</p>
<ul>
<li>问题：<strong>更新MySQL和删除缓存这段时间内，请求读取的还是缓存的旧数据</strong>，不过等<a href>数据</a>库更新完成，就会恢复一致，影响相对比较小。</li>
</ul>
</li>
<li><p><strong>异步更新缓存</strong>：<a href>数据</a>库的更新操作完成后不直接操作缓存，而是把这个操作命令封装成消息扔到消息队列中，然后由Redis自己去消费更新<a href>数据</a>，消息队列可以保证<a href>数据</a>操作顺序一致性，确保缓存系统的<a href>数据</a>正常。</p>
</li>
</ul>
<h2 id="kafka"><a href="#kafka" class="headerlink" title="kafka"></a>kafka</h2><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul>
<li>异步处理：将原本串行处理的业务，转为分块异步处理</li>
<li>应用解耦：<ul>
<li>A系统进行订单创建，需要通知B、C系统作相应操作。A系统是强依赖BC系统的，如果此时BC系统出现了问题，换成了另一个D系统，则代码就需要进行修改</li>
<li>使用消息队列的方式，A系统只用发送消息即可，不用再关心BC系统的状态，进行了解耦</li>
</ul>
</li>
<li>流量削峰：<ul>
<li>某个系统平时qps比较低，做活动时qps激增，但系统的处理能力达不到，可以使用消息队列的形式，一方面可以缓解qps压力，另一方面也可以控制参加活动人数，超过限制就丢弃</li>
</ul>
</li>
</ul>
<h3 id="kafka的消费者是pull还是push模式，这种模式有什么好处？"><a href="#kafka的消费者是pull还是push模式，这种模式有什么好处？" class="headerlink" title="kafka的消费者是pull还是push模式，这种模式有什么好处？"></a>kafka的消费者是pull还是push模式，这种模式有什么好处？</h3><ul>
<li>producer将消息push到broker，consumer从broker对消息进行pull</li>
<li>优点：pull模式消费者自主决定是否批量从broker拉取数据，而push模式在无法知道消费者消费能力情况下，不易控制推送速度，太快可能造成消费者奔溃，太慢又可能造成浪费</li>
<li>缺点：如果 broker 没有可供消费的消息，将导致 consumer 不断在循环中轮询，直到新消息到到达</li>
</ul>
<h3 id="kafka集群组成"><a href="#kafka集群组成" class="headerlink" title="kafka集群组成"></a>kafka集群组成</h3><p><img src="/2022/01/03/day29/day29_58.png" alt="kafka组成"></p>
<ul>
<li>  <strong>Broker</strong>：消息中间件处理节点，一个Kafka节点就是一个Broker，一个或者多个Broker可以组成一个Kafka集群</li>
<li>  <strong>Topic</strong>：每条发布到Kafka集群的消息都有一个类别，这个类别被称为Topic。（物理上不同Topic的消息分开存储，逻辑上一个Topic的消息虽然保存于一个或多个broker上但用户只需指定消息的Topic即可生产或消费数据而不必关心数据存于何处）</li>
<li>  <strong>Partition</strong>：用于存放消息的队列，存放的消息都是<strong>有序</strong>的。同一个topic可以分多个partition</li>
<li>  <strong>Producer</strong>：消息生产者，向Broker发送消息的客户端</li>
<li>  <strong>Consumer</strong>：消息消费者，从Broker读取消息的客户端，通过offset进行标识消息被消费的位置</li>
<li>  <strong>Consumer Group</strong>：每个consumer都属于一个group，一条消息可以发送到多个不同的group，但是一个group内只有一个consumer能够消费该信息</li>
<li>  <strong>ZooKeeper</strong>：主要用于在集群中不同节点之间的通信。如: leader 检测、分布式同步、配置管理、识别新节点何时离开或连接、集群、节点实时状态等</li>
</ul>
<h3 id="kafka消息可靠性"><a href="#kafka消息可靠性" class="headerlink" title="kafka消息可靠性"></a>kafka消息可靠性</h3><ul>
<li>每个partition提供多个副本，将副本分布到所有的broker中。副本中会有一个leader节点，其他为follower节点</li>
<li>消息备份：<ul>
<li>ISR：一个partition中与leader保持同步的副本列表，在max.ms时间内与leader保持同步。follower会周期性向leader发fetchRequest，请求数据同步</li>
<li>ACKs：生产者发送消息中包含acks字段，代表leader应答生产者前，leader收到的应答数<ul>
<li>acks=0：生产者无需服务端确认，无法保证数据被发送到broker</li>
<li>acks=1：leader在接收到消息之后立刻应答，不需要等到follower同步完成。如果leader宕机，消息可能丢失</li>
<li>acks=all：所有follower同步完消息之后leader再进行应答</li>
</ul>
</li>
<li>副本对象的重要字段：<ul>
<li>LEO（log end offset）：日志末端偏移。指向副本中下一条消息的写入位置</li>
<li>HW（high watermark）：已同步消息标识。HW以下的数据都已经备份，leader的HW值为ISR中所有备份的LEO最小值决定（最慢的机器）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="kafka故障恢复"><a href="#kafka故障恢复" class="headerlink" title="kafka故障恢复"></a>kafka故障恢复</h3><ul>
<li><p>Broker故障恢复：</p>
<ul>
<li><p>Broker和其他的Broker断开，ZooKeeper还和Broker0连接，认为它还存活</p>
<ul>
<li>leader：当leader超过max.ms没有收到follower的fectchRequest之后，broker0会将leader的ISR收缩到只有broker0本身，并将ISR的变更通知到zookeeper</li>
<li>follower：超过max.ms后，leader会将broker0从ISR中删除</li>
</ul>
<p><img src="/2022/01/03/day29/day29_59.png" alt="情形1"></p>
</li>
<li><p>Broker和ZooKeeper断开连接，ZooKeeper会认为Broker0宕机</p>
<ul>
<li>leader：<ul>
<li>zookeeper将broker0删除，controller收到通知，从ISR中选择新的leader，并通知其他broker</li>
<li>当Broker0与ZooKeeper恢复连接后，发现自己不再是Partition0的Leader，于是将本地日志截断(为了保证和Leader数据一致性)。在broker0失联期间，所有写入broker0的消息都会丢失</li>
</ul>
</li>
<li>follower：broker之间的连接未断，还是可以向leader发送fetchRequest进行同步</li>
</ul>
<p><img src="/2022/01/03/day29/day29_60.png" alt="情形2"></p>
</li>
</ul>
</li>
<li><p>Controller故障恢复：</p>
<ul>
<li>controller与zookeeper断开连接：zookeeper会将controller删除，并重新选举出新的controller。当重新恢复连接之后，作为一个普通的broker</li>
<li>Controller与某个broker断开连接：该broker中的leader会被重新选举，而broker并不知道leader已经更换，所以会出现broker和zookeeper断开连接时，短暂服务不可用和可能发生数据丢失的情况</li>
</ul>
</li>
</ul>
<h3 id="kafka高性能"><a href="#kafka高性能" class="headerlink" title="kafka高性能"></a>kafka高性能</h3><ul>
<li><p>批量发送：producer在发送消息到broker时，采用批量发送的方式，减少网络消耗，提高性能</p>
<ul>
<li>Producer将消息分发到多个本地Partition的消息队列中，每个Partition消息队列中的消息会写入到不同的Leader节点</li>
<li><strong>发送流程</strong>：producer生产消息，序列化压缩之后，追加到本地的记录收集器，sender不断轮询，满足一定条件才将收集器中的数据发送到broker中（消息大小达到阈值、消息等待时间到达阈值）</li>
</ul>
<p><img src="/2022/01/03/day29/day29_61.png" alt="批量发送"></p>
</li>
<li><p>顺序写+零拷贝：提高broker在持久化消息、读取消息的性能</p>
<ul>
<li>顺序IO：数据分布在一起，找到第一块数据后，其他需要的数据就在第一块数据的后面，不需要多次切换寻址，读取速度较快<ul>
<li>producer传递给broker的每条消息都有一个顺序值，代表producer生产消息的顺序。producer创建的消息集中，每条消息的顺序值只是相对于本批次的序号，服务端会将每条消息的顺序值转换为绝对偏移量。kafka通过nextOffset来记录存储在日志中最近一条消息的偏移量</li>
</ul>
</li>
<li>零拷贝：减少数据拷贝次数和上下文切换次数（详见操作系统部分）</li>
</ul>
</li>
</ul>
<h2 id="thrift"><a href="#thrift" class="headerlink" title="thrift"></a>thrift</h2><p><img src="/2022/01/03/day29/day29_56.png" alt="thrift基本框架"></p>
<ul>
<li><p>Client端：</p>
<ul>
<li><p>netty client：客户端与服务端的网络通信由netty完成。</p>
</li>
<li><p>客户端代理：RPC要求像调用本地函数一样调用远程函数，需要向调用方屏蔽调用细节。</p>
</li>
<li><p>客户端filter：代理模式的具体实现，是用责任链模式衔接，为框架提供了高可扩展性。Filter 中包含：服务监控、服务路由、故障注入、服务鉴权、服务降级、服务调用等模块</p>
</li>
<li><p>连接池：调用端做IO操作时需要创建的对象。一个客户端可以和多个服务端相连，这些连接在服务端的连接池中维护</p>
</li>
<li><p>线程池：收到服务端返回的数据后，通知业务线程</p>
</li>
<li><p>netty client：客户端与服务端的网络通信由netty完成。其包含 Boss（ Reactor 模型中的 MainReactor ）、Worker（Reactor 模型中的 SubReactor）以及基于Channel 的 Pipeline</p>
</li>
<li><ul>
<li>boss：在客户端中，负责发起connect请求；在服务端中，负责accept客户端发起的connect请求</li>
<li>worker：负责轮询连接是否有数据到达，并负责将数据读写到相应的channel中</li>
<li>pipeline：负责对channel中的数据进行加工</li>
</ul>
</li>
</ul>
</li>
<li><p>server端：</p>
<ul>
<li>服务端filter：与客户端filter对应，请求在进入业务代码前，要经过服务监控、服务鉴权、服务限流等模块</li>
<li>线程池：将业务逻辑从I/O中剥离，数据准备好后，业务代码将在业务线程中执行</li>
<li>netty server：与netty client类似</li>
</ul>
</li>
</ul>
<h3 id="远程服务调用的执行过程"><a href="#远程服务调用的执行过程" class="headerlink" title="远程服务调用的执行过程"></a>远程服务调用的执行过程</h3><p><img src="/2022/01/03/day29/day29_57.png" alt="RPC调用过程"></p>
<ul>
<li><p>首先在客户端调用远程服务方法时，其真正调用的是 InvocationHandler 的 invoke 方法（这里使用 JDK 的动态代理）。Pigeon 中 InvocationHandler 的实现为 ServiceInvocationProxy， 所以调用接口声明的任意方法最终都会进到ServiceInvocationProxy.invoke 方法</p>
</li>
<li><p>ServiceInvocationProxy.invoke 中会调用客户端 Filter ，请求会依次经过 监控、路由、降级、网关、鉴权 等模块后，进入 RemoteCallInvokeFilter</p>
</li>
<li><p>在 RemoteCallInvokeFilter 中调用 Client.write 方法，其逻辑为从连接池（ChannelPool）中 获取连接（获取连接的超时时间默认为：2000ms），然后将数据写进 Channel</p>
</li>
<li><p>在向服务端发送数据之前，需经过 Channel 的 Pipeline（序列化、压缩等，减少网络传输的数据量）</p>
</li>
<li><p>开始向服务端发送数据，由于 Netty 发送消息是异步的，所以如果是同步调用的话，Pigeon 这里会让业务线程主动 await ，直到收到服务端响应或超时后唤醒。</p>
</li>
<li><p>服务端收到客户端发过的消息后，从 Channel 中将消息读出来之前，也会先经过一些 Pipeline（反序列化、解压缩等）后到达 NettyServerHandler。pigeon在该步骤有服务隔离的设计</p>
</li>
<li><ul>
<li>默认的隔离机制：当超时数达到300，或超时率超过5%，将后续对应请求放入slow线程池处理；其他情况，将后续对应请求放入shared线程池处理</li>
<li>默认开启方法限流：单个方法不能占用超过380个线程</li>
<li>提供业务自定义独立线程池支持</li>
</ul>
</li>
<li><p>在选择相应的线程池并成功的拿到线程后，请求就到了服务端 Filter 中。请求会依次经过 监控、流量录制、鉴权、泛化调用、网关等模块后，进入 BusinessProcessFilter</p>
</li>
<li><p>BusinessProcessFilter 中会根据客户端传递来的服务信息和参数，通过反射调用相应的业务服务并拿到业务处理结果。然后在 WriteResponseProcessFilter 中将返回结果写入 Channel</p>
</li>
<li><p>返回结果再经过服务端的 Pipeline 处理（序列化、压缩等），就发给客户端</p>
</li>
<li><p>客户端收到消息后，经过客户端的 Pipeline 处理（反序列化、解压缩等）后到达 NettyClientHandler,然后交给 ResponseThreadPoolProcessor 线程池处理</p>
</li>
<li><p>ResponseThreadPoolProcessor 收到消息后，会通知之前 await 的业务线程，并将结果传递给他</p>
</li>
<li><p>业务线程收到 signal 通知后，就将结果返回给之前的方法调用</p>
</li>
</ul>
<h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h2 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h2><ul>
<li><p>进程是对运行时程序的封装，是<strong>操作系统进行资源调度和分配的基本单位</strong>，<strong>实现操作系统的并发</strong>。线程是进程的子任务，<strong>CPU调度和分派的基本单位</strong>，用于<strong>保证程序的实时性</strong>，<strong>实现进程内部的并发</strong>；</p>
</li>
<li><p>每个线程都独自占用一个虚拟处理器、独自的寄存器组，指令计数器和处理器状态，完成不同的任务，但是<strong>共享同一地址空间</strong>，<strong>打开的文件队列</strong>和<strong>其他内核资源</strong>；</p>
</li>
<li><p>区别：</p>
<ul>
<li>一个线程只能属于一个进程，一个进程可以有多个线程，线程依赖于进程而存在</li>
<li>进程切换开销大，在创建或撤消进程时，系统都要为之分配或回收资源。线程切换只须保存和设置少量寄存器的内容，切换速度快，同一个进程的线程都具有同一个页表，那么在切换的时候不需要切换页表。</li>
<li>进程间通信复杂。同一进程中的多个线程具有相同的地址空间，通信比较容易，例如可以使用<strong>全局变量</strong></li>
<li>进程间不会相互影响，一个线程挂掉会导致整个进程挂掉</li>
</ul>
</li>
</ul>
<h2 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h2><ul>
<li>创建状态：进程正在被创建；</li>
<li>就绪状态：进程被加入到就绪队列中等待CPU调度运行；</li>
<li>执行状态：进程正在被运行；</li>
<li>等待阻塞状态：进程因为某种原因，比如等待I/O，等待设备，而暂时不能运行；</li>
<li>终止状态：进程运行完毕；</li>
</ul>
<h2 id="进程通信方式"><a href="#进程通信方式" class="headerlink" title="进程通信方式"></a>进程通信方式</h2><ul>
<li><p>匿名管道：本质是内核缓冲区，可用于亲缘进程（父子进程，兄弟进程）间通信，半双工，一端读、一端写，先进先出；</p>
</li>
<li><p>有名管道：本质是一个文件，可以提供给没有亲缘关系的进程通信；</p>
</li>
<li><p>消息队列：存放于内核的某个消息链表，允许多个进程进行读写；</p>
</li>
<li><p>套接字：套接字主要用于不同主机的进程之间的通信；</p>
</li>
<li><p>信号：一种异步通信方式，信号可以在任何时候发给某一进程；</p>
</li>
<li><p>信号量：信号量是一个计数器，<strong>原子的P、V操作</strong>，用于进程同步；</p>
</li>
<li><p>共享内存：多个进程可以直接读写同一块内存空间，共享内存如果中间涉及到写操作，往往需要同步机制进行辅助，比如信号量；</p>
</li>
<li><p>线程间通信方式：临界区，互斥量（锁），信号量，信号</p>
</li>
</ul>
<h2 id="单核机器上写多线程程序，是否需要考虑加锁，为什么？"><a href="#单核机器上写多线程程序，是否需要考虑加锁，为什么？" class="headerlink" title="单核机器上写多线程程序，是否需要考虑加锁，为什么？"></a>单核机器上写多线程程序，是否需要考虑加锁，为什么？</h2><ul>
<li>仍然需要线程锁，因为线程锁通常用来实现线程的同步和通信，在单核机器上的多线程程序，<strong>仍然存在线程同步的问题</strong>。因为在<strong>抢占式操作系统中</strong>，通常为每个线程分配一个时间片，当某个线程时间片耗尽时，操作系统会将其挂起，然后运行另一个线程，（如果这两个线程共享某些数据，不使用线程锁的前提下，可能会导致共享数据修改引起冲突）</li>
</ul>
<h2 id="协程（微线程，极高的运行效率，没有线程切换开销、没有锁机制开销）"><a href="#协程（微线程，极高的运行效率，没有线程切换开销、没有锁机制开销）" class="headerlink" title="协程（微线程，极高的运行效率，没有线程切换开销、没有锁机制开销）"></a>协程（微线程，极高的运行效率，没有线程切换开销、没有锁机制开销）</h2><ul>
<li><p>协程看上去也是子程序，<strong>但内部可中断</strong>，然后转而执行别的子程序，在适当的时候再返回来接着执行；</p>
</li>
<li><p>协程和线程区别，<strong>协程有极高的运行效率，没有线程切换开销、没有锁机制开销</strong></p>
<ul>
<li>和多线程比，协程最大的优势就是<strong>没有线程切换的开销</strong>，线程数量越多，协程的性能优势就越明显；</li>
<li><strong>没有锁机制的开销（只需判断状态）</strong>，因为只有一个线程，不存在同时写变量冲突；</li>
</ul>
</li>
</ul>
<h2 id="进程调度策略"><a href="#进程调度策略" class="headerlink" title="进程调度策略"></a>进程调度策略</h2><ul>
<li>先来先服务：可能会导致阻塞</li>
<li>最短作业优先调度：提高吞吐量，但是长任务可能无法被调度</li>
<li>高相应比优先调度：根据公式计算相应比，等待时间/要求服务的时间，要求服务的时间不可预知，不实用</li>
<li>时间片轮转：每个进程使用固定长度的CPU时间。时间设置太低，进程切换频繁，效率低；时间片太大，短作业的响应时间变长</li>
<li>最高优先级调度: 可能导致低优先级作业无法被调度</li>
<li>多级反馈队列调度：多个队列之间是最高优先级调度；单个队列里面是时间片轮转</li>
</ul>
<h2 id="内存页面置换算法"><a href="#内存页面置换算法" class="headerlink" title="内存页面置换算法"></a>内存页面置换算法</h2><ul>
<li>最佳页面置换算法：替换掉未来最长时间不访问的页面。但无法预测未来情况，只是一种理想算法</li>
<li>先进先出置换算法</li>
<li>最近最久未使用置换算法（LRU）：选择最近最长时间没有被访问过的页面进行置换。需要在内存中维护一个所有页面的链表，实现难度大。</li>
<li>时钟页面置换算法：类似于LRU和FIFO的结合。所有页面保存在类似钟面的环形链表，缺页中断时判断表针指向页面，<strong>若页面R位为0</strong>，则选择此页面进行置换；<strong>否则R=1</strong>，清除R位直到找到R=0的页面为止；</li>
<li>最近最少使用置换算法（LFU）：<strong>选择「访问次数」最少的那个页面，并将其淘汰</strong>。使用计数器，记录每个页面被访问次数</li>
</ul>
<h2 id="IO模型"><a href="#IO模型" class="headerlink" title="IO模型"></a>IO模型</h2><ul>
<li>阻塞IO：调用者调用一个函数，需要等待这个函数返回之后，才可以继续进行操作</li>
<li>非阻塞IO：每隔一段时间区检测IO事件，检测间隙可以继续操作</li>
<li>信号驱动IO：运行端准备好数据，给调用端一个信号，调用端接收数据，不需要频繁检测</li>
<li>多路复用IO：不需要尝试获取数据，而是先开启另外一个线程来监控数据的状态，等到有数据的时候再同步获取数据，而在没数据的时候也是不需要等待的</li>
<li>异步IO：通过调用aio_read函数，那么内核会先将数据读取好，并且复制到用户空间之后，再执行回调函数通知应用程序，此时应用程序就可以直接从用户空间中读取数据，而不需要再从内核中读取数据</li>
</ul>
<h2 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h2><p><img src="/2022/01/03/day29/day29_37.png" alt="上下文切换对比"></p>
<h2 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a>零拷贝</h2><ul>
<li><p>最原始数据拷贝过程：整个过程都需要CPU参与</p>
<p><img src="/2022/01/03/day29/day29_38.png" alt="原始过程"></p>
</li>
<li><p>DMA：在IO设备和内存之间搬运数据，不需要CPU参与</p>
<p><img src="/2022/01/03/day29/day29_39.png" alt="DMA"></p>
<p><img src="/2022/01/03/day29/day29_40.png" alt="传统数据拷贝"></p>
</li>
<li><p>零拷贝</p>
<ul>
<li><p>mmap+write：<code>mmap()</code> 系统调用函数会直接把内核缓冲区里的数据<strong>映射</strong>到用户空间，这样，操作系统内核与用户空间就不需要再进行任何的数据拷贝操作。<strong>仍然有4次上下文切换</strong></p>
<ul>
<li>应用进程调用了 <code>mmap()</code> 后，DMA 会把磁盘的数据拷贝到内核的缓冲区里。接着，应用进程跟操作系统内核「共享」这个缓冲区；</li>
<li>应用进程再调用 <code>write()</code>，操作系统直接将内核缓冲区的数据拷贝到 socket 缓冲区中，这一切都发生在内核态，由 CPU 来搬运数据；</li>
<li>最后，把内核的 socket 缓冲区里的数据，拷贝到网卡的缓冲区里，这个过程是由 DMA 搬运的</li>
</ul>
<p><img src="/2022/01/03/day29/day29_41.png" alt="mmap+write"></p>
</li>
<li><p>sendfile：一次系统调用，2次上下文切换，3次数据拷贝</p>
<ul>
<li>如果网卡支持SG-DMA技术，可以缩减为2次数据拷贝</li>
</ul>
<p><img src="/2022/01/03/day29/day29_42.png" alt="sendfile"></p>
</li>
</ul>
<p><img src="/2022/01/03/day29/day29_43.png" alt="SG-DMA"></p>
</li>
</ul>
<h2 id="Select-poll-epoll"><a href="#Select-poll-epoll" class="headerlink" title="Select/poll/epoll"></a>Select/poll/epoll</h2><ul>
<li>select：注册事件数量有限制<ul>
<li>从用户空间拷贝fd_set（注册的事件集合）到内核空间</li>
<li>遍历所有fd文件，并将当前进程挂到每个fd的等待队列中，当某个fd文件设备收到消息后，会唤醒设备等待队列上睡眠的进程，那么当前进程就会被唤醒</li>
<li>如果遍历完所有的fd没有I/O事件，则当前进程进入睡眠，当有某个fd文件有I/O事件或当前进程睡眠超时后，当前进程重新唤醒再次遍历所有fd文件</li>
</ul>
</li>
<li>poll：和select类似，但使用链表存储注册事件，数量无限制</li>
<li>epoll：采用的是事件驱动机制，每个fd上有注册有回调函数，当网卡接收到数据时会回调该函数，同时将该fd的引用放入<strong>rdlist就绪列表</strong>中。调用<strong>epoll_wait</strong>检查是否有事件发生时，只需要检查eventpoll对象中的rdlist双链表中是否有epitem元素即可。如果rdlist不为空，则把发生的事件复制到用户态，同时将事件数量返回给用户。</li>
</ul>
<h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h2 id="七层结构、四层结构"><a href="#七层结构、四层结构" class="headerlink" title="七层结构、四层结构"></a>七层结构、四层结构</h2><p><img src="/2022/01/03/day29/day29_46.png" alt="七层结构"></p>
<p><img src="/2022/01/03/day29/day29_47.png" alt="四层结构"></p>
<h2 id="输入网址到页面显示整个过程"><a href="#输入网址到页面显示整个过程" class="headerlink" title="输入网址到页面显示整个过程"></a>输入网址到页面显示整个过程</h2><p><img src="/2022/01/03/day29/day29_48.png" alt="网址解析"></p>
<ul>
<li><p>首先查看浏览器缓存，如果缓存中有该URL对应的资源，且没有过期，直接显示页面。</p>
</li>
<li><p>解析URL，生成发送给服务器的HTTP请求信息。确定Web服务器和文件名</p>
<p><img src="/2022/01/03/day29/day29_49.png" alt="URL组成"></p>
</li>
</ul>
<p><img src="/2022/01/03/day29/day29_50.png" alt="HTTP消息格式"></p>
<ul>
<li>DNS查询，查询服务器域名对应的IP地址。DNS查询步骤<ul>
<li>首先查看浏览器缓存是否有相应数据</li>
<li>问根域名服务器，根域名服务器会告诉本地DNS应该去哪个顶级域名服务器查询</li>
<li>顶级域名服务器，他会告诉本地域名服务器应该去哪个权威域名服务器查询</li>
<li>权威域名服务器解析域名对应的IP</li>
</ul>
</li>
<li>建立于目标主机的TCP连接</li>
<li>发送HTTP请求（将报文在TCP/IP架构中向下传递并层层封装）</li>
<li>服务器处理HTTP请求并返回响应HTTP报文（将报文在TCP/IP架构中向上传递并层层解封装）</li>
<li>浏览器解析渲染页面</li>
<li>当不需要连接后断开TCP连接（四次挥手）</li>
</ul>
<h2 id="TCP和UDP区别"><a href="#TCP和UDP区别" class="headerlink" title="TCP和UDP区别"></a>TCP和UDP区别</h2><ul>
<li><p>连接不同：tcp是面向连接的，传输数据前要先建立连接；udp是不需要连接的即刻传输数据。</p>
</li>
<li><p>服务对象：tcp只支持一对一的数据传输；udp支持一对一、一对多、多对多的通信。</p>
</li>
<li><p>可靠性方面：tcp是提供可靠交付的，数据可以无差错、不丢失、不重复的按需到达；udp是尽最大努力交付，不保证可靠交付。</p>
</li>
<li><p>拥塞控制和流量控制方面：tcp有拥塞控制和流量控制，能保证数据的安全性；但udp没有，即使网络非常拥堵了也不会影响udp的发送速率。</p>
</li>
<li><p>首部开销方面：tcp首部长度较长，开销会稍大一些，在没有使用选项字段时是20字节，使用了会更多；udp的是首部只有8字节，是固定不变的。开销较小。</p>
</li>
<li><p>传输方式方面：tcp是流式传输，没有边界，但保证顺序可靠；udp是一个包一个包的发送，有边界，但可能会丢包和乱序。</p>
</li>
<li><p>分片方式方面：tcp的数据大小如果大于MSS，会在传输层进行分片，目的主机收到后，在传输层组装tcp数据包，如果中途丢失了一个分片，子需要传输丢失的分片；udp的数据大小如果大于MTU会在网络层分片，目的主机收到后在网络层组装完数据向上层传输，如果丢失分片，则需要重传所有数据包，所以一般udp传输的报文数据应该小于MTU。</p>
<p><img src="/2022/01/03/day29/day29_52.png" alt="UDP头部格式"></p>
</li>
</ul>
<p><img src="/2022/01/03/day29/day29_51.png" alt="TCP头部格式"></p>
<h2 id="TCP三次握手，四次挥手"><a href="#TCP三次握手，四次挥手" class="headerlink" title="TCP三次握手，四次挥手"></a>TCP三次握手，四次挥手</h2><p><img src="/2022/01/03/day29/day29_53.png" alt="三次握手"></p>
<p><img src="/2022/01/03/day29/day29_54.png" alt="4次挥手"></p>
<h2 id="为什么是三次握手"><a href="#为什么是三次握手" class="headerlink" title="为什么是三次握手"></a>为什么是三次握手</h2><ul>
<li><strong>避免历史连接</strong>：由于网络延迟，旧的syn报文比新的syn报文提前到达服务端。如果是三次握手，在第三次时客户端会给服务端发送rst报文终止连接，而两次握手没办法做到</li>
<li>同步双方序列号</li>
<li>三次握手可以解决，不需要更多次握手浪费资源</li>
</ul>
<h2 id="SYN攻击"><a href="#SYN攻击" class="headerlink" title="SYN攻击"></a>SYN攻击</h2><ul>
<li>攻击者短时间内伪造不同的IP地址，向服务器发送SYN报文，让服务器接受以为有正常的连接，会在SYN接收队列中记录并回复应答报文，但没有后续，直到将服务器的SYN接收队列占满，真正正常的用户无法连接服务器</li>
<li>可以增大SYN接受队列的长度、减少SYN+ACK重传次数</li>
</ul>
<h2 id="为什么四次挥手"><a href="#为什么四次挥手" class="headerlink" title="为什么四次挥手"></a>为什么四次挥手</h2><ul>
<li>因为需要双方都处理完数据之后才能关闭连接，因此需要双方都主动发送FIN报文，并接收到对方回应</li>
</ul>
<h2 id="为什么TIME-WAIT等待时间为2MSL"><a href="#为什么TIME-WAIT等待时间为2MSL" class="headerlink" title="为什么TIME_WAIT等待时间为2MSL"></a>为什么TIME_WAIT等待时间为2MSL</h2><ul>
<li>如果第四次挥手ACK报文丢失，服务端没有断开连接，服务端会重发FIN报文，所以客户端在发送完ACK报文后需要等待。2MSL正好是允许报文丢失一次的时间</li>
</ul>
<h2 id="TCP保证可靠传输"><a href="#TCP保证可靠传输" class="headerlink" title="TCP保证可靠传输"></a>TCP保证可靠传输</h2><ul>
<li><p>重传机制：根据序列号和确认应答号，判断是否收到数据包。<strong>重传解决数据包丢失情况</strong></p>
<ul>
<li>超时重传：数据包丢失；确认应答丢失。<strong>超时重传时间应该略大于报文往返时间RTT</strong>。每遇到超时重传，会把下次超时时间翻倍，两次超时后，不再进行重传</li>
<li>快速重传：连续收到3次相同的ACK，说明中间有包丢失，进行重传。解决了超时时间设置问题。但不知道重传哪几个报文</li>
<li>SACK：选择性确认。在TCP头部字段中加入SACK，将已接受到的数据发送给发送方，发送方就知道重传哪些报文</li>
<li>D-SACK：有哪些数据被重复接受了。可以判断到底是，数据包丢失或ACK丢失或网络延迟</li>
</ul>
</li>
<li><p>滑动窗口：窗口大小（字节数）就是指<strong>无需等待确认应答，而可以继续发送数据长度的最大值</strong>。TCP头部的Window字段就是窗口大小，一般由接收方决定。</p>
</li>
<li><p>流量控制：根据接收方的接受能力控制发送数据量。</p>
<ul>
<li>接收端没有及时处理缓冲区的数据，导致接收窗口变小，发送窗口也变小</li>
<li>窗口大小为0后，发送方无法给接受方发送数据。发送方隔一段时间，会向接收方发送窗口探测报文</li>
</ul>
</li>
<li><p>拥塞控制：在网络拥挤的情况下，避免发送的数据填满整个网络。<strong>拥塞窗口，根据网络情况动态改变的窗口大小，发送窗口最终的值为拥塞窗口和流量控制窗口的最小值</strong></p>
<ul>
<li>慢启动：刚开始拥塞窗口大小成指数型增强：1，2，4…..</li>
<li>拥塞避免：当窗口大小超过thresh阈值后，拥塞窗口大小成线性增长，每收到一个ACK增加<strong>1/窗口大小</strong>，接收到一整个窗口ACK，增加1</li>
<li>拥塞发生：触发重传机制。<strong>超时重传</strong>后，拥塞窗口值直接变为1，thresh阈值为原来的1/2。<strong>快速重传</strong>后，拥塞窗口的值变为原来的1/2，阈值不变</li>
<li>快速恢复：在快速重传后使用，拥塞窗口变为thresh+3，重传数据包，如果收到重复的ACK，拥塞窗口值+1。收到新的ACK后，恢复过程结束，窗口大小变为thresh阈值</li>
</ul>
<p><img src="/2022/01/03/day29/day29_55.png" alt="拥塞控制"></p>
</li>
</ul>
<h2 id="TCP半连接和全连接队列"><a href="#TCP半连接和全连接队列" class="headerlink" title="TCP半连接和全连接队列"></a>TCP半连接和全连接队列</h2><ul>
<li>服务端收到客户端发起的 SYN 请求后，<strong>内核会把该连接存储到半连接队列</strong>，并向客户端响应 SYN+ACK，接着客户端会返回 ACK，服务端收到第三次握手的 ACK 后，<strong>内核会把连接从半连接队列移除，然后创建新的完全的连接，并将其添加到 accept 队列，等待进程调用 accept 函数时把连接取出来。</strong></li>
</ul>
<h2 id="HTTP和HTTPS区别"><a href="#HTTP和HTTPS区别" class="headerlink" title="HTTP和HTTPS区别"></a>HTTP和HTTPS区别</h2><ul>
<li>HTTP是明文传输，存在安全风险。HTTPS对传输数据进行加密，更加安全</li>
<li>HTTP连接建立只需要TCP三次握手，而HTTPS还需要进行SSL/TLS握手</li>
<li>HTTP端口号为80，HTTPS为443</li>
<li>HTTPS需要向CA申请数字证书，证明服务器的身份</li>
</ul>
<h2 id="常见状态码"><a href="#常见状态码" class="headerlink" title="常见状态码"></a>常见状态码</h2><ul>
<li><code>1xx</code> 类状态码属于<strong>提示信息</strong>，是协议处理中的一种中间状态，实际用到的比较少</li>
<li><code>2xx</code> 类状态码表示服务器<strong>成功</strong>处理了客户端的请求，也是我们最愿意看到的状态<ul>
<li>200：一切正常</li>
</ul>
</li>
<li><code>3xx</code> 类状态码表示客户端请求的资源发生了变动，需要客户端用新的 URL 重新发送请求获取资源，也就是<strong>重定向</strong><ul>
<li>301：永久重定向</li>
<li>302：临时重定向</li>
<li>304：重定向存在缓存文件</li>
</ul>
</li>
<li><code>4xx</code> 类状态码表示客户端发送的<strong>报文有误</strong>，服务器无法处理，也就是错误码的含义<ul>
<li>400：表示客户端请求的报文有错误</li>
<li>403：服务器禁止访问资源</li>
<li>404：请求资源不存在或找不到</li>
</ul>
</li>
<li><code>5xx</code> 类状态码表示客户端请求报文正确，但是<strong>服务器处理时内部发生了错误</strong>，属于服务器端的错误码<ul>
<li>500：服务端有错误</li>
<li>501：客户端请求功能还不支持</li>
<li>503：服务器很忙，无法响应</li>
</ul>
</li>
</ul>
<h2 id="GET和POST区别"><a href="#GET和POST区别" class="headerlink" title="GET和POST区别"></a>GET和POST区别</h2><ul>
<li>GET是从服务器获得指定资源，POST是请求对指定资源做相应的处理</li>
<li>GET的请求参数一般在URL中，浏览器会对URL长度有限制，POST数据在报文body中</li>
</ul>
<h2 id="Cookie和Session区别"><a href="#Cookie和Session区别" class="headerlink" title="Cookie和Session区别"></a>Cookie和Session区别</h2><ul>
<li>Cookie一般用来保存用户信息（登录信息，在cookie中放入token）。Session主要在服务端记录用户状态（添加购物车，使用session表明用户身份）</li>
<li>Cookie 数据保存在客户端(浏览器端)，Session 数据保存在服务器端</li>
</ul>
<h2 id="HTTPS建立连接过程"><a href="#HTTPS建立连接过程" class="headerlink" title="HTTPS建立连接过程"></a>HTTPS建立连接过程</h2><ul>
<li>ClientHello：由客户端向服务器发起加密通信请求，包含了SSL协议版本、客户端随机数C、支持的密码套件</li>
<li>SeverHello：确认SSL协议版本、服务端随机数S、确认采用的密码套件、CA证书</li>
<li>客户端回应<ul>
<li>首先通过浏览器或操作系统中的CA公钥，验证服务器身份</li>
<li>从数字证书中取出<strong>服务器公钥</strong>，使用它加密报文：随机数pre-master、之前数据的摘要。之后都采用加密传输</li>
</ul>
</li>
<li>服务器回应<ul>
<li>根据pre-master、C、S计算出后续数据传输的密钥</li>
<li>将之前的信息摘要，通过密钥加密后发送给客户端</li>
</ul>
</li>
</ul>
<h2 id="CA证书验证过程"><a href="#CA证书验证过程" class="headerlink" title="CA证书验证过程"></a>CA证书验证过程</h2><ul>
<li>CA 签发证书的过程：<ul>
<li>首先 CA 会把持有者的公钥、用途、颁发者、有效时间等信息打成一个包，然后对这些信息进行 Hash 计算，得到一个 Hash 值；</li>
<li>然后 CA 会使用自己的私钥将该 Hash 值加密，生成 Certificate Signature，也就是 CA 对证书做了签名；</li>
<li>最后将 Certificate Signature 添加在文件证书上，形成数字证书</li>
</ul>
</li>
<li>客户端校验服务端的数字证书的过程：<ul>
<li>首先客户端会使用同样的 Hash 算法获取该证书的 Hash 值 H1；</li>
<li>通常浏览器和操作系统中集成了 CA 的公钥信息，浏览器收到证书后可以使用 CA 的公钥解密 Certificate Signature 内容，得到一个 Hash 值 H2 ；</li>
<li>最后比较 H1 和 H2，如果值相同，则为可信赖的证书，否则则认为证书不可信。</li>
</ul>
</li>
</ul>
<h2 id="HTTP1-1"><a href="#HTTP1-1" class="headerlink" title="HTTP1.1"></a>HTTP1.1</h2><ul>
<li>简单：基本报文格式header+body，头部信息key-value的形式，容易理解</li>
<li>灵活易扩展：状态码、头字段等都没有固定死，允许开发人员自定义</li>
<li>应用广泛跨平台</li>
<li>长连接：没有主动断开连接，就不断开连接。超过一定的时间，断开连接</li>
<li>无状态</li>
<li>明文传输不安全</li>
<li>管道网络传输：可以同时发起多个请求，解决了请求的队头阻塞问题。但响应需要按顺序接受，响应存在对头阻塞问题</li>
</ul>
<h2 id="HTTP2基于HTTPS"><a href="#HTTP2基于HTTPS" class="headerlink" title="HTTP2基于HTTPS"></a>HTTP2基于HTTPS</h2><ul>
<li>头部压缩：同时发出多个请求，如果头部信息相同，会消除重复部分。<code>HPACK</code>,维护一张头信息表</li>
<li>二进制格式：头信息和数据体都是二进制格式</li>
<li>并发传输：提出了Stream概念，多个Stream复用同一个TCP。不同的请求具有不同的streamID</li>
</ul>
<h2 id="HTTP和RPC"><a href="#HTTP和RPC" class="headerlink" title="HTTP和RPC"></a>HTTP和RPC</h2><ul>
<li>HTTP和RPC都是协议，底层都可以基于TCP或UDP进行实现，只是定义了不同消息格式的应用层协议</li>
<li>RPC要比HTTP1.1效率更高</li>
<li>RPC实现服务调用时，需要双方都使用统一的RPC框架，跨操作系统，同一编程语言。HTTP不需要关注对方使用的编程语言，通用性灵活度更强</li>
</ul>
<h1 id="多线程编程"><a href="#多线程编程" class="headerlink" title="多线程编程"></a>多线程编程</h1><h2 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Semaphore fooSema = <span class="keyword">new</span> Semaphore(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">private</span> Semaphore barSema = <span class="keyword">new</span> Semaphore(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">fooSema.acquire(); <span class="comment">//获得</span></span><br><span class="line">barSema.release(); <span class="comment">//释放</span></span><br></pre></td></tr></table></figure>

<h2 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> CyclicBarrier cb = <span class="keyword">new</span> CyclicBarrier(<span class="number">2</span>); <span class="comment">//两个线程到达后，放行</span></span><br><span class="line"></span><br><span class="line">cb.await(); <span class="comment">//线程到达</span></span><br></pre></td></tr></table></figure>

<h2 id="Thread-yield"><a href="#Thread-yield" class="headerlink" title="Thread.yield()"></a>Thread.yield()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Thread.yield() <span class="comment">//从执行态变为就绪态</span></span><br></pre></td></tr></table></figure>

<h2 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> BlockingQueue&lt;Integer&gt; fooQueue = <span class="keyword">new</span> LinkedBlockingQueue&lt;Integer&gt;() &#123;&#123;</span><br><span class="line">        add(<span class="number">0</span>);</span><br><span class="line">    &#125;&#125;;</span><br><span class="line"><span class="keyword">private</span> BlockingQueue&lt;Integer&gt; barQueue = <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;();</span><br><span class="line"></span><br><span class="line">fooQueue.take();<span class="comment">//取元素</span></span><br><span class="line">barQueue.add();<span class="comment">//添加元素</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Object lock = <span class="keyword">new</span> Object();<span class="comment">//对象锁</span></span><br><span class="line"><span class="keyword">synchronized</span>(lock)&#123;</span><br><span class="line">    <span class="keyword">while</span>(condition)&#123;</span><br><span class="line">       lock.await();<span class="comment">//等待 </span></span><br><span class="line">    &#125;</span><br><span class="line">	lock.notifyAll();<span class="comment">//唤醒其他线程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="系统设计"><a href="#系统设计" class="headerlink" title="系统设计"></a>系统设计</h1><h2 id="高可用、高并发、高性能系统设计"><a href="#高可用、高并发、高性能系统设计" class="headerlink" title="高可用、高并发、高性能系统设计"></a>高可用、高并发、高性能系统设计</h2><ul>
<li>冗余：消除单点，负载均衡<ul>
<li>首先拆分整个系统，分成多个微服务，形成<strong>隔离</strong>，单个微服务挂掉不影响其他服务</li>
<li>消除单点：数据库成是单点，我们的手段有：主-备，主-备-从，分库，分表，分库分表，冗余数据的同时，数据的的“读”、“写”能力也在提升。缓存层，拿主流的redis来讲，主从、哨兵模式、cluster等都是其冗余手段；</li>
<li>负载均衡：冗余的点分担流量。制定降级策略，当下级某个机器挂掉，就停止调用，将流量分配给其他机器，或者停止服务</li>
</ul>
</li>
<li>取舍：冗余会导致加机器，但是也不能无限加机器，成本会很高<ul>
<li>限流：保证系统不过载，在压测时确定</li>
<li>重试：服务调用失败时可以重试，但不能一直重试，例如系统崩溃、系统升级等</li>
<li>熔断机制：防止应用程序不断地尝试执行可能会失败的操作，例如设置重试次数、超时时间等</li>
<li>降级：解决资源不足或访问量过大问题。无法调用相应的服务，简化操作步骤或流程，或者本地简单处理。</li>
</ul>
</li>
</ul>
<h2 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h2><h3 id="设计理念"><a href="#设计理念" class="headerlink" title="设计理念"></a>设计理念</h3><ul>
<li>中心化设计：分为主和从，强烈依赖与主节点<ul>
<li>主节点正常响应问题，采用主备方案解决</li>
<li>主节点性能瓶颈，影响请求分发</li>
</ul>
</li>
<li>去中心化：由节点自由选择中心<ul>
<li>问题：脑裂问题，由于网络故障，整体被分为两个独立的个体，会产生数据冲突和错误</li>
<li>方案：较小的个体自杀或拒绝服务</li>
</ul>
</li>
</ul>
<h3 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h3><ul>
<li><p>XA规范：实现分布式事务系统的概念模型</p>
<ul>
<li>AP：application program，应用程序，定义了事务的边界，以及指定了组成一个事务的行为，可以理解为就是事务发起的某个微服务</li>
<li>RMs：resource managers，资源管理器，可以理解为分布式数据库中的每一个数据实例</li>
<li>TM：transaction manager，事务管理器，负责协调管理事务，控制全局事务</li>
</ul>
</li>
<li><p>TM和RM之间实现事务的完成和回滚，使用<strong>2PC协议</strong></p>
</li>
<li><p><strong>CAP理论：</strong></p>
<ul>
<li>强一致性（Consistency）：系统在执行过某项操作后仍然处于一致的状态。在分布式系统中，更新操作执行成功后所有的用户都应该读到最新的值，这样的系统被认为是具有强一致性的</li>
<li>可用性（Availability）：每一个操作都能在一定的时间内返回结果</li>
<li>分区容错性（Partition Tolerance）：存在网络分区的情况下，仍然可以接受请求（满足CA）。网络分区是指由于某种原因，网络被分为多个单独个体，个体之间互不相通</li>
</ul>
<blockquote>
<p>实际情况中很难同时兼顾CAP</p>
<ol>
<li>放弃可用性（CP）：意味着我们将假设一旦网络发生分区，节点之间的信息同步时间可以无限制地延长，此时，问题相当于退化到前面“全局事务”中一个系统使用多个数据源的场景之中，我们可以通过 2PC/3PC 等手段，同时获得分区容忍性和一致性。<strong>一般用于对数据质量要求很高的场合中</strong></li>
<li>放弃一致性（AP）：意味着我们将假设一旦发生分区，节点之间所提供的数据可能不一致。AP系统目前主流选择，因为P是分布式特性，无法丢弃，A是我们构建分布式系统的目标。</li>
</ol>
</blockquote>
</li>
<li><p><strong>刚性事务</strong>：遵循ACID原则，强一致性。<strong>2PC</strong> 和 <strong>3PC</strong> 都是一种在分布式环境中仍追求强一致性的事务处理方案，对于多节点而且互相调用彼此服务的场合（微服务系统）是极不合适的，今天它几乎只实际应用于单服务多数据源的场合中</p>
<ul>
<li><p>2PC（两阶段提交）：协调者（TM），参与者（RM）</p>
<ul>
<li>第一阶段：当要执行一个分布式事务的时候，事务发起者首先向协调者发起事务请求，然后协调者会给所有参与者发送 prepare 请求（其中包括事务内容）告诉参与者需要执行事务。如果能执行发送的事务内容那么就先执行但不提交，执行后回复。参与者收到 prepare 消息后，他们会开始执行事务（但不提交），并将 <strong>Undo 和 Redo 信息记入事务日志</strong>中，之后参与者就向协调者反馈是否准备好了。</li>
<li>第二阶段：提交事务或者回滚事务。比如这个时候 所有的参与者 都返回了准备好了的消息，这个时候就进行事务的提交，协调者此时会给所有的参与者发送 Commit 请求 ，当参与者收到 Commit 请求的时候会执行前面执行的事务的提交操作 ，提交完毕之后将给协调者发送提交成功的响应。<br>如果<strong>在第一阶段有参与者返回了未准备好的消息</strong>，那么此时协调者将会给所有参与者发送 回滚事务的 rollback 请求，参与者收到之后将会 回滚它在第一阶段所做的事务处理。</li>
<li><strong>问题</strong>：<ul>
<li>单点故障：协调者挂掉，整个事务不可用。参与者等待协调者指令时无法超时处理</li>
<li>性能问题：prepare后，参与者只会执行事务，但不提交，会一直占用资源。<strong>最主要问题</strong></li>
<li>数据不一致：协调者在第二阶段宕机，只给部分参与者发送了commit。脑裂情况</li>
<li>网络传输导致空回滚和资源悬挂：没收到prepare，但收到了rollback；prepare由于延迟，导致先收到了rollback，后续又收到了prepare</li>
</ul>
</li>
</ul>
<p><img src="/2022/01/03/day29/day29_44.png" alt="2PC"></p>
</li>
<li><p>3PC（三阶段提交）</p>
<ul>
<li><p>CanCommit阶段：协调者向所有参与者发送 CanCommit 请求，参与者收到请求后会根据自身情况查看是否能执行事务，如果可以则返回 YES 响应并进入预备状态，否则返回 NO 。</p>
</li>
<li><p>PreCommit阶段：协调者根据参与者返回的响应来决定是否可以进行下面的 PreCommit 操作。</p>
<ul>
<li>如果上面参与者都返回 YES，那么协调者将向所有参与者发送 PreCommit 预提交请求，参与者收到预提交请求后，会进行事务的执行操作，并将 Undo 和 Redo 信息写入事务日志中 ，最后如果参与者顺利执行了事务则给协调者返回成功的响应。</li>
<li>如果在第一阶段协调者收到了 任何一个 NO 的信息，或者 在一定时间内 并没有收到全部的参与者的响应，那么就会中断事务，它会向所有参与者发送中断请求（abort）</li>
</ul>
</li>
<li><p>DoCommit阶段：如果协调者收到了所有参与者在 PreCommit 阶段的 YES 响应，那么协调者将会给所有参与者发送 DoCommit 请求，<strong>参与者收到 DoCommit 请求后则会进行事务的提交工作</strong>，完成后则会给协调者返回响应，协调者收到所有参与者返回的事务提交成功的响应之后则完成事务。若协调者在 PreCommit 阶段 收到了任何一个 NO 或者在一定时间内没有收到所有参与者的响应 ，那么就会进行中断请求的发送，参与者收到中断请求后则会 <strong>通过上面记录的回滚日志 来进行事务的回滚操作，并向协调者反馈回滚状况，协调者收到参与者返回的消息后，中断事务</strong>。</p>
<p><img src="/2022/01/03/day29/day29_45.png" alt="3PC"></p>
</li>
<li><p>总结：3PC加入的超时机制缓解了阻塞问题</p>
</li>
<li><p>缺点：无法解决网络分区问题；没有解决2PC性能差的问题，增加一个阶段，导致性能更差</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>柔性事务</strong>：遵循BASE理论，最终一致性；与刚性事务不同，柔性事务<strong>允许一定时间内，不同节点的数据不一致，但要求最终一致</strong>。</p>
<ul>
<li><p>BASE </p>
<ul>
<li>Basically Available（基本可用） ：分布式系统在出现不可预知故障的时候，允许损失部分可用性。</li>
<li>Soft-state（软状态，柔性事务） ：允许系统中的数据存在中间状态，并认为该中间状态的存在不会影响系统的整体可用性，即允许系统在不同节点的数据副本之间进行数据同步的过程存在延时。</li>
<li>Eventually Consistent（最终一致性）：系统中所有的数据副本，在经过一段时间的同步后，最终能够达到一个一致的状态。</li>
</ul>
</li>
<li><p>实现方案：补偿型和通知型</p>
<ul>
<li><p>补偿型：TCC和Saga</p>
<ul>
<li><p>TCC（Try-Confirm-Cancel）：业务侵入式较强的事务方案，要求业务处理过程必须拆分为“预留业务资源”和“确认/释放消费资源”两个子过程。 具体分为以下三个阶段</p>
<ul>
<li><strong>Try</strong>：尝试执行阶段，完成所有业务可执行性的检查（保障一致性），并且预留好全部需用到的业务资源（保障隔离性）。（购买时，冻结账户余额、冻结库存、生成预收款）</li>
<li><strong>Confirm</strong>：确认执行阶段，不进行任何业务检查，直接使用 Try 阶段准备的资源来完成业务处理。（账务服务扣减余额、仓库扣减库存、商家服务支付首款）</li>
<li><strong>Cancel</strong>：取消执行阶段，释放 Try 阶段预留的业务资源。（操作超时或者操作失败，进行cancel操作，取消资源预留操作）</li>
<li>特定：在业务层实现，几乎不涉及锁和资源的争用，性能高。但是开发和替换成本高</li>
</ul>
</li>
<li><p>Saga：与外部系统交互，无法使用TCC。</p>
<ul>
<li>将整个事务分成多个子事务，Ti，每个子事务都是原子的，而且有对应的补偿事务Ci</li>
<li>理想情况下，所有Ti都执行成功。否则进行恢复<ul>
<li>前向恢复：重复失败的子事务，直到成功。这种情况不需要Ci</li>
<li>反向恢复：对所有已完成事务进行回滚</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="领域驱动设计"><a href="#领域驱动设计" class="headerlink" title="领域驱动设计"></a>领域驱动设计</h2><ul>
<li>领域驱动指的是以领域作为解决问题切入点，面对业务需求，先提炼出领域概念，并构建领域模型来表达业务问题，而构建过程中我们应该尽可能避免牵扯技术方案或技术细节。而编码实现更像是对领域模型的代码翻译，代码（变量名、方法名、类名等）中要求能够表达领域概念，让人见码明义。</li>
<li><strong>思维模式转变</strong>：实践 DDD 以前，<strong>最常使用的是数据驱动设计</strong>。它的核心思路针对业务需求进行数据建模：<strong>根据业务需求提炼出类</strong>，然后把类映射为表结构，并根据读写性能要求使用范式优化表与表之间的关联关系。数据驱动是从技术的维度解决业务问题，得出的<strong>数据模型是对业务需求的直接翻译</strong>，并没有蕴含稳定的领域知识/规则。一旦需求发生变化，数据模型就得发生变化，对应的库表的设计也需要进行调整。<strong>这种设计思维导致变化从需求穿透到了数据层</strong>，中间并没有稳定的，不易变的层级进行阻隔，最终导致系统响应变化的能力很差。</li>
<li><strong>协同模式转变</strong>：DDD 通过解锁新角色”领域专家”以及模型驱动设计，<strong>有效地降低产品和研发的认知差异</strong>。领域专家是具有丰富行业经验和领域知识储备的人，他们能够在易变的、定制化的需求中提炼出清晰的边界，稳定的、可复用的领域概念和业务规则，并携手产品和研发共同构建出领域模型。</li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/12/19/day28/" rel="prev" title="Redis6">
      <i class="fa fa-chevron-left"></i> Redis6
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/01/09/30/" rel="next" title="SpringBoot">
      SpringBoot <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#JAVA%E5%9F%BA%E7%A1%80"><span class="nav-number">1.</span> <span class="nav-text">JAVA基础</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80"><span class="nav-number">1.1.</span> <span class="nav-text">基础</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Java-%E6%B3%9B%E5%9E%8B%E4%BA%86%E8%A7%A3%E4%B9%88%EF%BC%9F%E4%BB%80%E4%B9%88%E6%98%AF%E7%B1%BB%E5%9E%8B%E6%93%A6%E9%99%A4%EF%BC%9F%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%E5%B8%B8%E7%94%A8%E7%9A%84%E9%80%9A%E9%85%8D%E7%AC%A6%EF%BC%9F"><span class="nav-number">1.1.1.</span> <span class="nav-text">Java 泛型了解么？什么是类型擦除？介绍一下常用的通配符？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%87%8D%E5%86%99-equals-%E6%97%B6%E5%BF%85%E9%A1%BB%E9%87%8D%E5%86%99-hashCode-%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="nav-number">1.1.2.</span> <span class="nav-text">为什么重写 equals 时必须重写 hashCode 方法？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-%E7%A7%8D%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8C%85%E8%A3%85%E7%B1%BB%E5%92%8C%E5%B8%B8%E9%87%8F%E6%B1%A0"><span class="nav-number">1.1.3.</span> <span class="nav-text">8 种基本类型的包装类和常量池</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E4%B8%8E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%9A%84%E5%8C%BA%E5%88%AB%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="nav-number">1.1.4.</span> <span class="nav-text">成员变量与局部变量的区别有哪些？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E4%BB%8E%E5%AD%90%E7%B1%BB%E8%B0%83%E7%94%A8%E7%88%B6%E7%B1%BB%E7%9A%84private%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="nav-number">1.1.5.</span> <span class="nav-text">如何从子类调用父类的private属性和方法？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#String-StringBuffer-%E5%92%8C-StringBuilder-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88-String-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%9A%84-%E4%B8%8D%E5%8F%AF%E5%8F%98%E6%9C%89%E4%BB%80%E4%B9%88%E5%A5%BD%E5%A4%84"><span class="nav-number">1.1.6.</span> <span class="nav-text">**String StringBuffer 和 StringBuilder 的区别是什么? String 为什么是不可变的?**不可变有什么好处?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E5%BC%95%E7%94%A8%E6%8B%B7%E8%B4%9D%E5%8C%BA%E5%88%AB"><span class="nav-number">1.1.7.</span> <span class="nav-text">浅拷贝和引用拷贝区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-number">1.1.8.</span> <span class="nav-text">反射机制优缺点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8"><span class="nav-number">1.1.9.</span> <span class="nav-text">异常</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java-%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%AD%E5%A6%82%E6%9E%9C%E6%9C%89%E4%BA%9B%E5%AD%97%E6%AE%B5%E4%B8%8D%E6%83%B3%E8%BF%9B%E8%A1%8C%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%8C%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F"><span class="nav-number">1.1.10.</span> <span class="nav-text">Java 序列化中如果有些字段不想进行序列化，怎么办？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java%E4%B8%AD%E5%8F%AA%E6%9C%89%E5%80%BC%E4%BC%A0%E9%80%92"><span class="nav-number">1.1.11.</span> <span class="nav-text">Java中只有值传递</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#BIO-NIO-AIO"><span class="nav-number">1.1.12.</span> <span class="nav-text">BIO NIO AIO</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JDK%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%92%8CCGLIB%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%AF%B9%E6%AF%94"><span class="nav-number">1.1.13.</span> <span class="nav-text">JDK动态代理和CGLIB动态代理对比</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3"><span class="nav-number">1.1.14.</span> <span class="nav-text">抽象类和接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%9A%E4%B8%BE%E7%B1%BB"><span class="nav-number">1.1.15.</span> <span class="nav-text">枚举类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IO%E7%B1%BB"><span class="nav-number">1.1.16.</span> <span class="nav-text">IO类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93"><span class="nav-number">1.1.17.</span> <span class="nav-text">设计模式总结</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95"><span class="nav-number">1.1.18.</span> <span class="nav-text">排序算法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9B%86%E5%90%88"><span class="nav-number">1.2.</span> <span class="nav-text">集合</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ArrayList%E6%89%A9%E5%AE%B9"><span class="nav-number">1.2.1.</span> <span class="nav-text">ArrayList扩容</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Set"><span class="nav-number">1.2.2.</span> <span class="nav-text">Set</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%97%A0%E5%BA%8F%E6%80%A7%E5%92%8C%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E6%80%A7%E7%9A%84%E5%90%AB%E4%B9%89%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">1.2.2.1.</span> <span class="nav-text">无序性和不可重复性的含义是什么?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AF%94%E8%BE%83-HashSet%E3%80%81LinkedHashSet-%E5%92%8C-TreeSet-%E4%B8%89%E8%80%85%E7%9A%84%E5%BC%82%E5%90%8C"><span class="nav-number">1.2.2.2.</span> <span class="nav-text">比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Queue"><span class="nav-number">1.2.3.</span> <span class="nav-text">Queue</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ArrayDeque-%E4%B8%8E-LinkedList-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.2.3.1.</span> <span class="nav-text">ArrayDeque 与 LinkedList 的区别</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Map"><span class="nav-number">1.2.4.</span> <span class="nav-text">Map</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#HashMap%E5%92%8CHashTable%E5%8C%BA%E5%88%AB"><span class="nav-number">1.2.4.1.</span> <span class="nav-text">HashMap和HashTable区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HashMap-%E3%80%81TreeMap%E5%92%8CLinkedHashMap%E5%8C%BA%E5%88%AB"><span class="nav-number">1.2.4.2.</span> <span class="nav-text">HashMap 、TreeMap和LinkedHashMap区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HashSet%E6%A3%80%E6%B5%8B%E9%87%8D%E5%A4%8D"><span class="nav-number">1.2.4.3.</span> <span class="nav-text">HashSet检测重复</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HashMap%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.2.4.4.</span> <span class="nav-text">HashMap底层实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HashMap-%E7%9A%84%E9%95%BF%E5%BA%A6%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF-2-%E7%9A%84%E5%B9%82%E6%AC%A1%E6%96%B9"><span class="nav-number">1.2.4.5.</span> <span class="nav-text">HashMap 的长度为什么是 2 的幂次方</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HashMap%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%93%8D%E4%BD%9C%E5%AF%BC%E8%87%B4%E6%AD%BB%E5%BE%AA%E7%8E%AF"><span class="nav-number">1.2.4.6.</span> <span class="nav-text">HashMap多线程操作导致死循环</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ConcurrentHashMap%E5%92%8CHashTable%E5%8C%BA%E5%88%AB"><span class="nav-number">1.2.4.7.</span> <span class="nav-text">ConcurrentHashMap和HashTable区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ConcurrentHashMap%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95"><span class="nav-number">1.2.4.8.</span> <span class="nav-text">ConcurrentHashMap线程安全具体实现方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ConcurrentHashMap%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.2.4.9.</span> <span class="nav-text">ConcurrentHashMap底层实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Hash%E5%86%B2%E7%AA%81%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="nav-number">1.2.4.10.</span> <span class="nav-text">Hash冲突解决方案</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91"><span class="nav-number">1.3.</span> <span class="nav-text">并发</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8%E3%80%81%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88%E5%92%8C%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E7%A7%81%E6%9C%89%E7%9A%84%EF%BC%9F"><span class="nav-number">1.3.1.</span> <span class="nav-text">为什么程序计数器、虚拟机栈和本地方法栈是线程私有的？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%9F"><span class="nav-number">1.3.2.</span> <span class="nav-text">为什么要使用多线程？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81"><span class="nav-number">1.3.3.</span> <span class="nav-text">线程状态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%AD%BB%E9%94%81%EF%BC%8C%E4%BA%A7%E7%94%9F%E6%AD%BB%E9%94%81%E7%9A%84%E6%9D%A1%E4%BB%B6"><span class="nav-number">1.3.4.</span> <span class="nav-text">什么是死锁，产生死锁的条件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E6%AD%BB%E9%94%81"><span class="nav-number">1.3.5.</span> <span class="nav-text">如何避免死锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sleep%E5%92%8Cwait%E6%96%B9%E6%B3%95%E5%8C%BA%E5%88%AB%E5%92%8C%E5%85%B1%E5%90%8C%E7%82%B9"><span class="nav-number">1.3.6.</span> <span class="nav-text">sleep和wait方法区别和共同点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E4%BB%AC%E8%B0%83%E7%94%A8-start-%E6%96%B9%E6%B3%95%E6%97%B6%E4%BC%9A%E6%89%A7%E8%A1%8C-run-%E6%96%B9%E6%B3%95%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E4%BB%AC%E4%B8%8D%E8%83%BD%E7%9B%B4%E6%8E%A5%E8%B0%83%E7%94%A8-run-%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="nav-number">1.3.7.</span> <span class="nav-text">为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run() 方法？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#synchronized%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-number">1.3.8.</span> <span class="nav-text">synchronized关键字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#synchronized%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86"><span class="nav-number">1.3.9.</span> <span class="nav-text">synchronized底层原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JDK1-6-%E4%B9%8B%E5%90%8E%E7%9A%84-synchronized-%E5%85%B3%E9%94%AE%E5%AD%97%E5%BA%95%E5%B1%82%E5%81%9A%E4%BA%86%E5%93%AA%E4%BA%9B%E4%BC%98%E5%8C%96"><span class="nav-number">1.3.10.</span> <span class="nav-text">JDK1.6 之后的 synchronized 关键字底层做了哪些优化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88JDK8%E5%9C%A84s%E4%B9%8B%E5%90%8E%E6%89%8D%E5%BC%80%E5%90%AF%E5%81%8F%E5%90%91%E9%94%81%EF%BC%9F"><span class="nav-number">1.3.11.</span> <span class="nav-text">为什么JDK8在4s之后才开启偏向锁？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#synchronized-%E5%92%8C-ReentrantLock-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.3.12.</span> <span class="nav-text">synchronized 和 ReentrantLock 的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E4%B8%89%E4%B8%AA%E9%87%8D%E8%A6%81%E7%89%B9%E6%80%A7"><span class="nav-number">1.3.13.</span> <span class="nav-text">并发编程的三个重要特性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#volatile%E5%92%8Csynchronized%E5%85%B3%E9%94%AE%E5%AD%97%E5%8C%BA%E5%88%AB"><span class="nav-number">1.3.14.</span> <span class="nav-text">volatile和synchronized关键字区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ThreadLocal%E5%8E%9F%E7%90%86"><span class="nav-number">1.3.15.</span> <span class="nav-text">ThreadLocal原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ThreadLocal-%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E9%97%AE%E9%A2%98"><span class="nav-number">1.3.16.</span> <span class="nav-text">ThreadLocal 内存泄露问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ThreadLocalMap"><span class="nav-number">1.3.17.</span> <span class="nav-text">ThreadLocalMap</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%A5%BD%E5%A4%84"><span class="nav-number">1.3.18.</span> <span class="nav-text">线程池的好处</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E7%8A%B6%E6%80%81"><span class="nav-number">1.3.19.</span> <span class="nav-text">线程池的状态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0-Runnable-%E6%8E%A5%E5%8F%A3%E5%92%8C-Callable-%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.3.20.</span> <span class="nav-text">实现 Runnable 接口和 Callable 接口的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%A7%E8%A1%8C-execute-%E6%96%B9%E6%B3%95%E5%92%8C-submit-%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%E5%91%A2%EF%BC%9F"><span class="nav-number">1.3.21.</span> <span class="nav-text">执行 execute()方法和 submit()方法的区别是什么呢？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ThreadPoolExecutor%E5%8F%82%E6%95%B0%E5%88%86%E6%9E%90"><span class="nav-number">1.3.22.</span> <span class="nav-text">ThreadPoolExecutor参数分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#FixedThreadPool%E3%80%81SingleThreadExecutor%E5%92%8CCachedThreadPool"><span class="nav-number">1.3.23.</span> <span class="nav-text">FixedThreadPool、SingleThreadExecutor和CachedThreadPool</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Atomic%E5%8E%9F%E5%AD%90%E7%B1%BB%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="nav-number">1.3.24.</span> <span class="nav-text">Atomic原子类有哪些</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AtomicInteger-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E5%8E%9F%E7%90%86%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90"><span class="nav-number">1.3.25.</span> <span class="nav-text">AtomicInteger 线程安全原理简单分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AQS%E5%8E%9F%E7%90%86"><span class="nav-number">1.3.26.</span> <span class="nav-text">AQS原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AQS-%E7%BB%84%E4%BB%B6%E6%80%BB%E7%BB%93"><span class="nav-number">1.3.27.</span> <span class="nav-text">AQS 组件总结</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CopyOnWriteArrayList"><span class="nav-number">1.3.28.</span> <span class="nav-text">CopyOnWriteArrayList</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Blocking-Queue"><span class="nav-number">1.3.29.</span> <span class="nav-text">Blocking Queue</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JVM"><span class="nav-number">1.4.</span> <span class="nav-text">JVM</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F"><span class="nav-number">1.4.1.</span> <span class="nav-text">内存区域</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F"><span class="nav-number">1.4.1.1.</span> <span class="nav-text">运行时数据区域</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%A7%81%E6%9C%89%E5%8C%BA%E5%9F%9F"><span class="nav-number">1.4.1.2.</span> <span class="nav-text">线程私有区域</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A0%86"><span class="nav-number">1.4.1.3.</span> <span class="nav-text">堆</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A0%86%E3%80%81%E6%A0%88%E5%92%8C%E6%96%B9%E6%B3%95%E5%8C%BA%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-number">1.4.1.4.</span> <span class="nav-text">堆、栈和方法区的关系</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E5%85%83%E7%A9%BA%E9%97%B4%E4%BB%A3%E6%9B%BF%E6%96%B9%E6%B3%95%E5%8C%BA"><span class="nav-number">1.4.1.5.</span> <span class="nav-text">为什么要使用元空间代替方法区</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JVM-%E5%B8%B8%E9%87%8F%E6%B1%A0%E4%B8%AD%E5%AD%98%E5%82%A8%E7%9A%84%E6%98%AF%E5%AF%B9%E8%B1%A1%E8%BF%98%E6%98%AF%E5%BC%95%E7%94%A8%E5%91%A2"><span class="nav-number">1.4.1.6.</span> <span class="nav-text">JVM 常量池中存储的是对象还是引用呢?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E5%88%86%E9%85%8D%E8%BF%87%E7%A8%8B"><span class="nav-number">1.4.1.7.</span> <span class="nav-text">对象分配过程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B"><span class="nav-number">1.4.1.8.</span> <span class="nav-text">对象的创建过程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80"><span class="nav-number">1.4.1.9.</span> <span class="nav-text">对象的内存布局</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%B8%E9%87%8F%E6%B1%A0%E9%97%AE%E9%A2%98"><span class="nav-number">1.4.1.10.</span> <span class="nav-text">常量池问题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="nav-number">1.4.2.</span> <span class="nav-text">垃圾回收</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A9%BA%E9%97%B4%E6%8B%85%E4%BF%9D"><span class="nav-number">1.4.2.1.</span> <span class="nav-text">空间担保</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E6%AD%BB%E4%BA%A1%EF%BC%9F"><span class="nav-number">1.4.2.2.</span> <span class="nav-text">判断对象死亡？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%95%E7%94%A8%E5%88%86%E7%B1%BB"><span class="nav-number">1.4.2.3.</span> <span class="nav-text">引用分类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E5%B8%B8%E9%87%8F%E6%98%AF%E5%BA%9F%E5%BC%83%E7%9A%84%EF%BC%9F%E6%88%96%E8%80%85%E4%B8%80%E4%B8%AA%E7%B1%BB%E6%98%AF%E6%97%A0%E7%94%A8%E7%9A%84%E7%B1%BB%EF%BC%9F"><span class="nav-number">1.4.2.4.</span> <span class="nav-text">如何判断一个常量是废弃的？或者一个类是无用的类？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95"><span class="nav-number">1.4.2.5.</span> <span class="nav-text">垃圾回收算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HotSpot-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%88%86%E4%B8%BA%E6%96%B0%E7%94%9F%E4%BB%A3%E5%92%8C%E8%80%81%E5%B9%B4%E4%BB%A3%EF%BC%9F"><span class="nav-number">1.4.2.6.</span> <span class="nav-text">HotSpot 为什么要分为新生代和老年代？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8"><span class="nav-number">1.4.2.7.</span> <span class="nav-text">垃圾回收器</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD"><span class="nav-number">1.4.3.</span> <span class="nav-text">类加载</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B"><span class="nav-number">1.4.3.1.</span> <span class="nav-text">类加载过程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%88%86%E7%B1%BB"><span class="nav-number">1.4.3.2.</span> <span class="nav-text">类加载器分类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6"><span class="nav-number">1.4.3.3.</span> <span class="nav-text">双亲委派机制</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java8%E6%96%B0%E7%89%B9%E6%80%A7"><span class="nav-number">1.5.</span> <span class="nav-text">Java8新特性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Interface"><span class="nav-number">1.5.1.</span> <span class="nav-text">Interface</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Stream%E6%B5%81"><span class="nav-number">1.5.2.</span> <span class="nav-text">Stream流</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93-amp-%E4%B8%AD%E9%97%B4%E4%BB%B6"><span class="nav-number">2.</span> <span class="nav-text">数据库 &amp; 中间件</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#MySQL"><span class="nav-number">2.1.</span> <span class="nav-text">MySQL</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80-1"><span class="nav-number">2.1.1.</span> <span class="nav-text">基础</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%89%E5%A4%A7%E8%8C%83%E5%BC%8F"><span class="nav-number">2.1.1.1.</span> <span class="nav-text">三大范式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#drop%E3%80%81delete%E3%80%81%E5%92%8Ctruncate%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">2.1.1.2.</span> <span class="nav-text">drop、delete、和truncate区别？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%BE%E8%AE%A1%E6%95%B0%E6%8D%AE%E9%9B%86%E6%AD%A5%E9%AA%A4"><span class="nav-number">2.1.1.3.</span> <span class="nav-text">设计数据集步骤</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#MyISAM%E5%92%8CInnoDB%E5%8C%BA%E5%88%AB"><span class="nav-number">2.1.1.4.</span> <span class="nav-text">MyISAM和InnoDB区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1ACID%E7%89%B9%E6%80%A7"><span class="nav-number">2.1.1.5.</span> <span class="nav-text">事务ACID特性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E4%BA%8B%E5%8A%A1%E5%B8%A6%E6%9D%A5%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-number">2.1.1.6.</span> <span class="nav-text">并发事务带来的问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="nav-number">2.1.1.7.</span> <span class="nav-text">事务隔离级别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#join%E7%9A%84%E4%BD%BF%E7%94%A8%E5%92%8C%E5%8E%9F%E7%90%86"><span class="nav-number">2.1.1.8.</span> <span class="nav-text">join的使用和原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SQL%E8%AF%AD%E5%8F%A5%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="nav-number">2.1.1.9.</span> <span class="nav-text">SQL语句执行流程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#datetime%E5%92%8Ctimestamp%E5%8C%BA%E5%88%AB"><span class="nav-number">2.1.1.10.</span> <span class="nav-text">datetime和timestamp区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#varchar%E5%92%8Cchar%E5%8C%BA%E5%88%AB"><span class="nav-number">2.1.1.11.</span> <span class="nav-text">varchar和char区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#in%E5%92%8Cexists%E5%8C%BA%E5%88%AB"><span class="nav-number">2.1.1.12.</span> <span class="nav-text">in和exists区别</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%AB%98%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="nav-number">2.1.2.</span> <span class="nav-text">高性能优化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%97%E6%AE%B5%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83"><span class="nav-number">2.1.2.1.</span> <span class="nav-text">字段设计规范</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83"><span class="nav-number">2.1.2.2.</span> <span class="nav-text">索引设计规范</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B6%85-100-%E4%B8%87%E8%A1%8C%E7%9A%84%E6%89%B9%E9%87%8F%E5%86%99-UPDATE-DELETE-INSERT-%E6%93%8D%E4%BD%9C-%E8%A6%81%E5%88%86%E6%89%B9%E5%A4%9A%E6%AC%A1%E8%BF%9B%E8%A1%8C%E6%93%8D%E4%BD%9C"><span class="nav-number">2.1.2.3.</span> <span class="nav-text">超 100 万行的批量写 (UPDATE,DELETE,INSERT) 操作,要分批多次进行操作</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E8%AF%A6%E8%A7%A3"><span class="nav-number">2.1.3.</span> <span class="nav-text">索引详解</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-number">2.1.3.1.</span> <span class="nav-text">索引优缺点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E4%BD%BF%E7%94%A8HashMap"><span class="nav-number">2.1.3.2.</span> <span class="nav-text">索引底层数据结构？为什么不使用HashMap?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E7%B1%BB%E5%9E%8B"><span class="nav-number">2.1.3.3.</span> <span class="nav-text">索引类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E5%92%8C%E6%99%AE%E9%80%9A%E7%B4%A2%E5%BC%95"><span class="nav-number">2.1.3.4.</span> <span class="nav-text">唯一索引和普通索引</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95%E5%92%8C%E9%9D%9E%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95"><span class="nav-number">2.1.3.5.</span> <span class="nav-text">聚集索引和非聚集索引</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95"><span class="nav-number">2.1.3.6.</span> <span class="nav-text">覆盖索引</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88"><span class="nav-number">2.1.3.7.</span> <span class="nav-text">索引失效</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BB%BA%E7%AB%8B%E7%B4%A2%E5%BC%95%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-number">2.1.3.8.</span> <span class="nav-text">建立索引的注意事项</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95"><span class="nav-number">2.1.3.9.</span> <span class="nav-text">联合索引</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%A5%E5%BF%97"><span class="nav-number">2.1.4.</span> <span class="nav-text">日志</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#redo-log-%E9%87%8D%E5%81%9A%E6%97%A5%E5%BF%97"><span class="nav-number">2.1.4.1.</span> <span class="nav-text">redo log(重做日志)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#binlog"><span class="nav-number">2.1.4.2.</span> <span class="nav-text">binlog</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4"><span class="nav-number">2.1.4.3.</span> <span class="nav-text">两阶段提交</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undo-log-%E5%9B%9E%E6%BB%9A%E6%97%A5%E5%BF%97"><span class="nav-number">2.1.4.4.</span> <span class="nav-text">undo log(回滚日志)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MVCC"><span class="nav-number">2.1.5.</span> <span class="nav-text">MVCC</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#InnoDB%E5%AF%B9MVCC%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">2.1.5.1.</span> <span class="nav-text">InnoDB对MVCC的实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#RC%E5%92%8CRR%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E4%B8%8BMVCC%E7%9A%84ReadView%E7%94%9F%E6%88%90%E6%97%B6%E6%9C%BA%E4%B8%8D%E5%90%8C"><span class="nav-number">2.1.5.2.</span> <span class="nav-text">RC和RR隔离级别下MVCC的ReadView生成时机不同</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#MVCC-Next-key-Lock%E9%98%B2%E6%AD%A2%E5%B9%BB%E8%AF%BB%EF%BC%88RR%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%EF%BC%89"><span class="nav-number">2.1.5.3.</span> <span class="nav-text">MVCC+Next-key-Lock防止幻读（RR隔离级别）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%94%81"><span class="nav-number">2.1.6.</span> <span class="nav-text">锁</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%94%81%E5%88%86%E7%B1%BB"><span class="nav-number">2.1.6.1.</span> <span class="nav-text">锁分类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%A4%E9%98%B6%E6%AE%B5%E9%94%81"><span class="nav-number">2.1.6.2.</span> <span class="nav-text">两阶段锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8A%A0%E9%94%81%E5%8E%9F%E5%88%99"><span class="nav-number">2.1.6.3.</span> <span class="nav-text">加锁原则</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%89%B9%E6%AE%8A%E6%83%85%E5%86%B5%E5%A4%84%E7%90%86"><span class="nav-number">2.1.7.</span> <span class="nav-text">特殊情况处理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B6%85%E5%A4%A7%E5%88%86%E9%A1%B5%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%EF%BC%9F"><span class="nav-number">2.1.7.1.</span> <span class="nav-text">超大分页如何处理？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BC%98%E5%8C%96SQL%EF%BC%9F"><span class="nav-number">2.1.7.2.</span> <span class="nav-text">优化SQL？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%BB%E9%94%AE%E6%96%B9%E6%A1%88%EF%BC%9F"><span class="nav-number">2.1.7.3.</span> <span class="nav-text">分布式主键方案？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%EF%BC%9F"><span class="nav-number">2.1.7.4.</span> <span class="nav-text">分库分表？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%A7%E8%A1%A8%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96"><span class="nav-number">2.1.7.5.</span> <span class="nav-text">大表查询优化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6"><span class="nav-number">2.1.7.6.</span> <span class="nav-text">主从复制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%90%8C%E6%AD%A5%E6%96%B9%E5%BC%8F"><span class="nav-number">2.1.7.7.</span> <span class="nav-text">主从复制同步方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Mysql%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5%E5%BB%B6%E6%97%B6%E4%BA%A7%E7%94%9F%E5%8E%9F%E5%9B%A0-%E6%80%8E%E4%B9%88%E4%BC%98%E5%8C%96%EF%BC%9F"><span class="nav-number">2.1.7.8.</span> <span class="nav-text">Mysql主从同步延时产生原因?怎么优化？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis"><span class="nav-number">2.2.</span> <span class="nav-text">Redis</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BF%AB%EF%BC%9F"><span class="nav-number">2.2.1.</span> <span class="nav-text">Redis为什么快？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="nav-number">2.2.2.</span> <span class="nav-text">Redis应用场景有哪些？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="nav-number">2.2.3.</span> <span class="nav-text">Redis 数据类型有哪些？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%81%E4%B9%85%E5%8C%96"><span class="nav-number">2.2.4.</span> <span class="nav-text">持久化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6-1"><span class="nav-number">2.2.5.</span> <span class="nav-text">主从复制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%87%E6%9C%9F%E9%94%AE%E7%9A%84%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5%EF%BC%9F"><span class="nav-number">2.2.6.</span> <span class="nav-text">过期键的删除策略？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="nav-number">2.2.7.</span> <span class="nav-text">内存淘汰策略有哪些？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E7%BC%93%E5%AD%98%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8F%8C%E5%86%99%E6%97%B6%E7%9A%84%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7%EF%BC%9F"><span class="nav-number">2.2.8.</span> <span class="nav-text">如何保证缓存与数据库双写时的数据一致性？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#kafka"><span class="nav-number">2.3.</span> <span class="nav-text">kafka</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">2.3.1.</span> <span class="nav-text">使用场景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#kafka%E7%9A%84%E6%B6%88%E8%B4%B9%E8%80%85%E6%98%AFpull%E8%BF%98%E6%98%AFpush%E6%A8%A1%E5%BC%8F%EF%BC%8C%E8%BF%99%E7%A7%8D%E6%A8%A1%E5%BC%8F%E6%9C%89%E4%BB%80%E4%B9%88%E5%A5%BD%E5%A4%84%EF%BC%9F"><span class="nav-number">2.3.2.</span> <span class="nav-text">kafka的消费者是pull还是push模式，这种模式有什么好处？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#kafka%E9%9B%86%E7%BE%A4%E7%BB%84%E6%88%90"><span class="nav-number">2.3.3.</span> <span class="nav-text">kafka集群组成</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#kafka%E6%B6%88%E6%81%AF%E5%8F%AF%E9%9D%A0%E6%80%A7"><span class="nav-number">2.3.4.</span> <span class="nav-text">kafka消息可靠性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#kafka%E6%95%85%E9%9A%9C%E6%81%A2%E5%A4%8D"><span class="nav-number">2.3.5.</span> <span class="nav-text">kafka故障恢复</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#kafka%E9%AB%98%E6%80%A7%E8%83%BD"><span class="nav-number">2.3.6.</span> <span class="nav-text">kafka高性能</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#thrift"><span class="nav-number">2.4.</span> <span class="nav-text">thrift</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E8%B0%83%E7%94%A8%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="nav-number">2.4.1.</span> <span class="nav-text">远程服务调用的执行过程</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="nav-number">3.</span> <span class="nav-text">操作系统</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B"><span class="nav-number">3.1.</span> <span class="nav-text">进程与线程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81"><span class="nav-number">3.2.</span> <span class="nav-text">进程状态</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F"><span class="nav-number">3.3.</span> <span class="nav-text">进程通信方式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%95%E6%A0%B8%E6%9C%BA%E5%99%A8%E4%B8%8A%E5%86%99%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%A8%8B%E5%BA%8F%EF%BC%8C%E6%98%AF%E5%90%A6%E9%9C%80%E8%A6%81%E8%80%83%E8%99%91%E5%8A%A0%E9%94%81%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">3.4.</span> <span class="nav-text">单核机器上写多线程程序，是否需要考虑加锁，为什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%8F%E7%A8%8B%EF%BC%88%E5%BE%AE%E7%BA%BF%E7%A8%8B%EF%BC%8C%E6%9E%81%E9%AB%98%E7%9A%84%E8%BF%90%E8%A1%8C%E6%95%88%E7%8E%87%EF%BC%8C%E6%B2%A1%E6%9C%89%E7%BA%BF%E7%A8%8B%E5%88%87%E6%8D%A2%E5%BC%80%E9%94%80%E3%80%81%E6%B2%A1%E6%9C%89%E9%94%81%E6%9C%BA%E5%88%B6%E5%BC%80%E9%94%80%EF%BC%89"><span class="nav-number">3.5.</span> <span class="nav-text">协程（微线程，极高的运行效率，没有线程切换开销、没有锁机制开销）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AD%96%E7%95%A5"><span class="nav-number">3.6.</span> <span class="nav-text">进程调度策略</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="nav-number">3.7.</span> <span class="nav-text">内存页面置换算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#IO%E6%A8%A1%E5%9E%8B"><span class="nav-number">3.8.</span> <span class="nav-text">IO模型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2"><span class="nav-number">3.9.</span> <span class="nav-text">上下文切换</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9B%B6%E6%8B%B7%E8%B4%9D"><span class="nav-number">3.10.</span> <span class="nav-text">零拷贝</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Select-poll-epoll"><span class="nav-number">3.11.</span> <span class="nav-text">Select&#x2F;poll&#x2F;epoll</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C"><span class="nav-number">4.</span> <span class="nav-text">计算机网络</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%83%E5%B1%82%E7%BB%93%E6%9E%84%E3%80%81%E5%9B%9B%E5%B1%82%E7%BB%93%E6%9E%84"><span class="nav-number">4.1.</span> <span class="nav-text">七层结构、四层结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BE%93%E5%85%A5%E7%BD%91%E5%9D%80%E5%88%B0%E9%A1%B5%E9%9D%A2%E6%98%BE%E7%A4%BA%E6%95%B4%E4%B8%AA%E8%BF%87%E7%A8%8B"><span class="nav-number">4.2.</span> <span class="nav-text">输入网址到页面显示整个过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TCP%E5%92%8CUDP%E5%8C%BA%E5%88%AB"><span class="nav-number">4.3.</span> <span class="nav-text">TCP和UDP区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="nav-number">4.4.</span> <span class="nav-text">TCP三次握手，四次挥手</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="nav-number">4.5.</span> <span class="nav-text">为什么是三次握手</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SYN%E6%94%BB%E5%87%BB"><span class="nav-number">4.6.</span> <span class="nav-text">SYN攻击</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="nav-number">4.7.</span> <span class="nav-text">为什么四次挥手</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88TIME-WAIT%E7%AD%89%E5%BE%85%E6%97%B6%E9%97%B4%E4%B8%BA2MSL"><span class="nav-number">4.8.</span> <span class="nav-text">为什么TIME_WAIT等待时间为2MSL</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TCP%E4%BF%9D%E8%AF%81%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93"><span class="nav-number">4.9.</span> <span class="nav-text">TCP保证可靠传输</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TCP%E5%8D%8A%E8%BF%9E%E6%8E%A5%E5%92%8C%E5%85%A8%E8%BF%9E%E6%8E%A5%E9%98%9F%E5%88%97"><span class="nav-number">4.10.</span> <span class="nav-text">TCP半连接和全连接队列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HTTP%E5%92%8CHTTPS%E5%8C%BA%E5%88%AB"><span class="nav-number">4.11.</span> <span class="nav-text">HTTP和HTTPS区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E7%8A%B6%E6%80%81%E7%A0%81"><span class="nav-number">4.12.</span> <span class="nav-text">常见状态码</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#GET%E5%92%8CPOST%E5%8C%BA%E5%88%AB"><span class="nav-number">4.13.</span> <span class="nav-text">GET和POST区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Cookie%E5%92%8CSession%E5%8C%BA%E5%88%AB"><span class="nav-number">4.14.</span> <span class="nav-text">Cookie和Session区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HTTPS%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5%E8%BF%87%E7%A8%8B"><span class="nav-number">4.15.</span> <span class="nav-text">HTTPS建立连接过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CA%E8%AF%81%E4%B9%A6%E9%AA%8C%E8%AF%81%E8%BF%87%E7%A8%8B"><span class="nav-number">4.16.</span> <span class="nav-text">CA证书验证过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HTTP1-1"><span class="nav-number">4.17.</span> <span class="nav-text">HTTP1.1</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HTTP2%E5%9F%BA%E4%BA%8EHTTPS"><span class="nav-number">4.18.</span> <span class="nav-text">HTTP2基于HTTPS</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HTTP%E5%92%8CRPC"><span class="nav-number">4.19.</span> <span class="nav-text">HTTP和RPC</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B"><span class="nav-number">5.</span> <span class="nav-text">多线程编程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Semaphore"><span class="nav-number">5.1.</span> <span class="nav-text">Semaphore</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CyclicBarrier"><span class="nav-number">5.2.</span> <span class="nav-text">CyclicBarrier</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Thread-yield"><span class="nav-number">5.3.</span> <span class="nav-text">Thread.yield()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BlockingQueue"><span class="nav-number">5.4.</span> <span class="nav-text">BlockingQueue</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#synchronized"><span class="nav-number">5.5.</span> <span class="nav-text">synchronized</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1"><span class="nav-number">6.</span> <span class="nav-text">系统设计</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%AB%98%E5%8F%AF%E7%94%A8%E3%80%81%E9%AB%98%E5%B9%B6%E5%8F%91%E3%80%81%E9%AB%98%E6%80%A7%E8%83%BD%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1"><span class="nav-number">6.1.</span> <span class="nav-text">高可用、高并发、高性能系统设计</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F"><span class="nav-number">6.2.</span> <span class="nav-text">分布式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BE%E8%AE%A1%E7%90%86%E5%BF%B5"><span class="nav-number">6.2.1.</span> <span class="nav-text">设计理念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1"><span class="nav-number">6.2.2.</span> <span class="nav-text">分布式事务</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1"><span class="nav-number">6.3.</span> <span class="nav-text">领域驱动设计</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Kaixuan Wang"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Kaixuan Wang</p>
  <div class="site-description" itemprop="description">只争朝夕</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">31</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Kaixuan Wang</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>

<script src="/js/utils.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
